
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>codeflare: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/codeflare/codeflare.go (79.3%)</option>
				
				<option value="file1">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/codeflare/codeflare_controller.go (0.0%)</option>
				
				<option value="file2">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/codeflare/codeflare_controller_actions.go (0.0%)</option>
				
				<option value="file3">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/codeflare/codeflare_support.go (0.0%)</option>
				
				<option value="file4">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/components.go (0.0%)</option>
				
				<option value="file5">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/dashboard/dashboard.go (69.7%)</option>
				
				<option value="file6">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/dashboard/dashboard_controller.go (0.0%)</option>
				
				<option value="file7">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/dashboard/dashboard_controller_actions.go (26.7%)</option>
				
				<option value="file8">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/dashboard/dashboard_support.go (0.0%)</option>
				
				<option value="file9">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/datasciencepipelines/datasciencepipelines.go (71.9%)</option>
				
				<option value="file10">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/datasciencepipelines/datasciencepipelines_controller.go (0.0%)</option>
				
				<option value="file11">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/datasciencepipelines/datasciencepipelines_controller_actions.go (60.4%)</option>
				
				<option value="file12">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/datasciencepipelines/datasciencepipelines_support.go (0.0%)</option>
				
				<option value="file13">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/feastoperator/feastoperator.go (79.3%)</option>
				
				<option value="file14">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/feastoperator/feastoperator_controller.go (0.0%)</option>
				
				<option value="file15">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/feastoperator/feastoperator_controller_actions.go (0.0%)</option>
				
				<option value="file16">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/feastoperator/feastoperator_support.go (0.0%)</option>
				
				<option value="file17">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/kserve/config.go (0.0%)</option>
				
				<option value="file18">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/kserve/kserve.go (76.7%)</option>
				
				<option value="file19">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/kserve/kserve_controller.go (0.0%)</option>
				
				<option value="file20">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/kserve/kserve_controller_actions.go (25.6%)</option>
				
				<option value="file21">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/kserve/kserve_support.go (15.7%)</option>
				
				<option value="file22">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/kueue/kueue.go (81.2%)</option>
				
				<option value="file23">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/kueue/kueue_config.go (87.0%)</option>
				
				<option value="file24">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/kueue/kueue_controller.go (0.0%)</option>
				
				<option value="file25">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/kueue/kueue_controller_actions.go (73.7%)</option>
				
				<option value="file26">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/kueue/kueue_support.go (82.1%)</option>
				
				<option value="file27">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelcontroller/modelcontroller.go (84.2%)</option>
				
				<option value="file28">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelcontroller/modelcontroller_actions.go (0.0%)</option>
				
				<option value="file29">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelcontroller/modelcontroller_controller.go (0.0%)</option>
				
				<option value="file30">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelcontroller/modelcontroller_support.go (0.0%)</option>
				
				<option value="file31">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelmeshserving/modelmeshserving.go (79.3%)</option>
				
				<option value="file32">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelmeshserving/modelmeshserving_actions.go (0.0%)</option>
				
				<option value="file33">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelmeshserving/modelmeshserving_controller.go (0.0%)</option>
				
				<option value="file34">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelmeshserving/modelmeshserving_support.go (0.0%)</option>
				
				<option value="file35">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelregistry/modelregistry.go (76.7%)</option>
				
				<option value="file36">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelregistry/modelregistry_controller.go (0.0%)</option>
				
				<option value="file37">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelregistry/modelregistry_controller_actions.go (0.0%)</option>
				
				<option value="file38">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelregistry/modelregistry_support.go (0.0%)</option>
				
				<option value="file39">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/ray/ray.go (79.3%)</option>
				
				<option value="file40">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/ray/ray_controller.go (0.0%)</option>
				
				<option value="file41">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/ray/ray_controller_actions.go (0.0%)</option>
				
				<option value="file42">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/ray/ray_support.go (0.0%)</option>
				
				<option value="file43">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/trainingoperator/trainingoperator.go (79.3%)</option>
				
				<option value="file44">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/trainingoperator/trainingoperator_controller.go (0.0%)</option>
				
				<option value="file45">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/trainingoperator/trainingoperator_controller_actions.go (0.0%)</option>
				
				<option value="file46">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/trainingoperator/trainingoperator_support.go (0.0%)</option>
				
				<option value="file47">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/trustyai/trustyai.go (76.7%)</option>
				
				<option value="file48">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/trustyai/trustyai_controller.go (0.0%)</option>
				
				<option value="file49">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/trustyai/trustyai_controller_actions.go (0.0%)</option>
				
				<option value="file50">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/trustyai/trustyai_support.go (0.0%)</option>
				
				<option value="file51">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/workbenches/workbenches.go (63.9%)</option>
				
				<option value="file52">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/workbenches/workbenches_controller.go (0.0%)</option>
				
				<option value="file53">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/workbenches/workbenches_controller_actions.go (0.0%)</option>
				
				<option value="file54">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/workbenches/workbenches_support.go (0.0%)</option>
				
				<option value="file55">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/dscinitialization/auth.go (84.6%)</option>
				
				<option value="file56">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/dscinitialization/dscinitialization_controller.go (39.4%)</option>
				
				<option value="file57">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/dscinitialization/monitoring.go (0.0%)</option>
				
				<option value="file58">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/dscinitialization/utils.go (49.5%)</option>
				
				<option value="file59">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/auth/auth.go (83.3%)</option>
				
				<option value="file60">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/auth/auth_controller.go (50.0%)</option>
				
				<option value="file61">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/auth/auth_controller_actions.go (69.1%)</option>
				
				<option value="file62">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/certconfigmapgenerator/certconfigmapgenerator.go (14.3%)</option>
				
				<option value="file63">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/certconfigmapgenerator/certconfigmapgenerator_controller.go (78.7%)</option>
				
				<option value="file64">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/certconfigmapgenerator/certconfigmapgenerator_support.go (82.9%)</option>
				
				<option value="file65">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/monitoring/monitoring.go (0.0%)</option>
				
				<option value="file66">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/monitoring/monitoring_controller.go (6.2%)</option>
				
				<option value="file67">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/monitoring/monitoring_controller_actions.go (0.0%)</option>
				
				<option value="file68">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/monitoring/monitoring_controller_support.go (45.9%)</option>
				
				<option value="file69">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/secretgenerator/secret.go (89.2%)</option>
				
				<option value="file70">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/secretgenerator/secretgenerator.go (12.5%)</option>
				
				<option value="file71">github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/secretgenerator/secretgenerator_controller.go (0.0%)</option>
				
				<option value="file72">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/datasciencecluster/defaulting.go (77.8%)</option>
				
				<option value="file73">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/datasciencecluster/register.go (60.0%)</option>
				
				<option value="file74">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/datasciencecluster/validating.go (100.0%)</option>
				
				<option value="file75">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/dscinitialization/register.go (66.7%)</option>
				
				<option value="file76">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/dscinitialization/validating.go (92.3%)</option>
				
				<option value="file77">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/hardwareprofile/mutating.go (86.9%)</option>
				
				<option value="file78">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/hardwareprofile/register.go (66.7%)</option>
				
				<option value="file79">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/inferenceservice/mutating.go (75.6%)</option>
				
				<option value="file80">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/inferenceservice/register.go (0.0%)</option>
				
				<option value="file81">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/kueue/register.go (0.0%)</option>
				
				<option value="file82">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/kueue/validating.go (82.8%)</option>
				
				<option value="file83">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/notebook/mutating.go (82.5%)</option>
				
				<option value="file84">github.com/opendatahub-io/opendatahub-operator/v2/internal/webhook/notebook/register.go (0.0%)</option>
				
				<option value="file85">github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/cert.go (0.0%)</option>
				
				<option value="file86">github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/cluster_config.go (7.7%)</option>
				
				<option value="file87">github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/meta.go (75.8%)</option>
				
				<option value="file88">github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/operator.go (0.0%)</option>
				
				<option value="file89">github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/resources.go (48.1%)</option>
				
				<option value="file90">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/cacher/cacher.go (100.0%)</option>
				
				<option value="file91">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deleteresource/action_delete_resources.go (79.2%)</option>
				
				<option value="file92">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy/action_deploy.go (66.3%)</option>
				
				<option value="file93">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy/action_deploy_cache.go (79.4%)</option>
				
				<option value="file94">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy/action_deploy_merge_deployment.go (76.5%)</option>
				
				<option value="file95">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy/action_deploy_metrics.go (100.0%)</option>
				
				<option value="file96">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy/action_deploy_remove_deployment_resources.go (82.4%)</option>
				
				<option value="file97">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy/action_deploy_support.go (64.7%)</option>
				
				<option value="file98">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc/action_gc.go (75.4%)</option>
				
				<option value="file99">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc/action_gc_metrics.go (100.0%)</option>
				
				<option value="file100">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc/action_gc_support.go (78.9%)</option>
				
				<option value="file101">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize/action_render_manifests.go (75.9%)</option>
				
				<option value="file102">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/template/action_render_templates.go (93.0%)</option>
				
				<option value="file103">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/resourcecacher/resourcecacher.go (94.7%)</option>
				
				<option value="file104">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments/action_deployments_available.go (67.4%)</option>
				
				<option value="file105">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases/action_fetch_releases_status.go (89.7%)</option>
				
				<option value="file106">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions/conditions.go (73.5%)</option>
				
				<option value="file107">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions/conditions_support.go (90.9%)</option>
				
				<option value="file108">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources/resources.go (17.7%)</option>
				
				<option value="file109">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler/reconciler.go (67.2%)</option>
				
				<option value="file110">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler/reconciler_actions.go (74.1%)</option>
				
				<option value="file111">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler/reconciler_metrics.go (100.0%)</option>
				
				<option value="file112">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler/reconciler_support.go (37.1%)</option>
				
				<option value="file113">github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types/types.go (41.7%)</option>
				
				<option value="file114">github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/builder.go (0.0%)</option>
				
				<option value="file115">github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/conditions.go (0.0%)</option>
				
				<option value="file116">github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/feature.go (0.0%)</option>
				
				<option value="file117">github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/feature_data.go (0.0%)</option>
				
				<option value="file118">github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/feature_tracker_handler.go (0.0%)</option>
				
				<option value="file119">github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/handler.go (0.0%)</option>
				
				<option value="file120">github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/manifest/builder.go (0.0%)</option>
				
				<option value="file121">github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/manifest/types.go (41.9%)</option>
				
				<option value="file122">github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/provider/types.go (88.9%)</option>
				
				<option value="file123">github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/resources.go (0.0%)</option>
				
				<option value="file124">github.com/opendatahub-io/opendatahub-operator/v2/pkg/manifests/kustomize/kustomize.go (100.0%)</option>
				
				<option value="file125">github.com/opendatahub-io/opendatahub-operator/v2/pkg/manifests/kustomize/kustomize_engine.go (75.7%)</option>
				
				<option value="file126">github.com/opendatahub-io/opendatahub-operator/v2/pkg/manifests/kustomize/kustomize_filters.go (0.0%)</option>
				
				<option value="file127">github.com/opendatahub-io/opendatahub-operator/v2/pkg/manifests/kustomize/kustomize_opts.go (40.0%)</option>
				
				<option value="file128">github.com/opendatahub-io/opendatahub-operator/v2/pkg/manifests/kustomize/kustomize_render_opts.go (35.5%)</option>
				
				<option value="file129">github.com/opendatahub-io/opendatahub-operator/v2/pkg/manifests/kustomize/kustomize_support.go (0.0%)</option>
				
				<option value="file130">github.com/opendatahub-io/opendatahub-operator/v2/pkg/plugins/addAnnotationsplugin.go (0.0%)</option>
				
				<option value="file131">github.com/opendatahub-io/opendatahub-operator/v2/pkg/plugins/addLabelsplugin.go (0.0%)</option>
				
				<option value="file132">github.com/opendatahub-io/opendatahub-operator/v2/pkg/plugins/namespacePlugin.go (0.0%)</option>
				
				<option value="file133">github.com/opendatahub-io/opendatahub-operator/v2/pkg/plugins/removerplugin.go (53.8%)</option>
				
				<option value="file134">github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources/resources.go (25.9%)</option>
				
				<option value="file135">github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources/resources_types.go (0.0%)</option>
				
				<option value="file136">github.com/opendatahub-io/opendatahub-operator/v2/pkg/rules/rules.go (91.8%)</option>
				
				<option value="file137">github.com/opendatahub-io/opendatahub-operator/v2/pkg/upgrade/uninstallation.go (0.0%)</option>
				
				<option value="file138">github.com/opendatahub-io/opendatahub-operator/v2/pkg/upgrade/upgrade.go (39.8%)</option>
				
				<option value="file139">github.com/opendatahub-io/opendatahub-operator/v2/pkg/utils/test/matchers/jq/jq_matcher.go (61.1%)</option>
				
				<option value="file140">github.com/opendatahub-io/opendatahub-operator/v2/pkg/utils/test/matchers/jq/jq_support.go (64.4%)</option>
				
				<option value="file141">github.com/opendatahub-io/opendatahub-operator/v2/pkg/utils/test/matchers/jq/jq_transform.go (75.0%)</option>
				
				<option value="file142">github.com/opendatahub-io/opendatahub-operator/v2/pkg/utils/test/testf/testf.go (56.2%)</option>
				
				<option value="file143">github.com/opendatahub-io/opendatahub-operator/v2/pkg/utils/test/testf/testf_assertions.go (68.7%)</option>
				
				<option value="file144">github.com/opendatahub-io/opendatahub-operator/v2/pkg/utils/test/testf/testf_support.go (61.3%)</option>
				
				<option value="file145">github.com/opendatahub-io/opendatahub-operator/v2/pkg/utils/test/testf/testf_witht.go (48.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package codeflare

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov4" title="2">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov4" title="2">{
        return componentApi.CodeFlareComponentName
}</span>

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov4" title="2">{
        return &amp;componentApi.CodeFlare{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.CodeFlareKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.CodeFlareInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.CodeFlare.ManagementState),
                        },
                },
                Spec: componentApi.CodeFlareSpec{
                        CodeFlareCommonSpec: dsc.Spec.Components.CodeFlare.CodeFlareCommonSpec,
                },
        }
}</span>

func (s *componentHandler) Init(_ common.Platform) error <span class="cov0" title="0">{
        if err := odhdeploy.ApplyParams(paramsPath, "params.env", imageParamMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", paramsPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov10" title="8">{
        return dsc.Spec.Components.CodeFlare.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov7" title="5">{
        cs := metav1.ConditionUnknown

        c := componentApi.CodeFlare{}
        c.Name = componentApi.CodeFlareInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, err
        }</span>

        <span class="cov7" title="5">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov7" title="5">ms := components.NormalizeManagementState(dsc.Spec.Components.CodeFlare.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentName] = false
        dsc.Status.Components.CodeFlare.ManagementState = ms
        dsc.Status.Components.CodeFlare.CodeFlareCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov5" title="3">{
                dsc.Status.InstalledComponents[LegacyComponentName] = true
                dsc.Status.Components.CodeFlare.CodeFlareCommonStatus = c.Status.CodeFlareCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov5" title="3">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov5" title="3"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov7" title="5">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package codeflare

import (
        "context"

        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(
                mgr,
                &amp;componentApi.CodeFlare{},
        ).
                // customized Owns() for Component with new predicates
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.Secret{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;admissionregistrationv1.MutatingWebhookConfiguration{}).
                Owns(&amp;admissionregistrationv1.ValidatingWebhookConfiguration{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.CodeFlareInstanceName)),
                        reconciler.WithPredicates(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True)),
                ).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(releases.NewAction()).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                // must be final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return err // no need customize error, it is done in the caller main
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package codeflare

import (
        "context"
        "fmt"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

func initialize(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        rr.Manifests = append(rr.Manifests, manifestsPath())

        if err := odhdeploy.ApplyParams(paramsPath, "params.env", nil, map[string]string{"namespace": rr.DSCI.Spec.ApplicationsNamespace}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update params.env from %s : %w", paramsPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        codeflare, ok := rr.Instance.(*componentApi.CodeFlare)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.CodeFlare)", rr.Instance)
        }</span>

        <span class="cov0" title="0">if codeflare.Spec.DevFlags == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Implement devflags support logic
        // If dev flags are set, update default manifests path
        <span class="cov0" title="0">if len(codeflare.Spec.DevFlags.Manifests) != 0 </span><span class="cov0" title="0">{
                manifestConfig := codeflare.Spec.DevFlags.Manifests[0]
                if err := odhdeploy.DownloadManifests(ctx, ComponentName, manifestConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if manifestConfig.SourcePath != "" </span><span class="cov0" title="0">{
                        rr.Manifests[0].Path = odhdeploy.DefaultManifestPath
                        rr.Manifests[0].ContextDir = ComponentName
                        rr.Manifests[0].SourcePath = manifestConfig.SourcePath
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package codeflare

import (
        "path"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ComponentName = componentApi.CodeFlareComponentName

        ReadyConditionType = componentApi.CodeFlareKind + status.ReadySuffix

        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName = "codeflare"
)

var (
        paramsPath = path.Join(odhdeploy.DefaultManifestPath, ComponentName, "manager")

        imageParamMap = map[string]string{
                "codeflare-operator-controller-image": "RELATED_IMAGE_ODH_CODEFLARE_OPERATOR_IMAGE",
        }

        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

func manifestsPath() odhtypes.ManifestInfo <span class="cov0" title="0">{
        return odhtypes.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: "default",
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package components

import (
        "embed"

        operatorv1 "github.com/openshift/api/operator/v1"
)

//go:embed kueue/monitoring
//go:embed trainingoperator/monitoring
//go:embed trustyai/monitoring
//go:embed workbenches/monitoring
//go:embed codeflare/monitoring
//go:embed dashboard/monitoring
//go:embed datasciencepipelines/monitoring
//go:embed feastoperator/monitoring
//go:embed kserve/monitoring
//go:embed llamastackoperator/monitoring
//go:embed modelcontroller/monitoring
//go:embed modelmeshserving/monitoring
//go:embed modelregistry/monitoring
//go:embed ray/monitoring
var ComponentRulesFS embed.FS

// NormalizeManagementState returns the ManagementState or operatorv1.Removed if empty.
func NormalizeManagementState(managementState operatorv1.ManagementState) operatorv1.ManagementState <span class="cov0" title="0">{
        if managementState == "" </span><span class="cov0" title="0">{
                return operatorv1.Removed
        }</span>
        <span class="cov0" title="0">return managementState</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package dashboard

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov4" title="2">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov4" title="2">{
        return componentApi.DashboardComponentName
}</span>

func (s *componentHandler) Init(platform common.Platform) error <span class="cov0" title="0">{
        mi := defaultManifestInfo(platform)

        if err := odhdeploy.ApplyParams(mi.String(), "params.env", imagesMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", mi, err)
        }</span>

        <span class="cov0" title="0">extra := bffManifestsPath()
        if err := odhdeploy.ApplyParams(extra.String(), "params.env", imagesMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update modular-architecture images on path %s: %w", extra, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov4" title="2">{
        return &amp;componentApi.Dashboard{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.DashboardKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.DashboardInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.Dashboard.ManagementState),
                        },
                },
                Spec: componentApi.DashboardSpec{
                        DashboardCommonSpec: dsc.Spec.Components.Dashboard.DashboardCommonSpec,
                },
        }
}</span>

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov10" title="8">{
        return dsc.Spec.Components.Dashboard.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov7" title="5">{
        cs := metav1.ConditionUnknown

        c := componentApi.Dashboard{}
        c.Name = componentApi.DashboardInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov7" title="5">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov7" title="5">ms := components.NormalizeManagementState(dsc.Spec.Components.Dashboard.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentNameUpstream] = false
        dsc.Status.Components.Dashboard.ManagementState = ms
        dsc.Status.Components.Dashboard.DashboardCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov5" title="3">{
                dsc.Status.InstalledComponents[LegacyComponentNameUpstream] = true
                dsc.Status.Components.Dashboard.DashboardCommonStatus = c.Status.DashboardCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov5" title="3">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov5" title="3"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov7" title="5">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package dashboard

import (
        "context"
        "fmt"

        consolev1 "github.com/openshift/api/console/v1"
        routev1 "github.com/openshift/api/route/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

// NewComponentReconciler creates a ComponentReconciler for the Dashboard API.
func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        componentName := computeComponentName()

        _, err := reconciler.ReconcilerFor(mgr, &amp;componentApi.Dashboard{}).
                // operands - owned
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.Secret{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;corev1.Service{}).
                // By default, a predicated for changed generation is added by the Owns()
                // method, however for deployments, we also need to retrieve status info
                // hence we need a dedicated predicate to react to replicas status change
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                // operands - openshift
                Owns(&amp;routev1.Route{}).
                Owns(&amp;consolev1.ConsoleLink{}).
                // Those APIs are provided by the component itself hence they should
                // be watched dynamically
                OwnsGVK(gvk.AcceleratorProfile, reconciler.Dynamic()).
                OwnsGVK(gvk.OdhApplication, reconciler.Dynamic()).
                OwnsGVK(gvk.OdhDocument, reconciler.Dynamic()).
                OwnsGVK(gvk.OdhQuickStart, reconciler.Dynamic()).
                // CRDs are not owned by the component and should be left on the cluster,
                // so by default, the deploy action won't add all the annotation added to
                // other resources. Hence, a custom handling is required in order to minimize
                // chattering and avoid noisy neighborhoods
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.DashboardInstanceName)),
                        reconciler.WithPredicates(
                                component.ForLabel(labels.ODH.Component(componentName), labels.True)),
                ).
                // The OdhDashboardConfig resource is expected to be created by the operator
                // but then owned by the user so we only re-create it with factory values if
                // it gets deleted
                WatchesGVK(gvk.OdhDashboardConfig,
                        reconciler.Dynamic(),
                        reconciler.WithPredicates(resources.Deleted()),
                ).
                WatchesGVK(gvk.DashboardHardwareProfile, reconciler.WithEventHandler(
                        handlers.ToNamed(componentApi.DashboardInstanceName),
                ), reconciler.WithPredicates(predicate.Funcs{
                        GenericFunc: func(tge event.TypedGenericEvent[client.Object]) bool </span><span class="cov0" title="0">{ return false }</span>,
                        DeleteFunc:  func(tde event.TypedDeleteEvent[client.Object]) bool <span class="cov0" title="0">{ return false }</span>,
                }), reconciler.Dynamic()).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(setKustomizedParams).
                WithAction(configureDependencies).
                WithAction(kustomize.NewAction(
                        // Those are the default labels added by the legacy deploy method
                        // and should be preserved as the original plugin were affecting
                        // deployment selectors that are immutable once created, so it won't
                        // be possible to actually amend the labels in a non-disruptive
                        // manner.
                        //
                        // Additional labels/annotations MUST be added by the deploy action
                        // so they would affect only objects metadata without side effects
                        kustomize.WithLabel(labels.ODH.Component(componentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, componentName),
                )).
                WithAction(customizeResources).
                WithAction(deploy.NewAction()).
                WithAction(deployments.NewAction()).
                WithAction(reconcileHardwareProfiles).
                WithAction(updateStatus).
                // must be the final action
                WithAction(gc.NewAction(
                        gc.WithUnremovables(gvk.OdhDashboardConfig),
                )).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create the dashboard controller: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package dashboard

import (
        "context"
        "errors"
        "fmt"
        "maps"
        "strconv"
        "strings"

        "github.com/go-logr/logr"
        routev1 "github.com/openshift/api/route/v1"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/log"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        infraAPI "github.com/opendatahub-io/opendatahub-operator/v2/api/infrastructure/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

type DashboardHardwareProfile struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`
        Spec              DashboardHardwareProfileSpec `json:"spec"`
}

type DashboardHardwareProfileSpec struct {
        DisplayName  string                        `json:"displayName"`
        Enabled      bool                          `json:"enabled"`
        Description  string                        `json:"description,omitempty"`
        Tolerations  []corev1.Toleration           `json:"tolerations,omitempty"`
        Identifiers  []infraAPI.HardwareIdentifier `json:"identifiers,omitempty"`
        NodeSelector map[string]string             `json:"nodeSelector,omitempty"`
}

type DashboardHardwareProfileList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []DashboardHardwareProfile `json:"items"`
}

func initialize(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        rr.Manifests = []odhtypes.ManifestInfo{defaultManifestInfo(rr.Release.Name)}

        return nil
}</span>

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        dashboard, ok := rr.Instance.(*componentApi.Dashboard)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Dashboard)", rr.Instance)
        }</span>

        <span class="cov0" title="0">if dashboard.Spec.DevFlags == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Implement devflags support logic
        // If dev flags are set, update default manifests path
        <span class="cov0" title="0">if len(dashboard.Spec.DevFlags.Manifests) != 0 </span><span class="cov0" title="0">{
                manifestConfig := dashboard.Spec.DevFlags.Manifests[0]
                if err := odhdeploy.DownloadManifests(ctx, ComponentName, manifestConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if manifestConfig.SourcePath != "" </span><span class="cov0" title="0">{
                        rr.Manifests[0].Path = odhdeploy.DefaultManifestPath
                        rr.Manifests[0].ContextDir = ComponentName
                        rr.Manifests[0].SourcePath = manifestConfig.SourcePath
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func customizeResources(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        for i := range rr.Resources </span><span class="cov0" title="0">{
                if rr.Resources[i].GroupVersionKind() == gvk.OdhDashboardConfig </span><span class="cov0" title="0">{
                        // mark the resource as not supposed to be managed by the operator
                        resources.SetAnnotation(&amp;rr.Resources[i], annotations.ManagedByODHOperator, "false")
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func setKustomizedParams(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        extraParamsMap, err := computeKustomizeVariable(ctx, rr.Client, rr.Release.Name, &amp;rr.DSCI.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to set variable for url, section-title etc")
        }</span>

        <span class="cov0" title="0">if err := odhdeploy.ApplyParams(rr.Manifests[0].String(), "params.env", nil, extraParamsMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update params.env from %s : %w", rr.Manifests[0].String(), err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func configureDependencies(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        if rr.Release.Name == cluster.OpenDataHub </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">err := rr.AddResources(&amp;corev1.Secret{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: corev1.SchemeGroupVersion.String(),
                        Kind:       "Secret",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      "anaconda-ce-access",
                        Namespace: rr.DSCI.Spec.ApplicationsNamespace,
                },
                Type: corev1.SecretTypeOpaque,
        })

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create access-secret for anaconda: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func updateStatus(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        d, ok := rr.Instance.(*componentApi.Dashboard)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("instance is not of type *odhTypes.Dashboard")
        }</span>

        // url
        <span class="cov0" title="0">rl := routev1.RouteList{}
        err := rr.Client.List(
                ctx,
                &amp;rl,
                client.InNamespace(rr.DSCI.Spec.ApplicationsNamespace),
                client.MatchingLabels(map[string]string{
                        labels.PlatformPartOf: strings.ToLower(componentApi.DashboardKind),
                }),
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list routes: %w", err)
        }</span>

        <span class="cov0" title="0">d.Status.URL = ""
        if len(rl.Items) == 1 </span><span class="cov0" title="0">{
                d.Status.URL = resources.IngressHost(rl.Items[0])
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func reconcileHardwareProfiles(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov6" title="2">{
        dashboardHardwareProfiles := &amp;unstructured.UnstructuredList{}
        dashboardHardwareProfiles.SetGroupVersionKind(gvk.DashboardHardwareProfile)

        err := rr.Client.List(ctx, dashboardHardwareProfiles)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list dashboard hardware profiles: %w", err)
        }</span>

        <span class="cov6" title="2">logger := log.FromContext(ctx)
        for _, hwprofile := range dashboardHardwareProfiles.Items </span><span class="cov6" title="2">{
                var dashboardHardwareProfile DashboardHardwareProfile

                if err := runtime.DefaultUnstructuredConverter.FromUnstructured(hwprofile.Object, &amp;dashboardHardwareProfile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert dashboard hardware profile: %w", err)
                }</span>

                <span class="cov6" title="2">infraHWP := &amp;infraAPI.HardwareProfile{}
                err := rr.Client.Get(ctx, client.ObjectKey{
                        Name:      dashboardHardwareProfile.Name,
                        Namespace: dashboardHardwareProfile.Namespace,
                }, infraHWP)

                if k8serr.IsNotFound(err) </span><span class="cov6" title="2">{
                        if err = createInfraHWP(ctx, rr, logger, &amp;dashboardHardwareProfile); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create infrastructure hardware profile: %w", err)
                        }</span>
                        <span class="cov6" title="2">continue</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get infrastructure hardware profile: %w", err)
                }</span>

                <span class="cov0" title="0">err = updateInfraHWP(ctx, rr, logger, &amp;dashboardHardwareProfile, infraHWP)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update existing infrastructure hardware profile: %w", err)
                }</span>
        }
        <span class="cov6" title="2">return nil</span>
}

func createInfraHWP(ctx context.Context, rr *odhtypes.ReconciliationRequest, logger logr.Logger, dashboardhwp *DashboardHardwareProfile) error <span class="cov10" title="3">{
        annotations := make(map[string]string)
        maps.Copy(annotations, dashboardhwp.Annotations)

        annotations["opendatahub.io/migrated-from"] = fmt.Sprintf("hardwareprofiles.dashboard.opendatahub.io/%s", dashboardhwp.Name)
        annotations["opendatahub.io/display-name"] = dashboardhwp.Spec.DisplayName
        annotations["opendatahub.io/description"] = dashboardhwp.Spec.Description
        annotations["opendatahub.io/disabled"] = strconv.FormatBool(!dashboardhwp.Spec.Enabled)

        infraHardwareProfile := &amp;infraAPI.HardwareProfile{
                ObjectMeta: metav1.ObjectMeta{
                        Name:        dashboardhwp.Name,
                        Namespace:   dashboardhwp.Namespace,
                        Annotations: annotations,
                },
                Spec: infraAPI.HardwareProfileSpec{
                        SchedulingSpec: &amp;infraAPI.SchedulingSpec{
                                SchedulingType: infraAPI.NodeScheduling,
                                Node: &amp;infraAPI.NodeSchedulingSpec{
                                        NodeSelector: dashboardhwp.Spec.NodeSelector,
                                        Tolerations:  dashboardhwp.Spec.Tolerations,
                                },
                        },
                        Identifiers: dashboardhwp.Spec.Identifiers,
                },
        }

        if err := rr.Client.Create(ctx, infraHardwareProfile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="3">logger.Info("successfully created infrastructure hardware profile", "name", infraHardwareProfile.GetName())
        return nil</span>
}

func updateInfraHWP(ctx context.Context, rr *odhtypes.ReconciliationRequest, logger logr.Logger, dashboardhwp *DashboardHardwareProfile, infrahwp *infraAPI.HardwareProfile) error <span class="cov0" title="0">{
        if infrahwp.Annotations == nil </span><span class="cov0" title="0">{
                infrahwp.Annotations = make(map[string]string)
        }</span>

        <span class="cov0" title="0">maps.Copy(infrahwp.Annotations, dashboardhwp.Annotations)

        infrahwp.Annotations["opendatahub.io/migrated-from"] = fmt.Sprintf("hardwareprofiles.dashboard.opendatahub.io/%s", dashboardhwp.Name)
        infrahwp.Annotations["opendatahub.io/display-name"] = dashboardhwp.Spec.DisplayName
        infrahwp.Annotations["opendatahub.io/description"] = dashboardhwp.Spec.Description
        infrahwp.Annotations["opendatahub.io/disabled"] = strconv.FormatBool(!dashboardhwp.Spec.Enabled)

        infrahwp.Spec.SchedulingSpec = &amp;infraAPI.SchedulingSpec{
                SchedulingType: infraAPI.NodeScheduling,
                Node: &amp;infraAPI.NodeSchedulingSpec{
                        NodeSelector: dashboardhwp.Spec.NodeSelector,
                        Tolerations:  dashboardhwp.Spec.Tolerations,
                },
        }
        infrahwp.Spec.Identifiers = dashboardhwp.Spec.Identifiers

        if err := rr.Client.Update(ctx, infrahwp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update infrastructure hardware profile: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("successfully updated infrastructure hardware profile", "name", infrahwp.GetName())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package dashboard

import (
        "context"
        "fmt"

        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ComponentName = componentApi.DashboardComponentName

        ReadyConditionType = componentApi.DashboardKind + status.ReadySuffix

        // Legacy component names are the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.

        LegacyComponentNameUpstream   = "dashboard"
        LegacyComponentNameDownstream = "rhods-dashboard"
)

var (
        sectionTitle = map[common.Platform]string{
                cluster.SelfManagedRhoai: "OpenShift Self Managed Services",
                cluster.ManagedRhoai:     "OpenShift Managed Services",
                cluster.OpenDataHub:      "OpenShift Open Data Hub",
        }

        baseConsoleURL = map[common.Platform]string{
                cluster.SelfManagedRhoai: "https://rhods-dashboard-",
                cluster.ManagedRhoai:     "https://rhods-dashboard-",
                cluster.OpenDataHub:      "https://odh-dashboard-",
        }

        overlaysSourcePaths = map[common.Platform]string{
                cluster.SelfManagedRhoai: "/rhoai/onprem",
                cluster.ManagedRhoai:     "/rhoai/addon",
                cluster.OpenDataHub:      "/odh",
        }

        imagesMap = map[string]string{
                "odh-dashboard-image":     "RELATED_IMAGE_ODH_DASHBOARD_IMAGE",
                "model-registry-ui-image": "RELATED_IMAGE_ODH_MODEL_REGISTRY_MOD_ARCH_IMAGE",
        }

        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

func defaultManifestInfo(p common.Platform) odhtypes.ManifestInfo <span class="cov0" title="0">{
        return odhtypes.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: overlaysSourcePaths[p],
        }
}</span>

func bffManifestsPath() odhtypes.ManifestInfo <span class="cov0" title="0">{
        return odhtypes.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: "modular-architecture",
        }
}</span>

func computeKustomizeVariable(ctx context.Context, cli client.Client, platform common.Platform, dscispec *dsciv1.DSCInitializationSpec) (map[string]string, error) <span class="cov0" title="0">{
        consoleLinkDomain, err := cluster.GetDomain(ctx, cli)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting console route URL %s : %w", consoleLinkDomain, err)
        }</span>

        <span class="cov0" title="0">return map[string]string{
                "dashboard-url": baseConsoleURL[platform] + dscispec.ApplicationsNamespace + "." + consoleLinkDomain,
                "section-title": sectionTitle[platform],
        }, nil</span>
}

func computeComponentName() string <span class="cov0" title="0">{
        release := cluster.GetRelease()

        name := LegacyComponentNameUpstream
        if release.Name == cluster.SelfManagedRhoai || release.Name == cluster.ManagedRhoai </span><span class="cov0" title="0">{
                name = LegacyComponentNameDownstream
        }</span>

        <span class="cov0" title="0">return name</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package datasciencepipelines

import (
        "context"
        "errors"
        "fmt"
        "strconv"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov8" title="1">{
        return componentApi.DataSciencePipelinesComponentName
}</span>

func (s *componentHandler) Init(_ common.Platform) error <span class="cov0" title="0">{
        release := cluster.GetRelease()
        clusterInfo := cluster.GetClusterInfo()
        extraParams := map[string]string{
                platformVersionParamsKey: release.Version.String(),
                fipsEnabledParamsKey:     strconv.FormatBool(clusterInfo.FipsEnabled),
        }
        if err := deploy.ApplyParams(paramsPath, "params.env", imageParamMap, extraParams); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", paramsPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov8" title="1">{
        return &amp;componentApi.DataSciencePipelines{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.DataSciencePipelinesKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.DataSciencePipelinesInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.DataSciencePipelines.ManagementState),
                        },
                },
                Spec: componentApi.DataSciencePipelinesSpec{
                        DataSciencePipelinesCommonSpec: dsc.Spec.Components.DataSciencePipelines.DataSciencePipelinesCommonSpec,
                },
        }
}</span>

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov8" title="1">{
        return dsc.Spec.Components.DataSciencePipelines.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov8" title="1">{
        cs := metav1.ConditionUnknown

        c := componentApi.DataSciencePipelines{}
        c.Name = componentApi.DataSciencePipelinesInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov8" title="1">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov8" title="1">ms := components.NormalizeManagementState(dsc.Spec.Components.DataSciencePipelines.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentName] = false
        dsc.Status.Components.DataSciencePipelines.ManagementState = ms
        dsc.Status.Components.DataSciencePipelines.DataSciencePipelinesCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov8" title="1">{
                dsc.Status.InstalledComponents[LegacyComponentName] = true
                dsc.Status.Components.DataSciencePipelines.DataSciencePipelinesCommonStatus = c.Status.DataSciencePipelinesCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov8" title="1">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov8" title="1"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov8" title="1">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package datasciencepipelines

import (
        "context"

        securityv1 "github.com/openshift/api/security/v1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(mgr, &amp;componentApi.DataSciencePipelines{}).
                // customized Owns() for Component with new predicates
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.Secret{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;monitoringv1.ServiceMonitor{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Owns(&amp;securityv1.SecurityContextConstraints{}).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.DataSciencePipelinesInstanceName)),
                        reconciler.WithPredicates(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True)),
                ).
                WithAction(checkPreConditions).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(argoWorkflowsControllersOptions).
                WithAction(releases.NewAction()).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return err // no need customize error, it is done in the caller main
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package datasciencepipelines

import (
        "context"
        "encoding/json"
        "fmt"
        "path"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        odherr "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/errors"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func checkPreConditions(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov8" title="1">{
        dsp, ok := rr.Instance.(*componentApi.DataSciencePipelines)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("resource instance %v is not a componentApi.DataSciencePipelines)", rr.Instance)
        }</span>

        <span class="cov8" title="1">awfSpec := dsp.Spec.ArgoWorkflowsControllers
        awfRemoved := awfSpec != nil &amp;&amp; awfSpec.ManagementState == operatorv1.Removed

        rr.Conditions.MarkTrue(status.ConditionArgoWorkflowAvailable)

        crd, err := cluster.GetCRD(ctx, rr.Client, ArgoWorkflowCRD)
        switch </span>{
        case k8serr.IsNotFound(err):<span class="cov8" title="1">
                if awfRemoved </span><span class="cov8" title="1">{
                        rr.Conditions.MarkFalse(
                                status.ConditionArgoWorkflowAvailable,
                                conditions.WithObservedGeneration(rr.Instance.GetGeneration()),
                                conditions.WithReason(status.DataSciencePipelinesArgoWorkflowsCRDMissingReason),
                                conditions.WithMessage(status.DataSciencePipelinesArgoWorkflowsCRDMissingMessage),
                        )

                        return ErrArgoWorkflowCRDMissing
                }</span>

                <span class="cov8" title="1">return nil</span>
        case err != nil:<span class="cov0" title="0">
                err = odherr.NewStopError("failed to check for existing %s CRD: %w", ArgoWorkflowCRD, err)

                rr.Conditions.MarkFalse(
                        status.ConditionArgoWorkflowAvailable,
                        conditions.WithObservedGeneration(rr.Instance.GetGeneration()),
                        conditions.WithError(err),
                )

                return err</span>
        }

        <span class="cov8" title="1">if awfRemoved </span><span class="cov8" title="1">{
                rr.Conditions.MarkTrue(status.ConditionArgoWorkflowAvailable,
                        conditions.WithObservedGeneration(rr.Instance.GetGeneration()),
                        conditions.WithReason(status.DataSciencePipelinesArgoWorkflowsNotManagedReason),
                        conditions.WithMessage(status.DataSciencePipelinesArgoWorkflowsNotManagedMessage),
                )

                return nil
        }</span>

        // Verify if existing workflow is deployed by ODH with label
        // if not then set Argo capability status condition to false
        <span class="cov8" title="1">odhLabelValue, odhLabelExists := crd.Labels[labels.ODH.Component(LegacyComponentName)]
        if !odhLabelExists || odhLabelValue != "true" </span><span class="cov8" title="1">{
                rr.Conditions.MarkFalse(
                        status.ConditionArgoWorkflowAvailable,
                        conditions.WithObservedGeneration(rr.Instance.GetGeneration()),
                        conditions.WithReason(status.DataSciencePipelinesDoesntOwnArgoCRDReason),
                        conditions.WithMessage(status.DataSciencePipelinesDoesntOwnArgoCRDMessage),
                )

                return ErrArgoWorkflowAPINotOwned
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func initialize(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        rr.Manifests = append(rr.Manifests, manifestPath(rr.Release.Name))

        return nil
}</span>

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        dsp, ok := rr.Instance.(*componentApi.DataSciencePipelines)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.DataSciencePipelines)", rr.Instance)
        }</span>

        <span class="cov0" title="0">if dsp.Spec.DevFlags == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Implement devflags support logic
        // If dev flags are set, update default manifests path
        <span class="cov0" title="0">if len(dsp.Spec.DevFlags.Manifests) != 0 </span><span class="cov0" title="0">{
                manifestConfig := dsp.Spec.DevFlags.Manifests[0]
                if err := odhdeploy.DownloadManifests(ctx, ComponentName, manifestConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if manifestConfig.SourcePath != "" </span><span class="cov0" title="0">{
                        rr.Manifests[0].Path = odhdeploy.DefaultManifestPath
                        rr.Manifests[0].ContextDir = ComponentName
                        rr.Manifests[0].SourcePath = manifestConfig.SourcePath
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func argoWorkflowsControllersOptions(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov8" title="1">{
        dsp, ok := rr.Instance.(*componentApi.DataSciencePipelines)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("resource instance %v is not a componentApi.DataSciencePipelines)", rr.Instance)
        }</span>

        <span class="cov8" title="1">awfSpec := dsp.Spec.ArgoWorkflowsControllers

        if awfSpec == nil </span><span class="cov8" title="1">{
                awfSpec = &amp;componentApi.ArgoWorkflowsControllersSpec{
                        ManagementState: operatorv1.Managed,
                }
        }</span>

        <span class="cov8" title="1">awfSpecJSON, err := json.Marshal(awfSpec)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal spec.argoWorkflowsControllers: %w", err)
        }</span>

        <span class="cov8" title="1">extraParams := map[string]string{
                argoWorkflowsControllersParamsKey: string(awfSpecJSON),
        }

        paramsPath := path.Join(odhdeploy.DefaultManifestPath, ComponentName, "base")

        if err := odhdeploy.ApplyParams(paramsPath, "params.env", imageParamMap, extraParams); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update params.env: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package datasciencepipelines

import (
        "path"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        odherrors "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/errors"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ArgoWorkflowCRD = "workflows.argoproj.io"
        ComponentName   = componentApi.DataSciencePipelinesComponentName

        ReadyConditionType = componentApi.DataSciencePipelinesKind + status.ReadySuffix

        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName               = "data-science-pipelines-operator"
        platformVersionParamsKey          = "PLATFORMVERSION"
        fipsEnabledParamsKey              = "FIPSENABLED"
        argoWorkflowsControllersParamsKey = "ARGOWORKFLOWSCONTROLLERS"
)

var (
        ErrArgoWorkflowAPINotOwned = odherrors.NewStopError(status.DataSciencePipelinesDoesntOwnArgoCRDMessage)
        ErrArgoWorkflowCRDMissing  = odherrors.NewStopError(status.DataSciencePipelinesArgoWorkflowsCRDMissingMessage)
)

var (
        imageParamMap = map[string]string{
                "IMAGES_DSPO":                    "RELATED_IMAGE_ODH_DATA_SCIENCE_PIPELINES_OPERATOR_CONTROLLER_IMAGE",
                "IMAGES_APISERVER":               "RELATED_IMAGE_ODH_ML_PIPELINES_API_SERVER_V2_IMAGE",
                "IMAGES_PERSISTENCEAGENT":        "RELATED_IMAGE_ODH_ML_PIPELINES_PERSISTENCEAGENT_V2_IMAGE",
                "IMAGES_SCHEDULEDWORKFLOW":       "RELATED_IMAGE_ODH_ML_PIPELINES_SCHEDULEDWORKFLOW_V2_IMAGE",
                "IMAGES_ARGO_EXEC":               "RELATED_IMAGE_ODH_DATA_SCIENCE_PIPELINES_ARGO_ARGOEXEC_IMAGE",
                "IMAGES_ARGO_WORKFLOWCONTROLLER": "RELATED_IMAGE_ODH_DATA_SCIENCE_PIPELINES_ARGO_WORKFLOWCONTROLLER_IMAGE",
                "IMAGES_DRIVER":                  "RELATED_IMAGE_ODH_ML_PIPELINES_DRIVER_IMAGE",
                "IMAGES_LAUNCHER":                "RELATED_IMAGE_ODH_ML_PIPELINES_LAUNCHER_IMAGE",
                "IMAGES_MLMDGRPC":                "RELATED_IMAGE_ODH_MLMD_GRPC_SERVER_IMAGE",
                "IMAGES_PIPELINESRUNTIMEGENERIC": "RELATED_IMAGE_ODH_ML_PIPELINES_RUNTIME_GENERIC_IMAGE",
                "IMAGES_MLMDENVOY":               "RELATED_IMAGE_DSP_PROXYV2_IMAGE",
                "IMAGES_MARIADB":                 "RELATED_IMAGE_DSP_MARIADB_IMAGE",
                "IMAGES_OAUTHPROXY":              "RELATED_IMAGE_OSE_OAUTH_PROXY_IMAGE",
                "IMAGES_TOOLBOX":                 "RELATED_IMAGE_DSP_TOOLBOX_IMAGE",
                "IMAGES_RHELAI":                  "RELATED_IMAGE_DSP_INSTRUCTLAB_NVIDIA_IMAGE",
        }

        overlaysSourcePaths = map[common.Platform]string{
                cluster.SelfManagedRhoai: "overlays/rhoai",
                cluster.ManagedRhoai:     "overlays/rhoai",
                cluster.OpenDataHub:      "overlays/odh",
        }

        conditionTypes = []string{
                status.ConditionArgoWorkflowAvailable,
                status.ConditionDeploymentsAvailable,
        }

        paramsPath = path.Join(odhdeploy.DefaultManifestPath, ComponentName, "base")
)

func manifestPath(p common.Platform) types.ManifestInfo <span class="cov0" title="0">{
        return types.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: overlaysSourcePaths[p],
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package feastoperator

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov8" title="1">{
        return componentApi.FeastOperatorComponentName
}</span>

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov8" title="1">{
        return &amp;componentApi.FeastOperator{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.FeastOperatorKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.FeastOperatorInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.FeastOperator.ManagementState),
                        },
                },
                Spec: componentApi.FeastOperatorSpec{
                        FeastOperatorCommonSpec: dsc.Spec.Components.FeastOperator.FeastOperatorCommonSpec,
                },
        }
}</span>

func (s *componentHandler) Init(p common.Platform) error <span class="cov0" title="0">{
        if err := odhdeploy.ApplyParams(manifestPath(p).String(), "params.env", imageParamMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", manifestPath(p), err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov8" title="1">{
        return dsc.Spec.Components.FeastOperator.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov8" title="1">{
        cs := metav1.ConditionUnknown

        c := componentApi.FeastOperator{}
        c.Name = componentApi.FeastOperatorInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov8" title="1">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov8" title="1">ms := components.NormalizeManagementState(dsc.Spec.Components.FeastOperator.ManagementState)

        dsc.Status.InstalledComponents[ComponentName] = false
        dsc.Status.Components.FeastOperator.ManagementState = ms
        dsc.Status.Components.FeastOperator.FeastOperatorCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov8" title="1">{
                dsc.Status.InstalledComponents[ComponentName] = true
                dsc.Status.Components.FeastOperator.FeastOperatorCommonStatus = c.Status.FeastOperatorCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov8" title="1">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov8" title="1"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov8" title="1">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package feastoperator

import (
        "context"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(mgr, &amp;componentApi.FeastOperator{}).
                // customized Owns() for Component with new predicates
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.FeastOperatorInstanceName)),
                        reconciler.WithPredicates(
                                component.ForLabel(labels.ODH.Component(ComponentName), labels.True)),
                ).
                // Add FeastOperator-specific actions
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(releases.NewAction()).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(ComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, ComponentName),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return err // no need customize error, it is done in the caller main
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package feastoperator

import (
        "context"
        "fmt"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

func initialize(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        rr.Manifests = append(rr.Manifests, manifestPath(rr.Release.Name))
        return nil
}</span>

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        feastoperator, ok := rr.Instance.(*componentApi.FeastOperator)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.FeastOperator)", rr.Instance)
        }</span>

        <span class="cov0" title="0">if feastoperator.Spec.DevFlags == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(feastoperator.Spec.DevFlags.Manifests) != 0 </span><span class="cov0" title="0">{
                manifestConfig := feastoperator.Spec.DevFlags.Manifests[0]
                if err := odhdeploy.DownloadManifests(ctx, ComponentName, manifestConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if manifestConfig.SourcePath != "" </span><span class="cov0" title="0">{
                        rr.Manifests[0].Path = odhdeploy.DefaultManifestPath
                        rr.Manifests[0].ContextDir = ComponentName
                        rr.Manifests[0].SourcePath = manifestConfig.SourcePath
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package feastoperator

import (
        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ComponentName = componentApi.FeastOperatorComponentName

        ReadyConditionType = componentApi.FeastOperatorKind + status.ReadySuffix
)

var (
        ManifestsSourcePath = map[common.Platform]string{
                cluster.SelfManagedRhoai: "overlays/rhoai",
                cluster.ManagedRhoai:     "overlays/rhoai",
                cluster.OpenDataHub:      "overlays/odh",
        }
        imageParamMap = map[string]string{
                "RELATED_IMAGE_FEAST_OPERATOR": "RELATED_IMAGE_ODH_FEAST_OPERATOR_IMAGE",
                "RELATED_IMAGE_FEATURE_SERVER": "RELATED_IMAGE_ODH_FEATURE_SERVER_IMAGE",
        }

        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

func manifestPath(p common.Platform) types.ManifestInfo <span class="cov0" title="0">{
        return types.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: ManifestsSourcePath[p],
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package kserve

import (
        "encoding/json"
        "fmt"

        corev1 "k8s.io/api/core/v1"
)

// ConfigMap Keys.
const (
        DeployConfigName     = "deploy"
        IngressConfigKeyName = "ingress"
        ServiceConfigKeyName = "service"
)

type DeployConfig struct {
        DefaultDeploymentMode string `json:"defaultDeploymentMode,omitempty"`
}

func getDeployConfig(cm *corev1.ConfigMap) (*DeployConfig, error) <span class="cov0" title="0">{
        deployConfig := DeployConfig{}
        if err := json.Unmarshal([]byte(cm.Data[DeployConfigName]), &amp;deployConfig); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error retrieving value for key '%s' from ConfigMap %s. %w", DeployConfigName, cm.Name, err)
        }</span>
        <span class="cov0" title="0">return &amp;deployConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package kserve

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        odherrors "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/errors"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

const (
        componentName            = componentApi.KserveComponentName
        authorinoOperator        = "authorino-operator"
        serviceMeshOperator      = "servicemeshoperator"
        serverlessOperator       = "serverless-operator"
        kserveConfigMapName      = "inferenceservice-config"
        kserveManifestSourcePath = "overlays/odh"

        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName = "kserve"

        ReadyConditionType = componentApi.KserveKind + status.ReadySuffix
)

var (
        conditionTypes = []string{
                status.ConditionServingAvailable,
                status.ConditionDeploymentsAvailable,
        }
)

var (
        ErrServiceMeshNotConfigured        = odherrors.NewStopError(status.ServiceMeshNeedConfiguredMessage)
        ErrServiceMeshNotReady             = odherrors.NewStopError(status.ServiceMeshNotReadyMessage)
        ErrServiceMeshOperatorNotInstalled = odherrors.NewStopError(status.ServiceMeshOperatorNotInstalledMessage)
        ErrServerlessOperatorNotInstalled  = odherrors.NewStopError(status.ServerlessOperatorNotInstalledMessage)
        ErrServerlessUnsupportedCertType   = odherrors.NewStopError(status.ServerlessUnsupportedCertMessage)
)

type componentHandler struct{}

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

// Init to set oauth image.
func (s *componentHandler) Init(platform common.Platform) error <span class="cov0" title="0">{
        mp := kserveManifestInfo(kserveManifestSourcePath)

        if err := odhdeploy.ApplyParams(mp.String(), "params.env", imageParamMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", mp, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) GetName() string <span class="cov8" title="1">{
        return componentName
}</span>

// for DSC to get compoment Kserve's CR.
func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov8" title="1">{
        return &amp;componentApi.Kserve{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.KserveKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.KserveInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.Kserve.ManagementState),
                        },
                },
                Spec: componentApi.KserveSpec{
                        KserveCommonSpec: dsc.Spec.Components.Kserve.KserveCommonSpec,
                },
        }
}</span>

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov8" title="1">{
        return dsc.Spec.Components.Kserve.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov8" title="1">{
        cs := metav1.ConditionUnknown

        c := componentApi.Kserve{}
        c.Name = componentApi.KserveInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov8" title="1">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov8" title="1">ms := components.NormalizeManagementState(dsc.Spec.Components.Kserve.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentName] = false
        dsc.Status.Components.Kserve.ManagementState = ms
        dsc.Status.Components.Kserve.KserveCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov8" title="1">{
                dsc.Status.InstalledComponents[LegacyComponentName] = true
                dsc.Status.Components.Kserve.KserveCommonStatus = c.Status.KserveCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov8" title="1">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov8" title="1"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov8" title="1">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package kserve

import (
        "context"

        templatev1 "github.com/openshift/api/template/v1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/template"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/generation"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/hash"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

// NewComponentReconciler creates a ComponentReconciler for the Dashboard API.
func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(mgr, &amp;componentApi.Kserve{}).
                // operands - owned
                Owns(&amp;corev1.Secret{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                // The ovms template gets a new resourceVersion periodically without any other
                // changes. The compareHashPredicate ensures that we don't needlessly enqueue
                // requests if there are no changes that we don't care about.
                Owns(&amp;templatev1.Template{}, reconciler.WithPredicates(hash.Updated())).
                Owns(&amp;networkingv1.NetworkPolicy{}).
                Owns(&amp;monitoringv1.ServiceMonitor{}).
                Owns(&amp;admissionregistrationv1.MutatingWebhookConfiguration{}).
                Owns(&amp;admissionregistrationv1.ValidatingWebhookConfiguration{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).

                // operands - dynamically owned
                OwnsGVK(gvk.Gateway, reconciler.Dynamic(ifGVKInstalled(gvk.Gateway))).
                OwnsGVK(gvk.EnvoyFilter, reconciler.Dynamic(ifGVKInstalled(gvk.EnvoyFilter))).
                OwnsGVK(gvk.KnativeServing, reconciler.Dynamic(ifGVKInstalled(gvk.KnativeServing))).
                OwnsGVK(gvk.ServiceMeshMember, reconciler.Dynamic(ifGVKInstalled(gvk.ServiceMeshMember))).
                OwnsGVK(gvk.AuthorizationPolicy, reconciler.Dynamic(ifGVKInstalled(gvk.AuthorizationPolicy))).
                OwnsGVK(gvk.AuthorizationPolicyv1beta1, reconciler.Dynamic(ifGVKInstalled(gvk.AuthorizationPolicyv1beta1))).

                // operands - watched
                //
                // By default the Watches functions adds:
                // - an event handler mapping to a cluster scope resource identified by the
                //   components.platform.opendatahub.io/managed-by annotation
                // - a predicate that check for generation change for Delete/Updates events
                //   for to objects that have the label components.platform.opendatahub.io/managed-by
                //   set to the current owner
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.KserveInstanceName)),
                        reconciler.WithPredicates(predicate.And(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                                predicate.Funcs{
                                        UpdateFunc: func(event event.UpdateEvent) bool </span><span class="cov0" title="0">{
                                                // The KServe and ModelMesh are shipping the same CRDs as part of their manifests
                                                // but with different versions, this cause the respective component reconcilers to
                                                // keep trying to install their respective version, ending in an infinite loop.
                                                switch event.ObjectNew.GetName() </span>{
                                                case "inferenceservices.serving.kserve.io":<span class="cov0" title="0">
                                                        return false</span>
                                                case "servingruntimes.serving.kserve.io":<span class="cov0" title="0">
                                                        return false</span>
                                                }
                                                <span class="cov0" title="0">return true</span>
                                        },
                                },
                        )),
                ).
                // resource
                Watches(
                        &amp;dsciv1.DSCInitialization{},
                        reconciler.WithEventHandler(handlers.ToNamed(componentApi.KserveInstanceName)),
                        reconciler.WithPredicates(predicate.Or(generation.New(), resources.DSCIReadiness, resources.DSCIServiceMeshCondition)),
                ).
                WatchesGVK(
                        gvk.OperatorCondition,
                        reconciler.WithEventHandler(handlers.ToNamed(componentApi.KserveInstanceName)),
                        reconciler.WithPredicates(isRequiredOperators),
                ).

                // actions
                WithAction(checkPreConditions).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(releases.NewAction()).
                WithAction(addTemplateFiles).
                WithAction(template.NewAction(
                        template.WithDataFn(getTemplateData),
                )).

                // these actions deal with the Kserve serving config and DSCI
                // service mesh config, and the transitions between different
                // management states of those.
                WithAction(addServingCertResourceIfManaged).
                WithAction(removeOwnershipFromUnmanagedResources).
                WithAction(cleanUpTemplatedResources).
                WithAction(kustomize.NewAction(
                        // These are the default labels added by the legacy deploy method
                        // and should be preserved as the original plugin were affecting
                        // deployment selectors that are immutable once created, so it won't
                        // be possible to actually amend the labels in a non-disruptive
                        // manner.
                        //
                        // Additional labels/annotations MUST be added by the deploy action
                        // so they would affect only objects metadata without side effects
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(customizeKserveConfigMap).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                WithAction(setStatusFields).
                // TODO: can be removed after RHOAI 2.26 (next EUS)
                WithAction(deleteFeatureTrackers).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx)

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package kserve

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/hashicorp/go-multierror"
        operatorv1 "github.com/openshift/api/operator/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        featuresv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/features/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        odherrors "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/errors"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func checkPreConditions(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov8" title="1">{
        k, ok := rr.Instance.(*componentApi.Kserve)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kserve)", rr.Instance)
        }</span>

        <span class="cov8" title="1">rr.Conditions.MarkUnknown(status.ConditionServingAvailable)

        if k.Spec.Serving.ManagementState != operatorv1.Managed </span><span class="cov8" title="1">{
                rr.Conditions.MarkFalse(
                        status.ConditionServingAvailable,
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                        conditions.WithReason(string(k.Spec.Serving.ManagementState)),
                        conditions.WithMessage("Serving management state is set to: %s", string(k.Spec.Serving.ManagementState)))

                return nil
        }</span>

        <span class="cov8" title="1">if rr.DSCI.Spec.ServiceMesh == nil || rr.DSCI.Spec.ServiceMesh.ManagementState != operatorv1.Managed </span><span class="cov8" title="1">{
                rr.Conditions.MarkFalse(
                        status.ConditionServingAvailable,
                        conditions.WithObservedGeneration(rr.Instance.GetGeneration()),
                        conditions.WithReason(status.ServiceMeshNotConfiguredReason),
                        conditions.WithMessage(status.ServiceMeshNeedConfiguredMessage),
                )

                return ErrServiceMeshNotConfigured
        }</span>

        <span class="cov8" title="1">var operatorsErr error

        if found, err := cluster.OperatorExists(ctx, rr.Client, serviceMeshOperator); err != nil || !found </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return odherrors.NewStopErrorW(err)
                }</span>

                <span class="cov8" title="1">operatorsErr = multierror.Append(operatorsErr, ErrServiceMeshOperatorNotInstalled)</span>
        }

        <span class="cov8" title="1">if found, err := cluster.OperatorExists(ctx, rr.Client, serverlessOperator); err != nil || !found </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return odherrors.NewStopErrorW(err)
                }</span>

                <span class="cov8" title="1">operatorsErr = multierror.Append(operatorsErr, ErrServerlessOperatorNotInstalled)</span>
        }

        <span class="cov8" title="1">if operatorsErr != nil </span><span class="cov8" title="1">{
                rr.Conditions.MarkFalse(
                        status.ConditionServingAvailable,
                        conditions.WithObservedGeneration(rr.Instance.GetGeneration()),
                        conditions.WithError(operatorsErr),
                )

                return odherrors.NewStopErrorW(operatorsErr)
        }</span>

        // Check if the CapabilityServiceMesh condition is not true, Serverless require ServiceMesh to be ready before creating SMM
        <span class="cov8" title="1">if !conditions.IsStatusConditionTrue(&amp;rr.DSCI.Status, status.CapabilityServiceMesh) </span><span class="cov8" title="1">{
                rr.Conditions.MarkFalse(
                        status.ConditionServingAvailable,
                        conditions.WithObservedGeneration(rr.Instance.GetGeneration()),
                        conditions.WithReason(status.ServiceMeshNotReadyReason),
                        conditions.WithMessage(status.ServiceMeshNotReadyMessage),
                )
                return ErrServiceMeshNotReady
        }</span>

        <span class="cov8" title="1">rr.Conditions.MarkTrue(status.ConditionServingAvailable)

        return nil</span>
}

func initialize(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        rr.Manifests = []odhtypes.ManifestInfo{
                kserveManifestInfo(kserveManifestSourcePath),
        }

        return nil
}</span>

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        k, ok := rr.Instance.(*componentApi.Kserve)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kserve)", rr.Instance)
        }</span>

        <span class="cov0" title="0">df := k.GetDevFlags()
        if df == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(df.Manifests) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">kSourcePath := kserveManifestSourcePath

        for _, subcomponent := range df.Manifests </span><span class="cov0" title="0">{
                if !strings.Contains(subcomponent.URI, componentName) &amp;&amp; !strings.Contains(subcomponent.URI, LegacyComponentName) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if err := deploy.DownloadManifests(ctx, componentName, subcomponent); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if subcomponent.SourcePath != "" </span><span class="cov0" title="0">{
                        kSourcePath = subcomponent.SourcePath
                }</span>

                <span class="cov0" title="0">break</span>
        }

        <span class="cov0" title="0">rr.Manifests = []odhtypes.ManifestInfo{
                kserveManifestInfo(kSourcePath),
        }

        return nil</span>
}

func deleteFeatureTrackers(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        ftNames := []string{
                rr.DSCI.Spec.ApplicationsNamespace + "-serverless-serving-deployment",
                rr.DSCI.Spec.ApplicationsNamespace + "-serverless-net-istio-secret-filtering",
                rr.DSCI.Spec.ApplicationsNamespace + "-serverless-serving-gateways",
                rr.DSCI.Spec.ApplicationsNamespace + "-kserve-external-authz",
        }

        for _, n := range ftNames </span><span class="cov0" title="0">{
                ft := featuresv1.FeatureTracker{}
                err := rr.Client.Get(ctx, client.ObjectKey{Name: n}, &amp;ft)
                if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to lookup FeatureTracker %s: %w", ft.GetName(), err)
                }</span>

                <span class="cov0" title="0">err = rr.Client.Delete(ctx, &amp;ft, client.PropagationPolicy(metav1.DeletePropagationForeground))
                if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete FeatureTracker %s: %w", ft.GetName(), err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func addServingCertResourceIfManaged(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        k, ok := rr.Instance.(*componentApi.Kserve)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kserve)", rr.Instance)
        }</span>

        <span class="cov0" title="0">if k.Spec.Serving.ManagementState == operatorv1.Managed </span><span class="cov0" title="0">{
                if rr.DSCI.Spec.ServiceMesh == nil </span><span class="cov0" title="0">{
                        return errors.New("ServiceMesh needs to be configured and 'Managed' in DSCI CR, " +
                                "it is required by KServe serving")
                }</span>

                <span class="cov0" title="0">err := createServingCertResource(ctx, rr.Client, &amp;rr.DSCI.Spec, k)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to create serverless serving certificate secret: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func addTemplateFiles(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov8" title="1">{
        // Always add all the templates...will get removed before deploy if necessary
        templates := []odhtypes.TemplateInfo{
                {
                        FS:   resourcesFS,
                        Path: "resources/serving-install/service-mesh-subscription.tmpl.yaml",
                },
                {
                        FS:   resourcesFS,
                        Path: "resources/serving-install/knative-serving.tmpl.yaml",
                },
                {
                        FS:   resourcesFS,
                        Path: "resources/servicemesh/routing/istio-ingress-gateway.tmpl.yaml",
                },
                {
                        FS:   resourcesFS,
                        Path: "resources/servicemesh/routing/istio-kserve-local-gateway.tmpl.yaml",
                },
                {
                        FS:   resourcesFS,
                        Path: "resources/servicemesh/routing/istio-local-gateway.yaml",
                },
                {
                        FS:   resourcesFS,
                        Path: "resources/servicemesh/routing/kserve-local-gateway-svc.tmpl.yaml",
                },
                {
                        FS:   resourcesFS,
                        Path: "resources/servicemesh/routing/local-gateway-svc.tmpl.yaml",
                },

                // These are the servicemesh ones, only deployed when authorino also installed
                {
                        FS:   resourcesFS,
                        Path: "resources/servicemesh/activator-envoyfilter.tmpl.yaml",
                },
                {
                        FS:   resourcesFS,
                        Path: "resources/servicemesh/kserve-predictor-authorizationpolicy.tmpl.yaml",
                },
                {
                        FS:   resourcesFS,
                        Path: "resources/servicemesh/kserve-inferencegraph-envoyfilter.tmpl.yaml",
                },
                {
                        FS:   resourcesFS,
                        Path: "resources/servicemesh/kserve-inferencegraph-authorizationpolicy.tmpl.yaml",
                },
        }

        rr.Templates = append(rr.Templates, templates...)
        return nil
}</span>

func removeOwnershipFromUnmanagedResources(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        k, ok := rr.Instance.(*componentApi.Kserve)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kserve)", rr.Instance)
        }</span>

        // unmanaged: remove ownerref &amp; label to avoid GC
        <span class="cov0" title="0">for _, res := range rr.Resources </span><span class="cov0" title="0">{
                if shouldRemoveOwnerRefAndLabel(rr.DSCI.Spec.ServiceMesh, k.Spec.Serving, res) </span><span class="cov0" title="0">{
                        if err := getAndRemoveOwnerReferences(ctx, rr.Client, res, isKserveOwnerRef); err != nil </span><span class="cov0" title="0">{
                                return odherrors.NewStopErrorW(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func cleanUpTemplatedResources(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov8" title="1">{
        k, ok := rr.Instance.(*componentApi.Kserve)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kserve)", rr.Instance)
        }</span>

        <span class="cov8" title="1">logger := logf.FromContext(ctx)

        authorinoInstalled, err := cluster.SubscriptionExists(ctx, rr.Client, "authorino-operator")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list subscriptions %w", err)
        }</span>

        <span class="cov8" title="1">if rr.DSCI.Spec.ServiceMesh != nil </span><span class="cov8" title="1">{
                // servicemesh is set to Removed
                if rr.DSCI.Spec.ServiceMesh.ManagementState == operatorv1.Removed </span><span class="cov0" title="0">{
                        // Delete servicemesh and serverless resources explicitly in
                        // this case, since the GC won't collect them because the Kserve
                        // CR generation hasn't changed.
                        for _, res := range rr.Resources </span><span class="cov0" title="0">{
                                if isForDependency("serverless")(&amp;res) || isForDependency("servicemesh")(&amp;res) </span><span class="cov0" title="0">{
                                        err := rr.Client.Delete(ctx, &amp;res, client.PropagationPolicy(metav1.DeletePropagationForeground))
                                        if err != nil </span><span class="cov0" title="0">{
                                                if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">if errors.Is(err, &amp;meta.NoKindMatchError{}) </span><span class="cov0" title="0">{ // when CRD is missing,
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">return odherrors.NewStopErrorW(err)</span>
                                        }
                                        <span class="cov0" title="0">logger.Info("Deleted", "kind", res.GetKind(), "name", res.GetName(), "namespace", res.GetNamespace())</span>
                                }
                        }
                }

                // Need to explicitly remove resources from cluster if they exist,
                // to delete resources accidentally created in 2.19.0.
                <span class="cov8" title="1">if !authorinoInstalled </span><span class="cov8" title="1">{
                        for _, res := range rr.Resources </span><span class="cov8" title="1">{
                                if isForDependency("servicemesh")(&amp;res) </span><span class="cov8" title="1">{
                                        err := rr.Client.Delete(ctx, &amp;res, client.PropagationPolicy(metav1.DeletePropagationForeground))
                                        if err != nil </span><span class="cov8" title="1">{
                                                if k8serr.IsNotFound(err) </span><span class="cov8" title="1">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">if errors.Is(err, &amp;meta.NoKindMatchError{}) </span><span class="cov0" title="0">{ // when CRD is missing,
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">return odherrors.NewStopErrorW(err)</span>
                                        }
                                        <span class="cov0" title="0">logger.Info("Deleted", "kind", res.GetKind(), "name", res.GetName(), "namespace", res.GetNamespace())</span>
                                }
                        }
                        <span class="cov8" title="1">if err := rr.RemoveResources(isForDependency("servicemesh")); err != nil </span><span class="cov0" title="0">{
                                return odherrors.NewStopErrorW(err)
                        }</span>
                }

                // servicemesh is set to Removed or Unmanaged
                <span class="cov8" title="1">if rr.DSCI.Spec.ServiceMesh.ManagementState != operatorv1.Managed </span><span class="cov0" title="0">{
                        if err := rr.RemoveResources(isForDependency("servicemesh")); err != nil </span><span class="cov0" title="0">{
                                return odherrors.NewStopErrorW(err)
                        }</span>
                }
        }
        // serverless is Removed or Unmananged
        <span class="cov8" title="1">if k.Spec.Serving.ManagementState != operatorv1.Managed </span><span class="cov0" title="0">{
                if err := rr.RemoveResources(isForDependency("serverless")); err != nil </span><span class="cov0" title="0">{
                        return odherrors.NewStopErrorW(err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func customizeKserveConfigMap(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        k, ok := rr.Instance.(*componentApi.Kserve)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kserve)", rr.Instance)
        }</span>

        <span class="cov0" title="0">logger := logf.FromContext(ctx)

        kserveConfigMap := corev1.ConfigMap{}
        cmidx, err := getIndexedResource(rr.Resources, &amp;kserveConfigMap, gvk.ConfigMap, kserveConfigMapName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //nolint:staticcheck
        <span class="cov0" title="0">serviceClusterIPNone := true
        if k.Spec.RawDeploymentServiceConfig == componentApi.KserveRawHeaded </span><span class="cov0" title="0">{
                // As default is Headless, only set false here if Headed is explicitly set
                serviceClusterIPNone = false
        }</span>

        <span class="cov0" title="0">switch k.Spec.Serving.ManagementState </span>{
        case operatorv1.Managed, operatorv1.Unmanaged:<span class="cov0" title="0">
                // if the default mode is empty in the DSC, assume mode is "Serverless" since k.Serving is Managed
                defaultmode := componentApi.Serverless
                if k.Spec.DefaultDeploymentMode != "" </span><span class="cov0" title="0">{
                        // if the default mode is explicitly specified, respect that
                        defaultmode = k.Spec.DefaultDeploymentMode
                }</span>
                <span class="cov0" title="0">if err := updateInferenceCM(&amp;kserveConfigMap, defaultmode, serviceClusterIPNone); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case operatorv1.Removed:<span class="cov0" title="0">
                if k.Spec.DefaultDeploymentMode == componentApi.Serverless </span><span class="cov0" title="0">{
                        return errors.New("setting defaultdeployment mode as Serverless is incompatible with having Serving 'Removed'")
                }</span>
                <span class="cov0" title="0">if k.Spec.DefaultDeploymentMode == "" </span><span class="cov0" title="0">{
                        logger.Info("Serving is removed, Kserve will default to RawDeployment")
                }</span>
                <span class="cov0" title="0">if err := updateInferenceCM(&amp;kserveConfigMap, componentApi.RawDeployment, serviceClusterIPNone); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err = replaceResourceAtIndex(rr.Resources, cmidx, &amp;kserveConfigMap); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">kserveConfigHash, err := hashConfigMap(&amp;kserveConfigMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">kserveDeployment := appsv1.Deployment{}
        deployidx, err := getIndexedResource(rr.Resources, &amp;kserveDeployment, gvk.Deployment, "kserve-controller-manager")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">kserveDeployment.Spec.Template.Annotations[labels.ODHAppPrefix+"/KserveConfigHash"] = kserveConfigHash

        if err = replaceResourceAtIndex(rr.Resources, deployidx, &amp;kserveDeployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func setStatusFields(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        k, ok := rr.Instance.(*componentApi.Kserve)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kserve)", rr.Instance)
        }</span>

        <span class="cov0" title="0">ddm, err := getDefaultDeploymentMode(ctx, rr.Client, &amp;rr.DSCI.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">k.Status.DefaultDeploymentMode = ddm

        serviceMeshEnabled := false
        if rr.DSCI.Spec.ServiceMesh != nil </span><span class="cov0" title="0">{
                if rr.DSCI.Spec.ServiceMesh.ManagementState == operatorv1.Managed || rr.DSCI.Spec.ServiceMesh.ManagementState == operatorv1.Unmanaged </span><span class="cov0" title="0">{
                        serviceMeshEnabled = true
                }</span>
        }

        //nolint:staticcheck
        <span class="cov0" title="0">serverlessEnabled := false
        if k.Spec.Serving.ManagementState == operatorv1.Managed || k.Spec.Serving.ManagementState == operatorv1.Unmanaged </span><span class="cov0" title="0">{
                serverlessEnabled = true
        }</span>

        <span class="cov0" title="0">k.Status.ServerlessMode = operatorv1.Removed
        if serverlessEnabled &amp;&amp; serviceMeshEnabled </span><span class="cov0" title="0">{
                k.Status.ServerlessMode = operatorv1.Managed
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package kserve

import (
        "context"
        "embed"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "maps"
        "strings"

        operatorv1 "github.com/openshift/api/operator/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        infrav1 "github.com/opendatahub-io/opendatahub-operator/v2/api/infrastructure/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

const DefaultCertificateSecretName = "knative-serving-cert"

var (
        imageParamMap = map[string]string{
                "kserve-agent":                     "RELATED_IMAGE_ODH_KSERVE_AGENT_IMAGE",
                "kserve-controller":                "RELATED_IMAGE_ODH_KSERVE_CONTROLLER_IMAGE",
                "kserve-router":                    "RELATED_IMAGE_ODH_KSERVE_ROUTER_IMAGE",
                "kserve-storage-initializer":       "RELATED_IMAGE_ODH_KSERVE_STORAGE_INITIALIZER_IMAGE",
                "kserve-llm-d-inference-scheduler": "RELATED_IMAGE_ODH_LLM_D_INFERENCE_SCHEDULER_IMAGE",
                "kserve-llm-d-routing-sidecar":     "RELATED_IMAGE_ODH_LLM_D_ROUTING_SIDECAR_IMAGE",
                "oauth-proxy":                      "RELATED_IMAGE_OSE_OAUTH_PROXY_IMAGE",
        }
)

//go:embed resources
var resourcesFS embed.FS

var isRequiredOperators = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                return false
        }</span>,
        CreateFunc: func(e event.CreateEvent) bool <span class="cov0" title="0">{
                return strings.HasPrefix(e.Object.GetName(), serverlessOperator) || strings.HasPrefix(e.Object.GetName(), serviceMeshOperator)
        }</span>,
        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov0" title="0">{
                return strings.HasPrefix(e.Object.GetName(), serverlessOperator) || strings.HasPrefix(e.Object.GetName(), serviceMeshOperator)
        }</span>,
        GenericFunc: func(e event.GenericEvent) bool <span class="cov0" title="0">{
                return false
        }</span>,
}

func kserveManifestInfo(sourcePath string) odhtypes.ManifestInfo <span class="cov0" title="0">{
        return odhtypes.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: componentName,
                SourcePath: sourcePath,
        }
}</span>

func createServingCertResource(ctx context.Context, cli client.Client, dscispec *dsciv1.DSCInitializationSpec, kserve *componentApi.Kserve) error <span class="cov0" title="0">{
        domain := getKnativeDomain(ctx, cli, kserve)
        secretName := getKnativeCertSecretName(kserve)

        switch kserve.Spec.Serving.IngressGateway.Certificate.Type </span>{
        case infrav1.SelfSigned:<span class="cov0" title="0">
                return cluster.CreateSelfSignedCertificate(ctx, cli, secretName,
                        domain, dscispec.ServiceMesh.ControlPlane.Namespace,
                        cluster.OwnedBy(kserve, cli.Scheme()))</span>
        case infrav1.Provided:<span class="cov0" title="0">
                return nil</span>
        case infrav1.OpenshiftDefaultIngress:<span class="cov0" title="0">
                return cluster.PropagateDefaultIngressCertificate(ctx, cli, secretName, dscispec.ServiceMesh.ControlPlane.Namespace)</span>
        default:<span class="cov0" title="0">
                return ErrServerlessUnsupportedCertType</span>
        }
}

func getTemplateData(ctx context.Context, rr *odhtypes.ReconciliationRequest) (map[string]any, error) <span class="cov8" title="1">{
        k, ok := rr.Instance.(*componentApi.Kserve)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resource instance %v is not a componentApi.Kserve)", rr.Instance)
        }</span>

        <span class="cov8" title="1">knativeIngressDomain := getKnativeDomain(ctx, rr.Client, k)
        knativeCertificateSecret := getKnativeCertSecretName(k)

        return map[string]any{
                "AuthExtensionName":        rr.DSCI.Spec.ApplicationsNamespace + "-auth-provider",
                "ControlPlane":             rr.DSCI.Spec.ServiceMesh.ControlPlane,
                "KnativeCertificateSecret": knativeCertificateSecret,
                "KnativeIngressDomain":     knativeIngressDomain,
                "Serving":                  k.Spec.Serving,
        }, nil</span>
}

func getKnativeDomain(ctx context.Context, cli client.Client, k *componentApi.Kserve) string <span class="cov8" title="1">{
        domain := k.Spec.Serving.IngressGateway.Domain
        if domain != "" </span><span class="cov0" title="0">{
                return domain
        }</span>

        <span class="cov8" title="1">domain, err := cluster.GetDomain(ctx, cli)
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">domain = "*." + domain
        return domain</span>
}

func getKnativeCertSecretName(k *componentApi.Kserve) string <span class="cov8" title="1">{
        name := k.Spec.Serving.IngressGateway.Certificate.SecretName
        if name == "" </span><span class="cov8" title="1">{
                name = DefaultCertificateSecretName
        }</span>

        <span class="cov8" title="1">return name</span>
}

func getDefaultDeploymentMode(ctx context.Context, cli client.Client, dscispec *dsciv1.DSCInitializationSpec) (string, error) <span class="cov0" title="0">{
        kserveConfigMap := corev1.ConfigMap{}
        err := cli.Get(ctx, client.ObjectKey{Name: kserveConfigMapName, Namespace: dscispec.ApplicationsNamespace}, &amp;kserveConfigMap)
        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">deployConfig, err := getDeployConfig(&amp;kserveConfigMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return deployConfig.DefaultDeploymentMode, nil</span>
}

func updateInferenceCM(inferenceServiceConfigMap *corev1.ConfigMap, defaultmode componentApi.DefaultDeploymentMode, isHeadless bool) error <span class="cov0" title="0">{
        deployData, err := getDeployConfig(inferenceServiceConfigMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if deployData.DefaultDeploymentMode != string(defaultmode) </span><span class="cov0" title="0">{
                // deploy
                deployData.DefaultDeploymentMode = string(defaultmode)
                deployDataBytes, err := json.MarshalIndent(deployData, "", " ")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not set values in configmap %s. %w", kserveConfigMapName, err)
                }</span>
                <span class="cov0" title="0">inferenceServiceConfigMap.Data[DeployConfigName] = string(deployDataBytes)

                // ingress
                var ingressData map[string]interface{}
                if err = json.Unmarshal([]byte(inferenceServiceConfigMap.Data[IngressConfigKeyName]), &amp;ingressData); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error retrieving value for key '%s' from configmap %s. %w", IngressConfigKeyName, kserveConfigMapName, err)
                }</span>
                <span class="cov0" title="0">if defaultmode == componentApi.RawDeployment </span><span class="cov0" title="0">{
                        ingressData["disableIngressCreation"] = true
                }</span> else<span class="cov0" title="0"> {
                        ingressData["disableIngressCreation"] = false
                }</span>
                <span class="cov0" title="0">ingressDataBytes, err := json.MarshalIndent(ingressData, "", " ")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not set values in configmap %s. %w", kserveConfigMapName, err)
                }</span>
                <span class="cov0" title="0">inferenceServiceConfigMap.Data[IngressConfigKeyName] = string(ingressDataBytes)</span>
        }

        // service
        <span class="cov0" title="0">var serviceData map[string]interface{}
        if err := json.Unmarshal([]byte(inferenceServiceConfigMap.Data[ServiceConfigKeyName]), &amp;serviceData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error retrieving value for key '%s' from configmap %s. %w", ServiceConfigKeyName, kserveConfigMapName, err)
        }</span>
        <span class="cov0" title="0">serviceData["serviceClusterIPNone"] = isHeadless
        serviceDataBytes, err := json.MarshalIndent(serviceData, "", " ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not set values in configmap %s. %w", kserveConfigMapName, err)
        }</span>
        <span class="cov0" title="0">inferenceServiceConfigMap.Data[ServiceConfigKeyName] = string(serviceDataBytes)
        return nil</span>
}

func getIndexedResource(rs []unstructured.Unstructured, obj any, g schema.GroupVersionKind, name string) (int, error) <span class="cov0" title="0">{
        var idx = -1
        for i, r := range rs </span><span class="cov0" title="0">{
                if r.GroupVersionKind() == g &amp;&amp; r.GetName() == name </span><span class="cov0" title="0">{
                        idx = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if idx == -1 </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("could not find %T with name %v in resources list", obj, name)
        }</span>

        <span class="cov0" title="0">err := runtime.DefaultUnstructuredConverter.FromUnstructured(rs[idx].Object, obj)
        if err != nil </span><span class="cov0" title="0">{
                return idx, fmt.Errorf("failed converting to %T from unstructured %v: %w", obj, rs[idx].Object, err)
        }</span>

        <span class="cov0" title="0">return idx, nil</span>
}

func replaceResourceAtIndex(rs []unstructured.Unstructured, idx int, obj any) error <span class="cov0" title="0">{
        u, err := resources.ToUnstructured(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rs[idx] = *u
        return nil</span>
}

func hashConfigMap(cm *corev1.ConfigMap) (string, error) <span class="cov0" title="0">{
        u, err := resources.ToUnstructured(cm)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">h, err := resources.Hash(u)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return base64.RawURLEncoding.EncodeToString(h), nil</span>
}

func ifGVKInstalled(kvg schema.GroupVersionKind) func(context.Context, *odhtypes.ReconciliationRequest) bool <span class="cov0" title="0">{
        return func(ctx context.Context, rr *odhtypes.ReconciliationRequest) bool </span><span class="cov0" title="0">{
                hasCRD, err := cluster.HasCRD(ctx, rr.Client, kvg)
                if err != nil </span><span class="cov0" title="0">{
                        ctrl.Log.Error(err, "error checking if CRD installed", "GVK", kvg)
                        return false
                }</span>
                <span class="cov0" title="0">return hasCRD</span>
        }
}

// shouldRemoveOwnerRefAndLabel encapsulates the decision on whether a resource
// should be excluded from GC collection because it's considered Unmanaged.
func shouldRemoveOwnerRefAndLabel(
        dsciServiceMesh *infrav1.ServiceMeshSpec,
        kserveServing infrav1.ServingSpec,
        res unstructured.Unstructured,
) bool <span class="cov0" title="0">{
        switch </span>{
        case isForDependency("servicemesh")(&amp;res):<span class="cov0" title="0">
                return dsciServiceMesh != nil &amp;&amp; dsciServiceMesh.ManagementState == operatorv1.Unmanaged</span>
        case isForDependency("serverless")(&amp;res):<span class="cov0" title="0">
                if dsciServiceMesh != nil &amp;&amp; dsciServiceMesh.ManagementState == operatorv1.Unmanaged </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if kserveServing.ManagementState == operatorv1.Unmanaged </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func getAndRemoveOwnerReferences(
        ctx context.Context,
        cli client.Client,
        res unstructured.Unstructured,
        predicate func(or metav1.OwnerReference) bool,
) error <span class="cov0" title="0">{
        current := resources.GvkToUnstructured(res.GroupVersionKind())

        lookupErr := cli.Get(ctx, client.ObjectKeyFromObject(&amp;res), current)
        if errors.IsNotFound(lookupErr) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if lookupErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to lookup object %s/%s: %w",
                        res.GetNamespace(), res.GetName(), lookupErr)
        }</span>

        <span class="cov0" title="0">ls := current.GetLabels()
        maps.DeleteFunc(ls, func(k string, v string) bool </span><span class="cov0" title="0">{
                return k == labels.PlatformPartOf &amp;&amp;
                        v == strings.ToLower(componentApi.KserveKind)
        }</span>)
        <span class="cov0" title="0">current.SetLabels(ls)

        return resources.RemoveOwnerReferences(ctx, cli, current, predicate)</span>
}

func isForDependency(s string) func(u *unstructured.Unstructured) bool <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) bool </span><span class="cov8" title="1">{
                for k, v := range u.GetLabels() </span><span class="cov8" title="1">{
                        if k == labels.PlatformDependency &amp;&amp; v == s </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }
}

func isKserveOwnerRef(or metav1.OwnerReference) bool <span class="cov0" title="0">{
        return or.APIVersion == componentApi.GroupVersion.String() &amp;&amp;
                or.Kind == componentApi.KserveKind
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package kueue

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        odherrors "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/errors"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

const (
        kueueOperator          = "kueue-operator"
        kueueOperatorNamespace = "openshift-kueue-operator"
        kueueCRDname           = "kueues.kueue.openshift.io"
)

var (
        ErrKueueOperatorAlreadyInstalled = odherrors.NewStopError(status.KueueOperatorAlreadyInstalledMessage)
        ErrKueueOperatorNotInstalled     = odherrors.NewStopError(status.KueueOperatorNotInstalledMessage)
)

type componentHandler struct{}

func init() <span class="cov3" title="2">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov3" title="2">{
        return componentApi.KueueComponentName
}</span>

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov3" title="2">{
        return &amp;componentApi.Kueue{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.KueueKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.KueueInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.Kueue.ManagementState),
                        },
                },
                Spec: componentApi.KueueSpec{
                        KueueManagementSpec:   dsc.Spec.Components.Kueue.KueueManagementSpec,
                        KueueCommonSpec:       dsc.Spec.Components.Kueue.KueueCommonSpec,
                        KueueDefaultQueueSpec: dsc.Spec.Components.Kueue.KueueDefaultQueueSpec,
                },
        }
}</span>

func (s *componentHandler) Init(platform common.Platform) error <span class="cov0" title="0">{
        if err := odhdeploy.ApplyParams(manifestsPath().String(), "params.env", imageParamMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", manifestsPath(), err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov10" title="9">{
        switch dsc.Spec.Components.Kueue.ManagementState </span>{
        case operatorv1.Managed:<span class="cov6" title="4">
                return true</span>
        case operatorv1.Unmanaged:<span class="cov5" title="3">
                return true</span>
        default:<span class="cov6" title="4">
                return false</span>
        }
}

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov8" title="6">{
        cs := metav1.ConditionUnknown

        c := componentApi.Kueue{}
        c.Name = componentApi.KueueInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov8" title="6">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov8" title="6">ms := components.NormalizeManagementState(dsc.Spec.Components.Kueue.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentName] = false
        dsc.Status.Components.Kueue.ManagementState = ms
        dsc.Status.Components.Kueue.KueueCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov6" title="4">{
                dsc.Status.InstalledComponents[LegacyComponentName] = true
                dsc.Status.Components.Kueue.KueueCommonStatus = c.Status.KueueCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov6" title="4">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov5" title="3"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov8" title="6">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package kueue

import (
        "context"
        "fmt"
        "slices"

        operatorv1 "github.com/openshift/api/operator/v1"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/util/sets"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/kustomize/kyaml/yaml"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

var (
        frameworkMapping = map[string]string{
                "pod":                                      "Pod",
                "deployment":                               "Deployment",
                "statefulset":                              "StatefulSet",
                "batch/job":                                "BatchJob",
                "ray.io/rayjob":                            "RayJob",
                "ray.io/raycluster":                        "RayCluster",
                "jobset.x-k8s.io/jobset":                   "JobSet",
                "kubeflow.org/mpijob":                      "MPIJob",
                "kubeflow.org/paddlejob":                   "PaddleJob",
                "kubeflow.org/pytorchjob":                  "PyTorchJob",
                "kubeflow.org/tfjob":                       "TFJob",
                "kubeflow.org/xgboostjob":                  "XGBoostJob",
                "workload.codeflare.dev/appwrapper":        "AppWrapper",
                "leaderworkerset.x-k8s.io/leaderworkerset": "LeaderWorkerSet",
        }
)

func lookupKueueManagerConfig(ctx context.Context, rr *odhtypes.ReconciliationRequest) (map[string]any, error) <span class="cov6" title="17">{
        cm := corev1.ConfigMap{}
        config := map[string]any{}

        err := rr.Client.Get(
                ctx,
                client.ObjectKey{Name: KueueConfigMapName, Namespace: rr.DSCI.Spec.ApplicationsNamespace},
                &amp;cm,
        )

        switch </span>{
        case k8serr.IsNotFound(err):<span class="cov3" title="4">
                return config, nil</span>
        case err != nil:<span class="cov0" title="0">
                return nil, err</span>
        }

        <span class="cov6" title="14">content, ok := cm.Data[KueueConfigMapEntry]
        if !ok </span><span class="cov0" title="0">{
                return config, nil
        }</span>

        <span class="cov6" title="14">if err := yaml.Unmarshal([]byte(content), &amp;config); err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="13">return config, nil</span>
}

func createKueueCR(ctx context.Context, rr *odhtypes.ReconciliationRequest) (*unstructured.Unstructured, error) <span class="cov6" title="17">{
        managerConfig, err := lookupKueueManagerConfig(ctx, rr)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to lookup kueue manager config: %w", err)
        }</span>

        //
        // Conversions
        //

        <span class="cov6" title="16">integrations, err := convertIntegrations(managerConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert integrations: %w", err)
        }</span>

        <span class="cov6" title="16">workloadMgmt, err := convertWorkloadManagement(managerConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert workload management: %w", err)
        }</span>

        <span class="cov6" title="16">gangScheduling, err := convertGangScheduling(managerConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert gang scheduling: %w", err)
        }</span>

        <span class="cov6" title="16">preemption, err := convertPreemption(managerConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert preemption: %w", err)
        }</span>

        //
        // Spec
        //

        <span class="cov6" title="16">config := map[string]interface{}{}

        obj := map[string]interface{}{
                "spec": map[string]interface{}{
                        "managementState": string(operatorv1.Managed),
                        "config":          config,
                },
        }

        if len(integrations) != 0 </span><span class="cov6" title="16">{
                config["integrations"] = integrations
        }</span>
        <span class="cov6" title="16">if len(workloadMgmt) != 0 </span><span class="cov3" title="3">{
                config["workloadManagement"] = workloadMgmt
        }</span>
        <span class="cov6" title="16">if len(gangScheduling) != 0 </span><span class="cov3" title="4">{
                config["gangScheduling"] = gangScheduling
        }</span>
        <span class="cov6" title="16">if len(preemption) != 0 </span><span class="cov3" title="3">{
                config["preemption"] = preemption
        }</span>

        // use resources.ToUnstructured so that it the content gets cleaned up
        // in case there are some misconfiguration i.e. int vs int64
        <span class="cov6" title="16">u, err := resources.ToUnstructured(&amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build unstructured content: %w", err)
        }</span>

        <span class="cov6" title="16">u.SetGroupVersionKind(gvk.KueueConfigV1)
        u.SetName(KueueCRName)

        // Set annotations to indicate this is not managed by ODH operator
        u.SetAnnotations(map[string]string{
                annotations.ManagedByODHOperator: "false",
        })

        return u, nil</span>
}

// convertIntegrations converts the integrations section from ConfigMap to Kueue operator format.
func convertIntegrations(config map[string]interface{}) (map[string]interface{}, error) <span class="cov6" title="16">{
        integrations := map[string]interface{}{}

        //
        // integrations/frameworks
        //

        frameworks, _, err := unstructured.NestedStringSlice(config, "integrations", "frameworks")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract frameworks: %w", err)
        }</span>

        <span class="cov6" title="16">frameworkSet := sets.New[string](
                "RayJob",
                "RayCluster",
                "PyTorchJob",
                "Pod",
                "Deployment",
                "StatefulSet",
        )

        for _, framework := range frameworks </span><span class="cov7" title="22">{
                if converted, ok := frameworkMapping[framework]; ok </span><span class="cov6" title="21">{
                        frameworkSet.Insert(converted)
                }</span>
        }

        <span class="cov6" title="16">convertedFrameworks := frameworkSet.UnsortedList()
        if len(convertedFrameworks) &gt; 0 </span><span class="cov6" title="16">{
                slices.Sort(convertedFrameworks)
                interfaceSlice := make([]interface{}, len(convertedFrameworks))
                for i, v := range convertedFrameworks </span><span class="cov10" title="102">{
                        interfaceSlice[i] = v
                }</span>
                <span class="cov6" title="16">integrations["frameworks"] = interfaceSlice</span>
        }

        //
        // integrations/externalFrameworks
        //

        <span class="cov6" title="16">externalFrameworksSet := sets.New[string]()

        externalFrameworks, _, err := unstructured.NestedStringSlice(config, "integrations", "externalFrameworks")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract external frameworks: %w", err)
        }</span>

        <span class="cov6" title="16">for _, framework := range externalFrameworks </span><span class="cov4" title="5">{
                if converted, ok := frameworkMapping[framework]; ok </span><span class="cov4" title="5">{
                        externalFrameworksSet.Insert(converted)
                }</span>
        }

        <span class="cov6" title="16">convertedExternalFrameworks := externalFrameworksSet.UnsortedList()
        if len(convertedExternalFrameworks) &gt; 0 </span><span class="cov3" title="3">{
                slices.Sort(convertedExternalFrameworks)
                interfaceSlice := make([]interface{}, len(convertedExternalFrameworks))
                for i, v := range convertedExternalFrameworks </span><span class="cov4" title="5">{
                        interfaceSlice[i] = v
                }</span>
                <span class="cov3" title="3">integrations["externalFrameworks"] = interfaceSlice</span>
        }

        //
        // integrations/labelKeys
        //

        <span class="cov6" title="16">labelKeys, _, err := unstructured.NestedStringSlice(config, "integrations", "labelKeys")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract label keys: %w", err)
        }</span>

        <span class="cov6" title="16">if len(labelKeys) &gt; 0 </span><span class="cov3" title="3">{
                slices.Sort(labelKeys)
                interfaceSlice := make([]interface{}, len(labelKeys))
                for i, v := range labelKeys </span><span class="cov4" title="5">{
                        interfaceSlice[i] = v
                }</span>
                <span class="cov3" title="3">integrations["labelKeys"] = interfaceSlice</span>
        }

        <span class="cov6" title="16">return integrations, nil</span>
}

// convertWorkloadManagement converts workload management configuration.
func convertWorkloadManagement(config map[string]interface{}) (map[string]interface{}, error) <span class="cov6" title="16">{
        manageJobsWithoutQueueName, found, err := unstructured.NestedBool(config, "manageJobsWithoutQueueName")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract manageJobsWithoutQueueName: %w", err)
        }</span>

        <span class="cov6" title="16">if !found </span><span class="cov6" title="14">{
                return nil, nil
        }</span>

        <span class="cov3" title="3">workloadMgmt := map[string]interface{}{
                "labelPolicy": "QueueName",
        }

        if manageJobsWithoutQueueName </span><span class="cov3" title="3">{
                workloadMgmt["labelPolicy"] = "None"
        }</span>

        <span class="cov3" title="3">return workloadMgmt, nil</span>
}

func convertGangScheduling(config map[string]interface{}) (map[string]interface{}, error) <span class="cov6" title="16">{
        waitForPodsReady, found, err := unstructured.NestedMap(config, "waitForPodsReady")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract waitForPodsReady: %w", err)
        }</span>

        <span class="cov6" title="16">if !found </span><span class="cov5" title="12">{
                return nil, nil
        }</span>

        <span class="cov4" title="5">enabled, _, err := unstructured.NestedBool(waitForPodsReady, "enable")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract waitForPodsReady.enable: %w", err)
        }</span>

        <span class="cov4" title="5">if !enabled </span><span class="cov2" title="2">{
                return nil, nil
        }</span>

        <span class="cov3" title="4">gangScheduling := map[string]interface{}{
                "policy": "None",
        }

        gangScheduling["policy"] = "ByWorkload"

        byWorkload := map[string]interface{}{
                "admission": "Parallel", // Default to Parallel
        }

        blockAdmission, _, err := unstructured.NestedBool(waitForPodsReady, "blockAdmission")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract waitForPodsReady.blockAdmission: %w", err)
        }</span>

        <span class="cov3" title="4">if blockAdmission </span><span class="cov2" title="2">{
                byWorkload["admission"] = "Sequential"
        }</span>

        <span class="cov3" title="4">timeout, _, err := unstructured.NestedString(waitForPodsReady, "timeout")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract timeout: %w", err)
        }</span>

        <span class="cov3" title="4">if timeout != "" </span><span class="cov2" title="2">{
                byWorkload["timeout"] = timeout
        }</span>

        <span class="cov3" title="4">gangScheduling["byWorkload"] = byWorkload

        return gangScheduling, nil</span>
}

func convertPreemption(config map[string]interface{}) (map[string]interface{}, error) <span class="cov6" title="16">{
        fairSharing, found, err := unstructured.NestedMap(config, "fairSharing")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract fairSharing: %w", err)
        }</span>
        <span class="cov6" title="16">if !found </span><span class="cov6" title="14">{
                return nil, nil
        }</span>

        <span class="cov3" title="3">preemption := map[string]interface{}{
                "preemptionPolicy": "Classical",
        }

        if found </span><span class="cov3" title="3">{
                // Check if fair sharing is enabled
                enabled, _, err := unstructured.NestedBool(fairSharing, "enable")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to extract fairSharing.enable: %w", err)
                }</span>

                <span class="cov3" title="3">if enabled </span><span class="cov3" title="3">{
                        preemption["preemptionPolicy"] = "FairSharing"
                        // Include the fairSharing configuration from the original config
                        preemption["fairSharing"] = fairSharing
                }</span>
        }

        <span class="cov3" title="3">return preemption, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package kueue

import (
        "context"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        promv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        b := reconciler.ReconcilerFor(mgr, &amp;componentApi.Kueue{}).
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.Secret{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;networkingv1.NetworkPolicy{}).
                Owns(&amp;promv1.PodMonitor{}).
                Owns(&amp;promv1.PrometheusRule{}).
                Owns(&amp;admissionregistrationv1.MutatingWebhookConfiguration{}).
                Owns(&amp;admissionregistrationv1.ValidatingWebhookConfiguration{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Watches(
                        &amp;corev1.ConfigMap{},
                        reconciler.WithPredicates(
                                predicates.DefaultPredicate,
                                component.ForLabel(labels.PlatformPartOf, componentApi.KueueComponentName),
                                resources.CreatedOrUpdatedOrDeletedNamed(KueueConfigMapName),
                        ),
                ).
                WatchesGVK(gvk.LocalQueue,
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.KueueInstanceName),
                        ),
                        reconciler.Dynamic(reconciler.CrdExists(gvk.LocalQueue))).
                WatchesGVK(gvk.ClusterQueue,
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.KueueInstanceName),
                        ),
                        reconciler.Dynamic(reconciler.CrdExists(gvk.ClusterQueue))).
                WatchesGVK(gvk.KueueConfigV1,
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.KueueInstanceName),
                        ),
                        reconciler.Dynamic(reconciler.CrdExists(gvk.KueueConfigV1))).
                WatchesGVK(gvk.OperatorCondition,
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.KueueInstanceName),
                        ),
                        reconciler.WithPredicates(resources.CreatedOrUpdatedOrDeletedNamePrefixed(kueueOperator))).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.KueueInstanceName)),
                        reconciler.WithPredicates(predicate.Or(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                                resources.CreatedOrUpdatedOrDeletedNamed(kueueCRDname),
                        )),
                ).
                Watches(&amp;rbacv1.ClusterRole{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.KueueInstanceName),
                        ),
                        reconciler.WithPredicates(resources.CreatedOrUpdatedName(ClusterQueueViewerRoleName), predicate.LabelChangedPredicate{}),
                ).
                Watches(&amp;corev1.Namespace{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.KueueInstanceName),
                        ),
                        reconciler.WithPredicates(
                                predicate.And(
                                        predicate.LabelChangedPredicate{},
                                        predicate.Or(component.ForLabel(cluster.KueueManagedLabelKey, "true"), component.ForLabel(cluster.KueueLegacyManagedLabelKey, "true")),
                                ),
                        ),
                ).
                Watches(&amp;serviceApi.Auth{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.KueueInstanceName),
                        ),
                ).
                WithAction(checkPreConditions).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(releases.NewAction()).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(manageDefaultKueueResourcesAction).
                WithAction(manageKueueAdminRoleBinding).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                WithAction(func(ctx context.Context, rr *types.ReconciliationRequest) error </span><span class="cov0" title="0">{
                        kueueCRInstance, ok := rr.Instance.(*componentApi.Kueue)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("resource instance %v is not a componentApi.Kueue)", rr.Instance)
                        }</span>
                        <span class="cov0" title="0">if kueueCRInstance.Spec.KueueManagementSpec.ManagementState == operatorv1.Unmanaged </span><span class="cov0" title="0">{
                                rr.Conditions.MarkFalse(status.ConditionDeploymentsAvailable, conditions.WithSeverity(common.ConditionSeverityInfo))
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }).
                WithAction(configureClusterQueueViewerRoleAction).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...)

        <span class="cov0" title="0">if _, err := b.Build(ctx); err != nil </span><span class="cov0" title="0">{
                return err // no need customize error, it is done in the caller main
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package kueue

import (
        "context"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        odherrors "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/errors"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

func checkPreConditions(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov8" title="7">{
        kueueCRInstance, ok := rr.Instance.(*componentApi.Kueue)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kueue)", rr.Instance)
        }</span>

        <span class="cov8" title="7">rConfig, err := cluster.HasCRD(ctx, rr.Client, gvk.MultiKueueConfigV1Alpha1)
        if err != nil </span><span class="cov0" title="0">{
                return odherrors.NewStopError("failed to check %s CRDs version: %w", gvk.MultiKueueConfigV1Alpha1, err)
        }</span>

        <span class="cov8" title="7">rCluster, err := cluster.HasCRD(ctx, rr.Client, gvk.MultikueueClusterV1Alpha1)
        if err != nil </span><span class="cov0" title="0">{
                return odherrors.NewStopError("failed to check %s CRDs version: %w", gvk.MultikueueClusterV1Alpha1, err)
        }</span>

        <span class="cov8" title="7">if rConfig || rCluster </span><span class="cov6" title="4">{
                return odherrors.NewStopError(status.MultiKueueCRDMessage)
        }</span>

        <span class="cov6" title="4">switch kueueCRInstance.Spec.ManagementState </span>{
        case operatorv1.Managed:<span class="cov3" title="2">
                if found, err := cluster.OperatorExists(ctx, rr.Client, kueueOperator); err != nil || found </span><span class="cov3" title="2">{
                        if err != nil </span><span class="cov0" title="0">{
                                return odherrors.NewStopErrorW(err)
                        }</span>

                        <span class="cov3" title="2">return odherrors.NewStopErrorW(ErrKueueOperatorAlreadyInstalled)</span>
                }
        case operatorv1.Unmanaged:<span class="cov3" title="2">
                if found, err := cluster.OperatorExists(ctx, rr.Client, kueueOperator); err != nil || !found </span><span class="cov3" title="2">{
                        if err != nil </span><span class="cov0" title="0">{
                                return odherrors.NewStopErrorW(err)
                        }</span>

                        <span class="cov3" title="2">return odherrors.NewStopErrorW(ErrKueueOperatorNotInstalled)</span>
                }
        default:<span class="cov3" title="2">
                return nil</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func initialize(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov5" title="3">{
        kueueCRInstance, ok := rr.Instance.(*componentApi.Kueue)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kueue)", rr.Instance)
        }</span>

        <span class="cov5" title="3">if kueueCRInstance.Spec.ManagementState == operatorv1.Managed </span><span class="cov3" title="2">{
                rr.Manifests = append(rr.Manifests, manifestsPath())
        }</span>
        <span class="cov5" title="3">rr.Manifests = append(rr.Manifests, kueueConfigManifestsPath())

        return nil</span>
}

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        kueue, ok := rr.Instance.(*componentApi.Kueue)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kueue)", rr.Instance)
        }</span>

        <span class="cov0" title="0">if kueue.Spec.DevFlags == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Implement devflags support logic
        // If dev flags are set, update default manifests path
        <span class="cov0" title="0">if len(kueue.Spec.DevFlags.Manifests) != 0 </span><span class="cov0" title="0">{
                manifestConfig := kueue.Spec.DevFlags.Manifests[0]
                if err := odhdeploy.DownloadManifests(ctx, ComponentName, manifestConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if manifestConfig.SourcePath != "" </span><span class="cov0" title="0">{
                        rr.Manifests[0].Path = odhdeploy.DefaultManifestPath
                        rr.Manifests[0].ContextDir = ComponentName
                        rr.Manifests[0].SourcePath = manifestConfig.SourcePath
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func configureClusterQueueViewerRoleAction(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov8" title="6">{
        c := rr.Client
        var cr rbacv1.ClusterRole
        cr.Name = ClusterQueueViewerRoleName
        if err := c.Get(ctx, client.ObjectKeyFromObject(&amp;cr), &amp;cr); err != nil </span><span class="cov3" title="2">{
                return client.IgnoreNotFound(err)
        }</span>
        <span class="cov7" title="5">l := cr.GetLabels()
        if l == nil </span><span class="cov5" title="3">{
                l = map[string]string{}
        }</span>
        <span class="cov7" title="5">if l[KueueBatchUserLabel] == "true" </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov6" title="4">l[KueueBatchUserLabel] = "true"
        cr.SetLabels(l)
        return c.Update(ctx, &amp;cr)</span>
}

func manageKueueAdminRoleBinding(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov8" title="6">{
        log := logf.FromContext(ctx)

        // Get the Auth CR to access admin groups
        authCR := &amp;serviceApi.Auth{}
        err := rr.Client.Get(ctx, client.ObjectKey{Name: serviceApi.AuthInstanceName}, authCR)
        if err != nil </span><span class="cov3" title="2">{
                if k8serr.IsNotFound(err) </span><span class="cov3" title="2">{
                        log.Info("Auth CR not found, skipping kueue admin role binding creation")
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get Auth CR: %w", err)</span>
        }

        // Filter admin groups (exclude system:authenticated and empty strings)
        // This is needed for upgrade scenarios where Auth CRs might contain invalid groups
        // from before the webhook was implemented
        <span class="cov7" title="5">var validAdminGroups []string
        for _, group := range authCR.Spec.AdminGroups </span><span class="cov10" title="10">{
                if group != "system:authenticated" &amp;&amp; group != "" </span><span class="cov8" title="6">{
                        validAdminGroups = append(validAdminGroups, group)
                }</span>
        }

        // Create subjects for the role binding
        <span class="cov7" title="5">subjects := []rbacv1.Subject{}
        for _, group := range validAdminGroups </span><span class="cov8" title="6">{
                subjects = append(subjects, rbacv1.Subject{
                        Kind:     gvk.Group.Kind,
                        APIGroup: gvk.Group.Group,
                        Name:     group,
                })
        }</span>

        // Create the ClusterRoleBinding
        <span class="cov7" title="5">crb := &amp;rbacv1.ClusterRoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name: KueueAdminRoleBindingName,
                },
                Subjects: subjects,
                RoleRef: rbacv1.RoleRef{
                        APIGroup: gvk.ClusterRole.Group,
                        Kind:     gvk.ClusterRole.Kind,
                        Name:     KueueAdminRoleName,
                },
        }

        err = rr.AddResources(crb)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating kueue admin ClusterRoleBinding: %w", err)
        }</span>

        <span class="cov7" title="5">log.Info("Successfully managed kueue admin role binding", "adminGroups", validAdminGroups)
        return nil</span>
}

func manageDefaultKueueResourcesAction(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov7" title="5">{
        kueueCRInstance, ok := rr.Instance.(*componentApi.Kueue)
        if !ok </span><span class="cov3" title="2">{
                return fmt.Errorf("resource instance %v is not a componentApi.Kueue)", rr.Instance)
        }</span>

        // Only proceed if Kueue is in Managed or Unmanaged state.
        <span class="cov6" title="4">if kueueCRInstance.Spec.ManagementState == operatorv1.Removed </span><span class="cov3" title="2">{
                return nil
        }</span>

        // In Unmanaged case create HBoK Kueue CR 'default'.
        <span class="cov5" title="3">if kueueCRInstance.Spec.ManagementState == operatorv1.Unmanaged </span><span class="cov3" title="2">{
                defaultKueueConfig, err := createKueueCR(ctx, rr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov3" title="2">rr.Resources = append(rr.Resources, *defaultKueueConfig)</span>
        }

        // Generate default ClusterQueue.
        <span class="cov5" title="3">clusterQueue := createDefaultClusterQueue(kueueCRInstance.Spec.DefaultClusterQueueName)
        rr.Resources = append(rr.Resources, *clusterQueue)

        // Get all managed namespaces (i.e. the one opterd in with the addition of the proper labels).
        managedNamespaces, err := getManagedNamespaces(ctx, rr.Client)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get managed namespaces: %w", err)
        }</span>
        // Update managed namespaces with missing labels
        <span class="cov5" title="3">err = ensureKueueLabelsOnManagedNamespaces(ctx, rr.Client, managedNamespaces)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add missing labels to managed namespaces: %v with error: %w", managedNamespaces, err)
        }</span>

        // Generate LocalQueues in each managed namespaces.
        <span class="cov5" title="3">for _, ns := range managedNamespaces </span><span class="cov8" title="7">{
                localQueue := createDefaultLocalQueue(kueueCRInstance.Spec.DefaultLocalQueueName, kueueCRInstance.Spec.DefaultClusterQueueName, ns.Name)
                rr.Resources = append(rr.Resources, *localQueue)
        }</span>

        <span class="cov5" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package kueue

import (
        "context"
        "fmt"
        "maps"

        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "sigs.k8s.io/controller-runtime/pkg/client"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

const (
        ComponentName = componentApi.KueueComponentName

        ReadyConditionType = componentApi.KueueKind + status.ReadySuffix

        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName        = "kueue"
        ClusterQueueViewerRoleName = "kueue-clusterqueue-viewer-role"
        KueueBatchUserLabel        = "rbac.kueue.x-k8s.io/batch-user"
        KueueAdminRoleBindingName  = "kueue-admin-rolebinding"
        KueueAdminRoleName         = "kueue-batch-admin-role"

        KueueCRName         = "cluster"
        KueueConfigMapName  = "kueue-manager-config"
        KueueConfigMapEntry = "controller_manager_config.yaml"

        NSListLimit = 500
)

var (
        imageParamMap = map[string]string{
                "odh-kueue-controller-image": "RELATED_IMAGE_ODH_KUEUE_CONTROLLER_IMAGE",
        }

        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

func manifestsPath() odhtypes.ManifestInfo <span class="cov5" title="3">{
        return odhtypes.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: "rhoai",
        }
}</span>

func kueueConfigManifestsPath() odhtypes.ManifestInfo <span class="cov7" title="5">{
        return odhtypes.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: "kueue-configs",
                SourcePath: "",
        }
}</span>

func getManagedNamespaces(ctx context.Context, c client.Client) ([]corev1.Namespace, error) <span class="cov5" title="3">{
        // Deduped namespaces, since some might have both labels.
        var uniqueNamespaces = make(map[string]corev1.Namespace)

        // Add all namespaces with management label.
        if err := collectNamespacesWithPagination(ctx, c, uniqueNamespaces, client.MatchingLabels{
                cluster.KueueManagedLabelKey: "true",
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Add namespaces with legacy management label.
        <span class="cov5" title="3">if err := collectNamespacesWithPagination(ctx, c, uniqueNamespaces, client.MatchingLabels{
                cluster.KueueLegacyManagedLabelKey: "true",
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="3">managedNamespacesList := []corev1.Namespace{}
        for v := range maps.Values(uniqueNamespaces) </span><span class="cov8" title="7">{
                managedNamespacesList = append(managedNamespacesList, v)
        }</span>

        <span class="cov5" title="3">return managedNamespacesList, nil</span>
}

func collectNamespacesWithPagination(ctx context.Context, c client.Client, namespaceSet map[string]corev1.Namespace, opts ...client.ListOption) error <span class="cov7" title="5">{
        lo := client.ListOptions{
                Limit: NSListLimit,
        }
        opts = append(opts, &amp;lo)
        for </span><span class="cov7" title="5">{
                // Listing namespaces with management label
                namespaces := &amp;corev1.NamespaceList{}
                if err := c.List(ctx, namespaces, opts...); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list namespaces with label %s: %w", cluster.KueueManagedLabelKey+"=true", err)
                }</span>

                <span class="cov7" title="5">for _, ns := range namespaces.Items </span><span class="cov10" title="9">{
                        namespaceSet[ns.Name] = ns
                }</span>

                <span class="cov7" title="5">if namespaces.Continue == "" </span><span class="cov7" title="5">{
                        break</span>
                }

                <span class="cov0" title="0">lo.Continue = namespaces.Continue</span>
        }
        <span class="cov7" title="5">return nil</span>
}

// i.e. if a namespace has just the KueueLegacyManagedLabelKey or the KueueManagedLabelKey, the other one is added as well.
func ensureKueueLabelsOnManagedNamespaces(ctx context.Context, c client.Client, namespaces []corev1.Namespace) error <span class="cov5" title="3">{
        for _, ns := range namespaces </span><span class="cov8" title="7">{
                hasLegacy := resources.HasLabel(&amp;ns, cluster.KueueLegacyManagedLabelKey)
                hasManaged := resources.HasLabel(&amp;ns, cluster.KueueManagedLabelKey)

                // Skip if both labels are already present
                if hasLegacy &amp;&amp; hasManaged </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Set both labels to ensure consistency
                <span class="cov8" title="7">resources.SetLabels(&amp;ns, map[string]string{
                        cluster.KueueLegacyManagedLabelKey: "true",
                        cluster.KueueManagedLabelKey:       "true",
                })

                if err := c.Update(ctx, &amp;ns); err != nil </span><span class="cov0" title="0">{
                        if !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov5" title="3">return nil</span>
}

func createDefaultClusterQueue(name string) *unstructured.Unstructured <span class="cov5" title="3">{
        clusterQueue := &amp;unstructured.Unstructured{}

        clusterQueue.Object = map[string]interface{}{
                "apiVersion": gvk.ClusterQueue.GroupVersion().String(),
                "kind":       gvk.ClusterQueue.Kind,
                "metadata": map[string]interface{}{
                        "name": name,
                        "annotations": map[string]interface{}{
                                annotations.ManagedByODHOperator: "false",
                        },
                },
                "spec": map[string]interface{}{
                        "namespaceSelector": map[string]interface{}{},
                },
        }

        return clusterQueue
}</span>

func createDefaultLocalQueue(name string, clusterQueueName string, namespace string) *unstructured.Unstructured <span class="cov8" title="7">{
        localQueue := &amp;unstructured.Unstructured{}

        localQueue.Object = map[string]interface{}{
                "apiVersion": gvk.LocalQueue.GroupVersion().String(),
                "kind":       gvk.LocalQueue.Kind,
                "metadata": map[string]interface{}{
                        "name":      name,
                        "namespace": namespace,
                        "annotations": map[string]interface{}{
                                annotations.ManagedByODHOperator: "false",
                        },
                },
                "spec": map[string]interface{}{
                        "clusterQueue": clusterQueueName,
                },
        }

        return localQueue
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package modelcontroller

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov8" title="1">{
        return componentApi.ModelControllerComponentName
}</span>

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov8" title="1">{
        // extra logic to set the management .spec.component.managementState, to not leave blank {}
        kState := operatorv1.Removed
        if dsc.Spec.Components.Kserve.ManagementState == operatorv1.Managed </span><span class="cov8" title="1">{
                kState = operatorv1.Managed
        }</span>

        <span class="cov8" title="1">mState := operatorv1.Removed
        if dsc.Spec.Components.ModelMeshServing.ManagementState == operatorv1.Managed </span><span class="cov8" title="1">{
                mState = operatorv1.Managed
        }</span>

        <span class="cov8" title="1">mrState := operatorv1.Removed
        if dsc.Spec.Components.ModelRegistry.ManagementState == operatorv1.Managed </span><span class="cov8" title="1">{
                mrState = operatorv1.Managed
        }</span>

        <span class="cov8" title="1">managementState := operatorv1.Removed
        if kState == operatorv1.Managed || mState == operatorv1.Managed </span><span class="cov8" title="1">{
                managementState = operatorv1.Managed
        }</span>

        <span class="cov8" title="1">return &amp;componentApi.ModelController{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.ModelControllerKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.ModelControllerInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(managementState),
                        },
                },
                Spec: componentApi.ModelControllerSpec{
                        ModelMeshServing: &amp;componentApi.ModelControllerMMSpec{
                                ManagementState: mState,
                                DevFlagsSpec:    dsc.Spec.Components.ModelMeshServing.DevFlagsSpec,
                        },
                        Kserve: &amp;componentApi.ModelControllerKerveSpec{
                                ManagementState: kState,
                                DevFlagsSpec:    dsc.Spec.Components.Kserve.DevFlagsSpec,
                                NIM:             dsc.Spec.Components.Kserve.NIM,
                        },
                        ModelRegistry: &amp;componentApi.ModelControllerMRSpec{
                                ManagementState: mrState,
                        },
                },
        }</span>
}

// Init for set images.
func (s *componentHandler) Init(_ common.Platform) error <span class="cov0" title="0">{
        // Update image parameters
        if err := odhdeploy.ApplyParams(manifestsPath().String(), "params.env", imageParamMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", manifestsPath(), err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov8" title="1">{
        switch </span>{
        case cr.IsComponentEnabled(componentApi.ModelMeshServingComponentName, dsc):<span class="cov8" title="1">
                return true</span>
        case cr.IsComponentEnabled(componentApi.KserveComponentName, dsc):<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov8" title="1">{
        cs := metav1.ConditionUnknown

        c := componentApi.ModelController{}
        c.Name = componentApi.ModelControllerInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov8" title="1">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov8" title="1">rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov8" title="1">{
                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov8" title="1">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov8" title="1"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(operatorv1.Removed)),
                        conditions.WithMessage("Component ManagementState is set to %s", operatorv1.Removed),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov8" title="1">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package modelcontroller

import (
        "context"
        "fmt"
        "strings"

        operatorv1 "github.com/openshift/api/operator/v1"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

func initialize(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        // early exist
        mc, ok := rr.Instance.(*componentApi.ModelController)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.ModelController)", rr.Instance)
        }</span>
        <span class="cov0" title="0">rr.Manifests = append(rr.Manifests, manifestsPath())

        nimState := operatorv1.Removed
        if mc.Spec.Kserve.ManagementState == operatorv1.Managed </span><span class="cov0" title="0">{
                nimState = mc.Spec.Kserve.NIM.ManagementState
        }</span>

        <span class="cov0" title="0">mrState := operatorv1.Removed
        if mc.Spec.ModelRegistry != nil &amp;&amp; mc.Spec.ModelRegistry.ManagementState == operatorv1.Managed </span><span class="cov0" title="0">{
                mrState = operatorv1.Managed
        }</span>

        <span class="cov0" title="0">extraParamsMap := map[string]string{
                "nim-state":              strings.ToLower(string(nimState)),
                "kserve-state":           strings.ToLower(string(mc.Spec.Kserve.ManagementState)),
                "modelmeshserving-state": strings.ToLower(string(mc.Spec.ModelMeshServing.ManagementState)),
                "modelregistry-state":    strings.ToLower(string(mrState)),
        }
        if err := odhdeploy.ApplyParams(rr.Manifests[0].String(), "params.env", nil, extraParamsMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", rr.Manifests[0].String(), err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// download devflag from kserve or modelmeshserving.
func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        mc, ok := rr.Instance.(*componentApi.ModelController)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.ModelController)", rr.Instance)
        }</span>

        <span class="cov0" title="0">l := logf.FromContext(ctx)

        var df *common.DevFlags

        ks := mc.Spec.Kserve
        ms := mc.Spec.ModelMeshServing

        switch </span>{
        case ks != nil &amp;&amp; ks.ManagementState == operatorv1.Managed &amp;&amp; resources.HasDevFlags(ks):<span class="cov0" title="0">
                l.V(3).Info("Using DevFlags from KServe")
                df = ks.GetDevFlags()</span>
        case ms != nil &amp;&amp; ms.ManagementState == operatorv1.Managed &amp;&amp; resources.HasDevFlags(ms):<span class="cov0" title="0">
                l.V(3).Info("Using DevFlags from ModelMesh")
                df = ms.GetDevFlags()</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }

        <span class="cov0" title="0">for _, subcomponent := range df.Manifests </span><span class="cov0" title="0">{
                if !strings.Contains(subcomponent.URI, ComponentName) &amp;&amp; !strings.Contains(subcomponent.URI, LegacyComponentName) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">l.V(3).Info("Downloading manifests", "uri", subcomponent.URI)

                if err := odhdeploy.DownloadManifests(ctx, ComponentName, subcomponent); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If overlay is defined, update paths
                <span class="cov0" title="0">if subcomponent.SourcePath != "" </span><span class="cov0" title="0">{
                        rr.Manifests[0].SourcePath = subcomponent.SourcePath
                }</span>

                <span class="cov0" title="0">break</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package modelcontroller

import (
        "context"

        templatev1 "github.com/openshift/api/template/v1"
        promv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(
                mgr,
                &amp;componentApi.ModelController{},
        ).
                // customized Owns() for Component with new predicates
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;promv1.ServiceMonitor{}).
                Owns(&amp;networkingv1.NetworkPolicy{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;admissionregistrationv1.ValidatingWebhookConfiguration{}).
                Owns(&amp;templatev1.Template{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.ModelControllerInstanceName)),
                        reconciler.WithPredicates(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True)),
                ).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx) // include GenerationChangedPredicate no need set in each Owns() above

        if err != nil </span><span class="cov0" title="0">{
                return err // no need customize error, it is done in the caller main
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package modelcontroller

import (
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ComponentName = componentApi.ModelControllerComponentName

        ReadyConditionType = componentApi.ModelControllerKind + status.ReadySuffix

        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName = "odh-model-controller"
)

var (
        imageParamMap = map[string]string{
                "odh-model-controller": "RELATED_IMAGE_ODH_MODEL_CONTROLLER_IMAGE",
        }

        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

func manifestsPath() types.ManifestInfo <span class="cov0" title="0">{
        return types.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: "base",
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package modelmeshserving

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov4" title="2">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov4" title="2">{
        return componentApi.ModelMeshServingComponentName
}</span>

func (s *componentHandler) Init(_ common.Platform) error <span class="cov0" title="0">{
        // Update image parameters
        if err := odhdeploy.ApplyParams(manifestsPath().String(), "params.env", imageParamMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", manifestsPath(), err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// for DSC to get compoment ModelMeshServing's CR.
func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov4" title="2">{
        return &amp;componentApi.ModelMeshServing{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.ModelMeshServingKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.ModelMeshServingInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.ModelMeshServing.ManagementState),
                        },
                },
                Spec: componentApi.ModelMeshServingSpec{
                        ModelMeshServingCommonSpec: dsc.Spec.Components.ModelMeshServing.ModelMeshServingCommonSpec,
                },
        }
}</span>

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov10" title="8">{
        return dsc.Spec.Components.ModelMeshServing.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov7" title="5">{
        cs := metav1.ConditionUnknown

        c := componentApi.ModelMeshServing{}
        c.Name = componentApi.ModelMeshServingInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov7" title="5">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov7" title="5">ms := components.NormalizeManagementState(dsc.Spec.Components.ModelMeshServing.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentName] = false
        dsc.Status.Components.ModelMeshServing.ManagementState = ms
        dsc.Status.Components.ModelMeshServing.ModelMeshServingCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov5" title="3">{
                dsc.Status.InstalledComponents[LegacyComponentName] = true
                dsc.Status.Components.ModelMeshServing.ModelMeshServingCommonStatus = c.Status.ModelMeshServingCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov5" title="3">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov5" title="3"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov7" title="5">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package modelmeshserving

import (
        "context"
        "fmt"
        "strings"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

func initialize(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        rr.Manifests = append(rr.Manifests, manifestsPath())

        return nil
}</span>

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        mm, ok := rr.Instance.(*componentApi.ModelMeshServing)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.ModelMeshServing)", rr.Instance)
        }</span>

        <span class="cov0" title="0">df := mm.GetDevFlags()
        if df == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(df.Manifests) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Implement devflags support logic
        // If dev flags are set, update default manifests path
        <span class="cov0" title="0">for _, subcomponent := range df.Manifests </span><span class="cov0" title="0">{
                if !strings.Contains(subcomponent.URI, ComponentName) &amp;&amp; !strings.Contains(subcomponent.URI, LegacyComponentName) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Download modelmeshserving
                <span class="cov0" title="0">if err := odhdeploy.DownloadManifests(ctx, ComponentName, subcomponent); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // If overlay is defined, update paths
                <span class="cov0" title="0">if subcomponent.SourcePath != "" </span><span class="cov0" title="0">{
                        rr.Manifests[0].SourcePath = subcomponent.SourcePath
                }</span>

                <span class="cov0" title="0">break</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package modelmeshserving

import (
        "context"

        promv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(
                mgr,
                &amp;componentApi.ModelMeshServing{},
        ).
                // customized Owns() for Component with new predicates
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;promv1.ServiceMonitor{}).
                Owns(&amp;networkingv1.NetworkPolicy{}).
                Owns(&amp;admissionregistrationv1.ValidatingWebhookConfiguration{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.ModelMeshServingInstanceName)),
                        reconciler.WithPredicates(predicate.And(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                                predicate.Funcs{
                                        UpdateFunc: func(event event.UpdateEvent) bool </span><span class="cov0" title="0">{
                                                // The KServe and ModelMesh are shipping the same CRDs as part of their manifests
                                                // but with different versions, this cause the respective component reconcilers to
                                                // keep trying to install their respective version, ending in an infinite loop.
                                                switch event.ObjectNew.GetName() </span>{
                                                case "inferenceservices.serving.kserve.io":<span class="cov0" title="0">
                                                        return false</span>
                                                case "servingruntimes.serving.kserve.io":<span class="cov0" title="0">
                                                        return false</span>
                                                }
                                                <span class="cov0" title="0">return true</span>
                                        },
                                },
                        )),
                ).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(releases.NewAction()).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx) // include GenerationChangedPredicate no need set in each Owns() above

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err // no need customize error, it is done in the caller main
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package modelmeshserving

import (
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ComponentName = componentApi.ModelMeshServingComponentName

        ReadyConditionType = componentApi.ModelMeshServingKind + status.ReadySuffix

        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName = "model-mesh"
)

var (
        imageParamMap = map[string]string{
                "odh-mm-rest-proxy":             "RELATED_IMAGE_ODH_MM_REST_PROXY_IMAGE",
                "odh-modelmesh-runtime-adapter": "RELATED_IMAGE_ODH_MODELMESH_RUNTIME_ADAPTER_IMAGE",
                "odh-modelmesh":                 "RELATED_IMAGE_ODH_MODELMESH_IMAGE",
                "odh-modelmesh-controller":      "RELATED_IMAGE_ODH_MODELMESH_CONTROLLER_IMAGE",
        }

        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

func manifestsPath() odhtypes.ManifestInfo <span class="cov0" title="0">{
        return odhtypes.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: "overlays/odh",
        }
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package modelregistry

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov8" title="1">{
        return componentApi.ModelRegistryComponentName
}</span>

func (s *componentHandler) Init(_ common.Platform) error <span class="cov0" title="0">{
        mi := baseManifestInfo(BaseManifestsSourcePath)

        if err := odhdeploy.ApplyParams(mi.String(), "params.env", imagesMap, extraParamsMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update params on path %s: %w", mi, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov8" title="1">{
        return &amp;componentApi.ModelRegistry{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.ModelRegistryKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.ModelRegistryInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.ModelRegistry.ManagementState),
                        },
                },
                Spec: componentApi.ModelRegistrySpec{
                        ModelRegistryCommonSpec: dsc.Spec.Components.ModelRegistry.ModelRegistryCommonSpec,
                },
        }
}</span>

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov8" title="1">{
        return dsc.Spec.Components.ModelRegistry.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov8" title="1">{
        cs := metav1.ConditionUnknown

        c := componentApi.ModelRegistry{}
        c.Name = componentApi.ModelRegistryInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov8" title="1">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov8" title="1">ms := components.NormalizeManagementState(dsc.Spec.Components.ModelRegistry.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentName] = false
        dsc.Status.Components.ModelRegistry.ManagementState = ms
        dsc.Status.Components.ModelRegistry.ModelRegistryCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov8" title="1">{
                dsc.Status.InstalledComponents[LegacyComponentName] = true
                dsc.Status.Components.ModelRegistry.ModelRegistryCommonStatus = c.Status.ModelRegistryCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov8" title="1">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov8" title="1"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov8" title="1">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package modelregistry

import (
        "context"
        "fmt"

        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/template"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/generation"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(mgr, &amp;componentApi.ModelRegistry{}).
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.Secret{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Owns(&amp;admissionregistrationv1.MutatingWebhookConfiguration{}).
                Owns(&amp;admissionregistrationv1.ValidatingWebhookConfiguration{}).
                // MR also depends on DSCInitialization to properly configure the SMM
                // resource
                Watches(
                        &amp;dsciv1.DSCInitialization{},
                        reconciler.WithEventHandler(handlers.ToNamed(componentApi.ModelRegistryInstanceName)),
                        reconciler.WithPredicates(generation.New()),
                ).
                Watches(&amp;corev1.Namespace{}).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.ModelRegistryInstanceName)),
                        reconciler.WithPredicates(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True)),
                ).
                WithAction(initialize).
                WithAction(customizeManifests).
                WithAction(releases.NewAction()).
                WithAction(configureDependencies).
                WithAction(template.NewAction()).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                WithAction(updateStatus).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create the model registry controller: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package modelregistry

import (
        "context"
        "errors"
        "fmt"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

func initialize(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        mr, ok := rr.Instance.(*componentApi.ModelRegistry)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.ModelRegistry)", rr.Instance)
        }</span>

        <span class="cov0" title="0">rr.Manifests = []odhtypes.ManifestInfo{
                baseManifestInfo(BaseManifestsSourcePath),
                extraManifestInfo(BaseManifestsSourcePath),
        }

        df := mr.GetDevFlags()

        if df == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(df.Manifests) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(df.Manifests) &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected number of manifests found: %d, expected 1)", len(df.Manifests))
        }</span>

        <span class="cov0" title="0">if err := odhdeploy.DownloadManifests(ctx, ComponentName, df.Manifests[0]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if df.Manifests[0].SourcePath != "" </span><span class="cov0" title="0">{
                rr.Manifests = []odhtypes.ManifestInfo{
                        baseManifestInfo(df.Manifests[0].SourcePath),
                        extraManifestInfo(df.Manifests[0].SourcePath),
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func customizeManifests(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        mr, ok := rr.Instance.(*componentApi.ModelRegistry)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.ModelRegistry)", rr.Instance)
        }</span>

        // update registries namespace in manifests
        <span class="cov0" title="0">if err := odhdeploy.ApplyParams(rr.Manifests[0].String(), "params.env", nil, map[string]string{
                "REGISTRIES_NAMESPACE": mr.Spec.RegistriesNamespace,
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update params on path %s: %w", rr.Manifests[0].String(), err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func configureDependencies(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        mr, ok := rr.Instance.(*componentApi.ModelRegistry)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.ModelRegistry)", rr.Instance)
        }</span>

        // Namespace
        <span class="cov0" title="0">if err := rr.AddResources(
                &amp;corev1.Namespace{
                        ObjectMeta: metav1.ObjectMeta{
                                Name: mr.Spec.RegistriesNamespace,
                        },
                },
        ); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add namespace %s to manifests: %w", mr.Spec.RegistriesNamespace, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func updateStatus(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        mr, ok := rr.Instance.(*componentApi.ModelRegistry)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("instance is not of type *odhTypes.ModelRegistry")
        }</span>

        <span class="cov0" title="0">mr.Status.RegistriesNamespace = mr.Spec.RegistriesNamespace

        return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package modelregistry

import (
        "path"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ComponentName = componentApi.ModelRegistryComponentName

        ReadyConditionType = componentApi.ModelRegistryKind + status.ReadySuffix

        DefaultModelRegistriesNamespace = "odh-model-registries"
        DefaultModelRegistryCert        = "default-modelregistry-cert"
        BaseManifestsSourcePath         = "overlays/odh"
        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName = "model-registry-operator"
)

var (
        imagesMap = map[string]string{
                "IMAGES_MODELREGISTRY_OPERATOR": "RELATED_IMAGE_ODH_MODEL_REGISTRY_OPERATOR_IMAGE",
                "IMAGES_GRPC_SERVICE":           "RELATED_IMAGE_ODH_MLMD_GRPC_SERVER_IMAGE",
                "IMAGES_REST_SERVICE":           "RELATED_IMAGE_ODH_MODEL_REGISTRY_IMAGE",
                "IMAGES_OAUTH_PROXY":            "RELATED_IMAGE_OSE_OAUTH_PROXY_IMAGE",
        }

        extraParamsMap = map[string]string{
                "DEFAULT_CERT": DefaultModelRegistryCert,
        }

        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

func baseManifestInfo(sourcePath string) odhtypes.ManifestInfo <span class="cov0" title="0">{
        return odhtypes.ManifestInfo{
                Path:       deploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: sourcePath,
        }
}</span>

func extraManifestInfo(sourcePath string) odhtypes.ManifestInfo <span class="cov0" title="0">{
        return odhtypes.ManifestInfo{
                Path:       deploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: path.Join(sourcePath, "extras"),
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package ray

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov4" title="2">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov4" title="2">{
        return componentApi.RayComponentName
}</span>

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov4" title="2">{
        return &amp;componentApi.Ray{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.RayKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.RayInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.Ray.ManagementState),
                        },
                },
                Spec: componentApi.RaySpec{
                        RayCommonSpec: dsc.Spec.Components.Ray.RayCommonSpec,
                },
        }
}</span>

func (s *componentHandler) Init(_ common.Platform) error <span class="cov0" title="0">{
        if err := odhdeploy.ApplyParams(manifestPath().String(), "params.env", imageParamMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", manifestPath(), err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov10" title="8">{
        return dsc.Spec.Components.Ray.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov7" title="5">{
        cs := metav1.ConditionUnknown

        c := componentApi.Ray{}
        c.Name = componentApi.RayInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov7" title="5">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov7" title="5">ms := components.NormalizeManagementState(dsc.Spec.Components.Ray.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentName] = false
        dsc.Status.Components.Ray.ManagementState = ms
        dsc.Status.Components.Ray.RayCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov5" title="3">{
                dsc.Status.InstalledComponents[LegacyComponentName] = true
                dsc.Status.Components.Ray.RayCommonStatus = c.Status.RayCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov5" title="3">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov5" title="3"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov7" title="5">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package ray

import (
        "context"

        securityv1 "github.com/openshift/api/security/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(mgr, &amp;componentApi.Ray{}).
                // customized Owns() for Component with new predicates
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.Secret{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Owns(&amp;securityv1.SecurityContextConstraints{}).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.RayInstanceName)),
                        reconciler.WithPredicates(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True)),
                ).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(releases.NewAction()).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return err // no need customize error, it is done in the caller main
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package ray

import (
        "context"
        "fmt"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

func initialize(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        rr.Manifests = append(rr.Manifests, manifestPath())

        if err := odhdeploy.ApplyParams(manifestPath().String(), "params.env", nil, map[string]string{"namespace": rr.DSCI.Spec.ApplicationsNamespace}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update params.env from %s : %w", manifestPath(), err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        ray, ok := rr.Instance.(*componentApi.Ray)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Ray)", rr.Instance)
        }</span>

        <span class="cov0" title="0">if ray.Spec.DevFlags == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Implement devflags support logic
        // If dev flags are set, update default manifests path
        <span class="cov0" title="0">if len(ray.Spec.DevFlags.Manifests) != 0 </span><span class="cov0" title="0">{
                manifestConfig := ray.Spec.DevFlags.Manifests[0]
                if err := odhdeploy.DownloadManifests(ctx, ComponentName, manifestConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if manifestConfig.SourcePath != "" </span><span class="cov0" title="0">{
                        rr.Manifests[0].Path = odhdeploy.DefaultManifestPath
                        rr.Manifests[0].ContextDir = ComponentName
                        rr.Manifests[0].SourcePath = manifestConfig.SourcePath
                }</span>
        }
        // TODO: Implement devflags logmode logic
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package ray

import (
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ComponentName = componentApi.RayComponentName

        ReadyConditionType = componentApi.RayKind + status.ReadySuffix

        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName = "ray"
)

var (
        imageParamMap = map[string]string{
                "odh-kuberay-operator-controller-image": "RELATED_IMAGE_ODH_KUBERAY_OPERATOR_CONTROLLER_IMAGE",
        }

        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

func manifestPath() types.ManifestInfo <span class="cov0" title="0">{
        return types.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: "openshift",
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package trainingoperator

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov4" title="2">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov4" title="2">{
        return componentApi.TrainingOperatorComponentName
}</span>

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov4" title="2">{
        return &amp;componentApi.TrainingOperator{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.TrainingOperatorKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.TrainingOperatorInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.TrainingOperator.ManagementState),
                        },
                },
                Spec: componentApi.TrainingOperatorSpec{
                        TrainingOperatorCommonSpec: dsc.Spec.Components.TrainingOperator.TrainingOperatorCommonSpec,
                },
        }
}</span>

func (s *componentHandler) Init(platform common.Platform) error <span class="cov0" title="0">{
        if err := odhdeploy.ApplyParams(manifestPath().String(), "params.env", imageParamMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", manifestPath(), err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov10" title="8">{
        return dsc.Spec.Components.TrainingOperator.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov7" title="5">{
        cs := metav1.ConditionUnknown

        c := componentApi.TrainingOperator{}
        c.Name = componentApi.TrainingOperatorInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov7" title="5">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov7" title="5">ms := components.NormalizeManagementState(dsc.Spec.Components.TrainingOperator.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentName] = false
        dsc.Status.Components.TrainingOperator.ManagementState = ms
        dsc.Status.Components.TrainingOperator.TrainingOperatorCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov5" title="3">{
                dsc.Status.InstalledComponents[LegacyComponentName] = true
                dsc.Status.Components.TrainingOperator.TrainingOperatorCommonStatus = c.Status.TrainingOperatorCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov5" title="3">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov5" title="3"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov7" title="5">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package trainingoperator

import (
        "context"

        promv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(mgr, &amp;componentApi.TrainingOperator{}).
                // customized Owns() for Component with new predicates
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;promv1.PodMonitor{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.TrainingOperatorInstanceName)),
                        reconciler.WithPredicates(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True)),
                ).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(releases.NewAction()).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return err // no need customize error, it is done in the caller main
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package trainingoperator

import (
        "context"
        "fmt"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

func initialize(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        rr.Manifests = append(rr.Manifests, manifestPath())
        return nil
}</span>

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        trainingoperator, ok := rr.Instance.(*componentApi.TrainingOperator)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.TrainingOperator)", rr.Instance)
        }</span>

        <span class="cov0" title="0">if trainingoperator.Spec.DevFlags == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(trainingoperator.Spec.DevFlags.Manifests) != 0 </span><span class="cov0" title="0">{
                manifestConfig := trainingoperator.Spec.DevFlags.Manifests[0]
                if err := odhdeploy.DownloadManifests(ctx, ComponentName, manifestConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if manifestConfig.SourcePath != "" </span><span class="cov0" title="0">{
                        rr.Manifests[0].Path = odhdeploy.DefaultManifestPath
                        rr.Manifests[0].ContextDir = ComponentName
                        rr.Manifests[0].SourcePath = manifestConfig.SourcePath
                }</span>
        }
        // TODO: Implement devflags logmode logic
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package trainingoperator

import (
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ComponentName = componentApi.TrainingOperatorComponentName

        ReadyConditionType = componentApi.TrainingOperatorKind + status.ReadySuffix

        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName = "trainingoperator"
)

var (
        imageParamMap = map[string]string{
                "odh-training-operator-controller-image": "RELATED_IMAGE_ODH_TRAINING_OPERATOR_IMAGE",
        }

        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

func manifestPath() types.ManifestInfo <span class="cov0" title="0">{
        return types.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: "rhoai",
        }
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package trustyai

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov4" title="2">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov4" title="2">{
        return componentApi.TrustyAIComponentName
}</span>

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov4" title="2">{
        return &amp;componentApi.TrustyAI{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.TrustyAIKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.TrustyAIInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.TrustyAI.ManagementState),
                        },
                },
                Spec: componentApi.TrustyAISpec{
                        TrustyAICommonSpec: dsc.Spec.Components.TrustyAI.TrustyAICommonSpec,
                },
        }
}</span>

func (s *componentHandler) Init(platform common.Platform) error <span class="cov0" title="0">{
        mp := manifestsPath(platform)

        if err := odhdeploy.ApplyParams(mp.String(), "params.env", imageParamMap); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update images on path %s: %w", mp, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov10" title="8">{
        return dsc.Spec.Components.TrustyAI.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov7" title="5">{
        cs := metav1.ConditionUnknown

        c := componentApi.TrustyAI{}
        c.Name = componentApi.TrustyAIInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov7" title="5">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov7" title="5">ms := components.NormalizeManagementState(dsc.Spec.Components.TrustyAI.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentName] = false
        dsc.Status.Components.TrustyAI.ManagementState = ms
        dsc.Status.Components.TrustyAI.TrustyAICommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov5" title="3">{
                dsc.Status.InstalledComponents[LegacyComponentName] = true
                dsc.Status.Components.TrustyAI.TrustyAICommonStatus = c.Status.TrustyAICommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov5" title="3">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov5" title="3"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov7" title="5">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package trustyai

import (
        "context"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(mgr, &amp;componentApi.TrustyAI{}).
                // customized Owns() for Component with new predicates
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.TrustyAIInstanceName)),
                        reconciler.WithPredicates(predicate.Or(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True), // if TrustyAI CR is changed
                                predicate.Funcs{ // OR if ISVC from kserve or model-mesh is created
                                        CreateFunc: func(e event.CreateEvent) bool </span><span class="cov0" title="0">{
                                                return e.Object.GetName() == "inferenceservices.serving.kserve.io" &amp;&amp;
                                                        (e.Object.GetLabels()[labels.ODH.Component(componentApi.KserveComponentName)] == labels.True) || (e.Object.GetLabels()[labels.ODH.Component("model-mesh")] == labels.True)
                                        }</span>,
                                },
                        )),
                ).
                WithAction(checkPreConditions).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(releases.NewAction()).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err // no need customize error, it is done in the caller main
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package trustyai

import (
        "context"
        "fmt"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        odherrors "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/errors"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

func checkPreConditions(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        isvc, err := cluster.HasCRD(ctx, rr.Client, gvk.InferenceServices)
        if err != nil </span><span class="cov0" title="0">{
                return odherrors.NewStopError("failed to check %s CRDs version: %w", gvk.InferenceServices, err)
        }</span>

        <span class="cov0" title="0">if !isvc </span><span class="cov0" title="0">{
                return odherrors.NewStopError(status.ISVCMissingCRDMessage)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func initialize(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        rr.Manifests = append(rr.Manifests, manifestsPath(rr.Release.Name))
        return nil
}</span>

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        trustyai, ok := rr.Instance.(*componentApi.TrustyAI)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.TrustyAI)", rr.Instance)
        }</span>

        <span class="cov0" title="0">if trustyai.Spec.DevFlags == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Implement devflags support logic
        // If dev flags are set, update default manifests path
        <span class="cov0" title="0">if len(trustyai.Spec.DevFlags.Manifests) != 0 </span><span class="cov0" title="0">{
                manifestConfig := trustyai.Spec.DevFlags.Manifests[0]
                if err := odhdeploy.DownloadManifests(ctx, ComponentName, manifestConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if manifestConfig.SourcePath != "" </span><span class="cov0" title="0">{
                        rr.Manifests[0].SourcePath = manifestConfig.SourcePath
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package trustyai

import (
        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ComponentName = componentApi.TrustyAIComponentName

        ReadyConditionType = componentApi.TrustyAIKind + status.ReadySuffix

        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName = "trustyai"
)

var (
        imageParamMap = map[string]string{
                "trustyaiServiceImage":               "RELATED_IMAGE_ODH_TRUSTYAI_SERVICE_IMAGE",
                "trustyaiOperatorImage":              "RELATED_IMAGE_ODH_TRUSTYAI_SERVICE_OPERATOR_IMAGE",
                "lmes-driver-image":                  "RELATED_IMAGE_ODH_TA_LMES_DRIVER_IMAGE",
                "lmes-pod-image":                     "RELATED_IMAGE_ODH_TA_LMES_JOB_IMAGE",
                "guardrails-orchestrator-image":      "RELATED_IMAGE_ODH_FMS_GUARDRAILS_ORCHESTRATOR_IMAGE",
                "guardrails-sidecar-gateway-image":   "RELATED_IMAGE_ODH_TRUSTYAI_VLLM_ORCHESTRATOR_GATEWAY_IMAGE",
                "guardrails-built-in-detector-image": "RELATED_IMAGE_ODH_BUILT_IN_DETECTOR_IMAGE",
                "oauthProxyImage":                    "RELATED_IMAGE_OSE_OAUTH_PROXY_IMAGE",
        }

        overlaysSourcePaths = map[common.Platform]string{
                cluster.SelfManagedRhoai: "/overlays/rhoai",
                cluster.ManagedRhoai:     "/overlays/rhoai",
                cluster.OpenDataHub:      "/overlays/odh",
        }

        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

func manifestsPath(p common.Platform) types.ManifestInfo <span class="cov0" title="0">{
        return types.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: ComponentName,
                SourcePath: overlaysSourcePaths[p],
        }
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package workbenches

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

type componentHandler struct{}

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits
        cr.Add(&amp;componentHandler{})
}</span>

func (s *componentHandler) GetName() string <span class="cov8" title="1">{
        return componentApi.WorkbenchesComponentName
}</span>

func (s *componentHandler) NewCRObject(dsc *dscv1.DataScienceCluster) common.PlatformObject <span class="cov8" title="1">{
        return &amp;componentApi.Workbenches{
                TypeMeta: metav1.TypeMeta{
                        Kind:       componentApi.WorkbenchesKind,
                        APIVersion: componentApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: componentApi.WorkbenchesInstanceName,
                        Annotations: map[string]string{
                                annotations.ManagementStateAnnotation: string(dsc.Spec.Components.Workbenches.ManagementState),
                        },
                },
                Spec: componentApi.WorkbenchesSpec{
                        WorkbenchesCommonSpec: dsc.Spec.Components.Workbenches.WorkbenchesCommonSpec,
                },
        }
}</span>

func (s *componentHandler) Init(platform common.Platform) error <span class="cov0" title="0">{
        nbcManifestInfo := notebookControllerManifestInfo(notebookControllerManifestSourcePath)
        if err := odhdeploy.ApplyParams(nbcManifestInfo.String(), "params.env", map[string]string{
                "odh-notebook-controller-image": "RELATED_IMAGE_ODH_NOTEBOOK_CONTROLLER_IMAGE",
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update params.env from %s : %w", nbcManifestInfo.String(), err)
        }</span>

        <span class="cov0" title="0">kfNbcManifestInfo := kfNotebookControllerManifestInfo(kfNotebookControllerManifestSourcePath)
        if err := odhdeploy.ApplyParams(kfNbcManifestInfo.String(), "params.env", map[string]string{
                "odh-kf-notebook-controller-image": "RELATED_IMAGE_ODH_KF_NOTEBOOK_CONTROLLER_IMAGE",
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update params.env from %s : %w", kfNbcManifestInfo.String(), err)
        }</span>

        <span class="cov0" title="0">nbImgsManifestInfo := notebookImagesManifestInfo(notebookImagesParamsPath)
        if err := odhdeploy.ApplyParams(nbImgsManifestInfo.String(), "params-latest.env", map[string]string{
                // CodeServer Workbench Images
                "odh-workbench-codeserver-datascience-cpu-py311-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_CODESERVER_DATASCIENCE_CPU_PY311_IMAGE",
                "odh-workbench-codeserver-datascience-cpu-py312-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_CODESERVER_DATASCIENCE_CPU_PY312_IMAGE",

                // Jupyter Workbench Images - Data Science CPU
                "odh-workbench-jupyter-datascience-cpu-py311-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_DATASCIENCE_CPU_PY311_IMAGE",
                "odh-workbench-jupyter-datascience-cpu-py312-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_DATASCIENCE_CPU_PY312_IMAGE",

                // Jupyter Workbench Images - Minimal CPU
                "odh-workbench-jupyter-minimal-cpu-py311-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_MINIMAL_CPU_PY311_IMAGE",
                "odh-workbench-jupyter-minimal-cpu-py312-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_MINIMAL_CPU_PY312_IMAGE",
                // Jupyter Workbench Images - Minimal CUDA
                "odh-workbench-jupyter-minimal-cuda-py311-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_MINIMAL_CUDA_PY311_IMAGE",
                "odh-workbench-jupyter-minimal-cuda-py312-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_MINIMAL_CUDA_PY312_IMAGE",
                // Jupyter Workbench Images - Minimal ROCm
                "odh-workbench-jupyter-minimal-rocm-py311-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_MINIMAL_ROCM_PY311_IMAGE",
                "odh-workbench-jupyter-minimal-rocm-py312-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_MINIMAL_ROCM_PY312_IMAGE",

                // Jupyter Workbench Images - PyTorch CUDA
                "odh-workbench-jupyter-pytorch-cuda-py311-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_PYTORCH_CUDA_PY311_IMAGE",
                "odh-workbench-jupyter-pytorch-cuda-py312-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_PYTORCH_CUDA_PY312_IMAGE",
                // Jupyter Workbench Images - PyTorch ROCm
                "odh-workbench-jupyter-pytorch-rocm-py311-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_PYTORCH_ROCM_PY311_IMAGE",
                "odh-workbench-jupyter-pytorch-rocm-py312-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_PYTORCH_ROCM_PY312_IMAGE",

                // Jupyter Workbench Images - TensorFlow CUDA
                "odh-workbench-jupyter-tensorflow-cuda-py311-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_TENSORFLOW_CUDA_PY311_IMAGE",
                "odh-workbench-jupyter-tensorflow-cuda-py312-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_TENSORFLOW_CUDA_PY312_IMAGE",
                // Jupyter Workbench Images - TensorFlow ROCm
                "odh-workbench-jupyter-tensorflow-rocm-py311-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_TENSORFLOW_ROCM_PY311_IMAGE",

                // Jupyter Workbench Images - TrustyAI CPU
                "odh-workbench-jupyter-trustyai-cpu-py311-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_TRUSTYAI_CPU_PY311_IMAGE",
                "odh-workbench-jupyter-trustyai-cpu-py312-ubi9-n": "RELATED_IMAGE_ODH_WORKBENCH_JUPYTER_TRUSTYAI_CPU_PY312_IMAGE",

                // Pipeline Runtime Images
                "odh-pipeline-runtime-datascience-cpu-py311-ubi9-n": "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_DATASCIENCE_CPU_PY311_IMAGE",
                "odh-pipeline-runtime-datascience-cpu-py312-ubi9-n": "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_DATASCIENCE_CPU_PY312_IMAGE",
                "odh-pipeline-runtime-minimal-cpu-py311-ubi9-n":     "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_MINIMAL_CPU_PY311_IMAGE",
                "odh-pipeline-runtime-minimal-cpu-py312-ubi9-n":     "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_MINIMAL_CPU_PY312_IMAGE",
                "odh-pipeline-runtime-tensorflow-cuda-py311-ubi9-n": "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_TENSORFLOW_CUDA_PY311_IMAGE",
                "odh-pipeline-runtime-tensorflow-cuda-py312-ubi9-n": "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_TENSORFLOW_CUDA_PY312_IMAGE",
                "odh-pipeline-runtime-tensorflow-rocm-py311-ubi9-n": "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_TENSORFLOW_ROCM_PY311_IMAGE",
                // Pipeline Runtime Images - PyTorch CUDA
                "odh-pipeline-runtime-pytorch-cuda-py311-ubi9-n": "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_PYTORCH_CUDA_PY311_IMAGE",
                "odh-pipeline-runtime-pytorch-cuda-py312-ubi9-n": "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_PYTORCH_CUDA_PY312_IMAGE",
                // Pipeline Runtime Images - PyTorch ROCm
                "odh-pipeline-runtime-pytorch-rocm-py311-ubi9-n": "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_PYTORCH_ROCM_PY311_IMAGE",
                "odh-pipeline-runtime-pytorch-rocm-py312-ubi9-n": "RELATED_IMAGE_ODH_PIPELINE_RUNTIME_PYTORCH_ROCM_PY312_IMAGE",
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update params-latest.env from %s : %w", nbImgsManifestInfo.String(), err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *componentHandler) IsEnabled(dsc *dscv1.DataScienceCluster) bool <span class="cov8" title="1">{
        return dsc.Spec.Components.Workbenches.ManagementState == operatorv1.Managed
}</span>

func (s *componentHandler) UpdateDSCStatus(ctx context.Context, rr *types.ReconciliationRequest) (metav1.ConditionStatus, error) <span class="cov8" title="1">{
        cs := metav1.ConditionUnknown

        c := componentApi.Workbenches{}
        c.Name = componentApi.WorkbenchesInstanceName

        if err := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;c), &amp;c); err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return cs, nil
        }</span>

        <span class="cov8" title="1">dsc, ok := rr.Instance.(*dscv1.DataScienceCluster)
        if !ok </span><span class="cov0" title="0">{
                return cs, errors.New("failed to convert to DataScienceCluster")
        }</span>

        <span class="cov8" title="1">ms := components.NormalizeManagementState(dsc.Spec.Components.Workbenches.ManagementState)

        dsc.Status.InstalledComponents[LegacyComponentName] = false
        dsc.Status.Components.Workbenches.ManagementState = ms
        dsc.Status.Components.Workbenches.WorkbenchesCommonStatus = nil

        rr.Conditions.MarkFalse(ReadyConditionType)

        if s.IsEnabled(dsc) </span><span class="cov8" title="1">{
                dsc.Status.InstalledComponents[LegacyComponentName] = true
                dsc.Status.Components.Workbenches.WorkbenchesCommonStatus = c.Status.WorkbenchesCommonStatus.DeepCopy()

                if rc := conditions.FindStatusCondition(c.GetStatus(), status.ConditionTypeReady); rc != nil </span><span class="cov8" title="1">{
                        rr.Conditions.MarkFrom(ReadyConditionType, *rc)
                        cs = rc.Status
                }</span> else<span class="cov0" title="0"> {
                        cs = metav1.ConditionFalse
                }</span>
        } else<span class="cov8" title="1"> {
                rr.Conditions.MarkFalse(
                        ReadyConditionType,
                        conditions.WithReason(string(ms)),
                        conditions.WithMessage("Component ManagementState is set to %s", string(ms)),
                        conditions.WithSeverity(common.ConditionSeverityInfo),
                )
        }</span>

        <span class="cov8" title="1">return cs, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package workbenches

import (
        "context"
        "path"

        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/releases"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

// NewComponentReconciler creates a ComponentReconciler for the Workbenches API.
func (s *componentHandler) NewComponentReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(mgr, &amp;componentApi.Workbenches{}).
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;corev1.Secret{}).
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                Owns(&amp;corev1.ServiceAccount{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;admissionregistrationv1.MutatingWebhookConfiguration{}).
                Owns(&amp;appsv1.Deployment{}, reconciler.WithPredicates(resources.NewDeploymentPredicate())).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(componentApi.WorkbenchesInstanceName)),
                        reconciler.WithPredicates(
                                component.ForLabel(labels.ODH.Component(LegacyComponentName), labels.True)),
                ).
                Watches(&amp;corev1.Namespace{}).
                WithAction(initialize).
                WithAction(devFlags).
                WithAction(releases.NewAction(
                        releases.WithMetadataFilePath(
                                path.Join(odhdeploy.DefaultManifestPath, ComponentName, kfNotebookControllerPath, releases.ComponentMetadataFilename)))).
                WithAction(configureDependencies).
                WithAction(kustomize.NewAction(
                        kustomize.WithLabel(labels.ODH.Component(LegacyComponentName), labels.True),
                        kustomize.WithLabel(labels.K8SCommon.PartOf, LegacyComponentName),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(deployments.NewAction()).
                WithAction(updateStatus).
                // must be the final action
                WithAction(gc.NewAction()).
                // declares the list of additional, controller specific conditions that are
                // contributing to the controller readiness status
                WithConditions(conditionTypes...).
                Build(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package workbenches

import (
        "context"
        "fmt"
        "strings"

        corev1 "k8s.io/api/core/v1"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

func initialize(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        rr.Manifests = []odhtypes.ManifestInfo{
                notebookControllerManifestInfo(notebookControllerManifestSourcePath),
                kfNotebookControllerManifestInfo(kfNotebookControllerManifestSourcePath),
                notebookImagesManifestInfo(notebookImagesManifestSourcePath),
        }

        return nil
}</span>

func devFlags(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        workbenches, ok := rr.Instance.(*componentApi.Workbenches)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Workbenches)", rr.Instance)
        }</span>

        <span class="cov0" title="0">if workbenches.Spec.DevFlags == nil || len(workbenches.Spec.DevFlags.Manifests) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Download manifests if defined by devflags
        // Go through each manifest and set the overlays if defined
        // first on odh-notebook-controller and kf-notebook-controller last to notebook-images
        <span class="cov0" title="0">nbcSourcePath := notebookControllerManifestSourcePath
        kfNbcSourcePath := kfNotebookControllerManifestSourcePath
        nbImgsSourcePath := notebookImagesManifestSourcePath

        for _, subcomponent := range workbenches.Spec.DevFlags.Manifests </span><span class="cov0" title="0">{
                if strings.Contains(subcomponent.ContextDir, "components/odh-notebook-controller") </span><span class="cov0" title="0">{
                        // Download subcomponent
                        if err := odhdeploy.DownloadManifests(ctx, notebookControllerContextDir, subcomponent); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // If overlay is defined, update paths
                        <span class="cov0" title="0">if subcomponent.SourcePath != "" </span><span class="cov0" title="0">{
                                nbcSourcePath = subcomponent.SourcePath
                        }</span>
                }

                <span class="cov0" title="0">if strings.Contains(subcomponent.ContextDir, "components/notebook-controller") </span><span class="cov0" title="0">{
                        // Download subcomponent
                        if err := odhdeploy.DownloadManifests(ctx, kfNotebookControllerContextDir, subcomponent); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // If overlay is defined, update paths
                        <span class="cov0" title="0">if subcomponent.SourcePath != "" </span><span class="cov0" title="0">{
                                kfNbcSourcePath = subcomponent.SourcePath
                        }</span>
                }

                <span class="cov0" title="0">if strings.Contains(subcomponent.URI, notebooksPath) </span><span class="cov0" title="0">{
                        // Download subcomponent
                        if err := odhdeploy.DownloadManifests(ctx, notebookContextDir, subcomponent); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // If overlay is defined, update paths
                        <span class="cov0" title="0">if subcomponent.SourcePath != "" </span><span class="cov0" title="0">{
                                nbImgsSourcePath = subcomponent.SourcePath
                        }</span>
                }
        }

        <span class="cov0" title="0">rr.Manifests = []odhtypes.ManifestInfo{
                notebookControllerManifestInfo(nbcSourcePath),
                kfNotebookControllerManifestInfo(kfNbcSourcePath),
                notebookImagesManifestInfo(nbImgsSourcePath),
        }

        return nil</span>
}

func configureDependencies(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        workbench, ok := rr.Instance.(*componentApi.Workbenches)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Workbenches", rr.Instance)
        }</span>

        <span class="cov0" title="0">wbNS := &amp;corev1.Namespace{}
        wbNS.Labels = map[string]string{
                labels.ODH.OwnedNamespace: "true",
        }

        if workbench.Spec.WorkbenchNamespace != "" || len(workbench.Spec.WorkbenchNamespace) &gt; 0 </span><span class="cov0" title="0">{
                wbNS.Name = workbench.Spec.WorkbenchNamespace
        }</span> else<span class="cov0" title="0"> {
                switch rr.Release.Name </span>{
                case cluster.SelfManagedRhoai, cluster.ManagedRhoai:<span class="cov0" title="0">
                        wbNS.Name = cluster.DefaultNotebooksNamespaceRHOAI</span>
                case cluster.OpenDataHub:<span class="cov0" title="0">
                        wbNS.Name = cluster.DefaultNotebooksNamespaceODH</span>
                }
        }

        <span class="cov0" title="0">err := rr.AddResources(wbNS)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create namespace for workbenches: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func updateStatus(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        workbench, ok := rr.Instance.(*componentApi.Workbenches)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a componentApi.Workbenches", rr.Instance)
        }</span>
        <span class="cov0" title="0">workbench.Status.WorkbenchNamespace = workbench.Spec.WorkbenchNamespace

        return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package workbenches

import (
        "path"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ComponentName = componentApi.WorkbenchesComponentName

        ReadyConditionType = componentApi.WorkbenchesKind + status.ReadySuffix

        notebooksPath                    = "notebooks"
        notebookImagesManifestSourcePath = "overlays/additional"
        notebookImagesParamsPath         = "base"

        notebookControllerPath               = "odh-notebook-controller"
        notebookControllerManifestSourcePath = "base"

        kfNotebookControllerPath               = "kf-notebook-controller"
        kfNotebookControllerManifestSourcePath = "overlays/openshift"

        // LegacyComponentName is the name of the component that is assigned to deployments
        // via Kustomize. Since a deployment selector is immutable, we can't upgrade existing
        // deployment to the new component name, so keep it around till we figure out a solution.
        LegacyComponentName = "workbenches"
)

var (
        notebookControllerContextDir   = path.Join(ComponentName, notebookControllerPath)
        kfNotebookControllerContextDir = path.Join(ComponentName, kfNotebookControllerPath)
        notebookContextDir             = path.Join(ComponentName, notebooksPath)
)

var (
        conditionTypes = []string{
                status.ConditionDeploymentsAvailable,
        }
)

// manifests for nbc in ODH and RHOAI + downstream use it for imageparams.
func notebookControllerManifestInfo(sourcePath string) odhtypes.ManifestInfo <span class="cov0" title="0">{
        return odhtypes.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: notebookControllerContextDir,
                SourcePath: sourcePath,
        }
}</span>

// manifests for ODH nbc + downstream use it for imageparams.
func kfNotebookControllerManifestInfo(sourcePath string) odhtypes.ManifestInfo <span class="cov0" title="0">{
        return odhtypes.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: kfNotebookControllerContextDir,
                SourcePath: sourcePath,
        }
}</span>

// notebook image manifests.
func notebookImagesManifestInfo(sourcePath string) odhtypes.ManifestInfo <span class="cov0" title="0">{
        return odhtypes.ManifestInfo{
                Path:       odhdeploy.DefaultManifestPath,
                ContextDir: notebookContextDir,
                SourcePath: sourcePath,
        }
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package dscinitialization

import (
        "context"

        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
)

var (
        // adminGroups maps each supported platform to its default admin group name.
        // These groups are assigned administrative privileges in the Auth custom resource.
        //
        // Platform mappings:
        //   - SelfManagedRhoai: "rhods-admins" - for self-managed Red Hat OpenShift AI
        //   - ManagedRhoai: "dedicated-admins" - for managed/hosted Red Hat OpenShift AI
        //   - OpenDataHub: "odh-admins" - for Open Data Hub deployments
        //
        // The admin group members have full administrative access to the platform,
        // including the ability to manage users, configure components, and access
        // all platform resources.
        adminGroups = map[common.Platform]string{
                cluster.SelfManagedRhoai: "rhods-admins",
                cluster.ManagedRhoai:     "dedicated-admins",
                cluster.OpenDataHub:      "odh-admins",
        }
)

// CreateAuth ensures an Auth custom resource exists in the cluster.
//
// Parameters:
//   - ctx: Context for the operation
//   - platform: The target platform type used to determine admin group configuration
//
// Returns:
//   - error: nil on success, error if Auth CR creation fails
func (r *DSCInitializationReconciler) CreateAuth(ctx context.Context, platform common.Platform) error <span class="cov8" title="1">{
        a := serviceApi.Auth{}
        // Auth CR exists, we do nothing
        err := r.Client.Get(ctx, client.ObjectKey{Name: serviceApi.AuthInstanceName}, &amp;a)
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        // Auth CR not found, create default Auth CR
        <span class="cov8" title="1">if err := r.Client.Create(ctx, BuildDefaultAuth(platform)); err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BuildDefaultAuth creates a default Auth custom resource with platform-specific configuration.
//
// Parameters:
//   - platform: The target platform type (OpenDataHub, SelfManagedRhoai, or ManagedRhoai)
//
// Returns:
//   - client.Object: A serviceApi.Auth resource with platform-specific admin group and system:authenticated in allowed groups
func BuildDefaultAuth(platform common.Platform) client.Object <span class="cov8" title="1">{
        // Get admin group for the platform, with fallback to OpenDataHub admin group
        adminGroup := adminGroups[platform]
        if adminGroup == "" </span><span class="cov8" title="1">{
                adminGroup = adminGroups[cluster.OpenDataHub]
        }</span>

        <span class="cov8" title="1">return &amp;serviceApi.Auth{
                TypeMeta:   metav1.TypeMeta{Kind: serviceApi.AuthKind, APIVersion: serviceApi.GroupVersion.String()},
                ObjectMeta: metav1.ObjectMeta{Name: serviceApi.AuthInstanceName},
                Spec: serviceApi.AuthSpec{
                        AdminGroups:   []string{adminGroup},
                        AllowedGroups: []string{"system:authenticated"},
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package dscinitialization contains controller logic of CRD DSCInitialization.
package dscinitialization

import (
        "context"
        "path/filepath"

        operatorv1 "github.com/openshift/api/operator/v1"
        routev1 "github.com/openshift/api/route/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        "k8s.io/client-go/util/retry"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        rp "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/logger"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/upgrade"
)

const (
        finalizerName = "dscinitialization.opendatahub.io/finalizer"
        fieldManager  = "dscinitialization.opendatahub.io"
)

// DSCInitializationReconciler reconciles a DSCInitialization object.
type DSCInitializationReconciler struct {
        Client   client.Client
        Scheme   *runtime.Scheme
        Recorder record.EventRecorder
}

// Reconcile contains controller logic specific to DSCInitialization instance updates.
func (r *DSCInitializationReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{ //nolint:funlen,gocyclo,maintidx
        log := logf.FromContext(ctx).WithName("DSCInitialization")
        log.Info("Reconciling DSCInitialization.", "DSCInitialization Request.Name", req.Name)

        currentOperatorRelease := cluster.GetRelease()
        // Set platform
        platform := currentOperatorRelease.Name

        instance, err := cluster.GetDSCI(ctx, r.Client)
        switch </span>{
        case k8serr.IsNotFound(err):<span class="cov8" title="1">
                return ctrl.Result{}, nil</span>
        case err != nil:<span class="cov0" title="0">
                log.Error(err, "Failed to retrieve DSCInitialization resource.", "DSCInitialization Request.Name", req.Name)

                ref := &amp;corev1.ObjectReference{Name: req.Name, Namespace: req.Namespace}
                ref.SetGroupVersionKind(gvk.DSCInitialization)

                r.Recorder.Eventf(ref, corev1.EventTypeWarning, "DSCInitializationReconcileError", "Failed to retrieve DSCInitialization instance")

                return ctrl.Result{}, err</span>
        }

        <span class="cov8" title="1">if instance.Spec.DevFlags != nil </span><span class="cov0" title="0">{
                level := instance.Spec.DevFlags.LogLevel
                log.V(1).Info("Setting log level", "level", level)
                if err := logger.SetLevel(level); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Failed to set log level", "level", level)
                }</span>
        }

        <span class="cov8" title="1">if instance.DeletionTimestamp.IsZero() </span><span class="cov8" title="1">{
                if !controllerutil.ContainsFinalizer(instance, finalizerName) </span><span class="cov8" title="1">{
                        log.Info("Adding finalizer for DSCInitialization", "name", instance.Name, "finalizer", finalizerName)
                        controllerutil.AddFinalizer(instance, finalizerName)
                        if err := r.Client.Update(ctx, instance); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                log.Info("Finalization DSCInitialization start deleting instance", "name", instance.Name, "finalizer", finalizerName)

                err := retry.RetryOnConflict(retry.DefaultRetry, func() error </span><span class="cov8" title="1">{
                        newInstance := &amp;dsciv1.DSCInitialization{}
                        if err := r.Client.Get(ctx, client.ObjectKeyFromObject(instance), newInstance); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if controllerutil.ContainsFinalizer(newInstance, finalizerName) </span><span class="cov8" title="1">{
                                controllerutil.RemoveFinalizer(newInstance, finalizerName)
                                if err := r.Client.Update(ctx, newInstance); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Failed to remove finalizer when deleting DSCInitialization instance")
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }

        // Start reconciling
        <span class="cov8" title="1">if instance.Status.Conditions == nil </span><span class="cov8" title="1">{
                reason := status.ReconcileInit
                message := "Initializing DSCInitialization resource"
                instance, err := status.UpdateWithRetry(ctx, r.Client, instance, func(saved *dsciv1.DSCInitialization) </span><span class="cov8" title="1">{
                        status.SetProgressingCondition(&amp;saved.Status.Conditions, reason, message)
                        saved.Status.Phase = status.PhaseProgressing
                        saved.Status.Release = currentOperatorRelease
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Failed to add conditions to status of DSCInitialization resource.", "DSCInitialization", req.Namespace, "Request.Name", req.Name)
                        r.Recorder.Eventf(instance, corev1.EventTypeWarning, "DSCInitializationReconcileError",
                                "%s for instance %s", message, instance.Name)

                        return reconcile.Result{}, err
                }</span>
        }

        // upgrade case to update release version in status
        <span class="cov8" title="1">if !instance.Status.Release.Version.Equals(currentOperatorRelease.Version.Version) </span><span class="cov0" title="0">{
                message := "Updating DSCInitialization status"
                instance, err := status.UpdateWithRetry(ctx, r.Client, instance, func(saved *dsciv1.DSCInitialization) </span><span class="cov0" title="0">{
                        saved.Status.Release = currentOperatorRelease
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Failed to update release version for DSCInitialization resource.", "DSCInitialization", req.Namespace, "Request.Name", req.Name)
                        r.Recorder.Eventf(instance, corev1.EventTypeWarning, "DSCInitializationReconcileError",
                                "%s for instance %s", message, instance.Name)
                        return reconcile.Result{}, err
                }</span>
        }

        // Deal with application namespace, configmap, networpolicy etc
        <span class="cov8" title="1">if err := r.createOperatorResource(ctx, instance, platform); err != nil </span><span class="cov0" title="0">{
                if _, err := status.UpdateWithRetry(ctx, r.Client, instance, func(saved *dsciv1.DSCInitialization) </span><span class="cov0" title="0">{
                        status.SetProgressingCondition(&amp;saved.Status.Conditions, status.ReconcileFailed, err.Error())
                        saved.Status.Phase = status.PhaseError
                }</span>); err != nil <span class="cov0" title="0">{
                        log.Error(err, "Failed to update DSCInitialization conditions", "DSCInitialization", req.Namespace, "Request.Name", req.Name)

                        r.Recorder.Eventf(instance, corev1.EventTypeWarning, "DSCInitializationReconcileError",
                                "%s for instance %s", err.Error(), instance.Name)
                }</span>

                // no need to log error as it was already logged in createOperatorResource
                <span class="cov0" title="0">r.Recorder.Eventf(instance, corev1.EventTypeWarning, "DSCInitializationReconcileError",
                        "failed to create operator resources for instance %s: %s", instance.Name, err.Error())

                return reconcile.Result{}, err</span>
        }

        <span class="cov8" title="1">switch req.Name </span>{
        case "prometheus":<span class="cov0" title="0"> // prometheus configmap
                if instance.Spec.Monitoring.ManagementState == operatorv1.Managed &amp;&amp; platform == cluster.ManagedRhoai </span><span class="cov0" title="0">{
                        log.Info("Monitoring enabled to restart deployment", "cluster", "Managed Service Mode")
                        if err := r.configureManagedMonitoring(ctx, instance, "updates"); err != nil </span><span class="cov0" title="0">{
                                return reconcile.Result{}, err
                        }</span>
                }

                <span class="cov0" title="0">return ctrl.Result{}, nil</span>
        case "addon-managed-odh-parameters":<span class="cov0" title="0">
                if instance.Spec.Monitoring.ManagementState == operatorv1.Managed &amp;&amp; platform == cluster.ManagedRhoai </span><span class="cov0" title="0">{
                        log.Info("Monitoring enabled when notification updated", "cluster", "Managed Service Mode")
                        if err := r.configureManagedMonitoring(ctx, instance, "updates"); err != nil </span><span class="cov0" title="0">{
                                return reconcile.Result{}, err
                        }</span>
                }

                <span class="cov0" title="0">return ctrl.Result{}, nil</span>
        case "backup":<span class="cov0" title="0"> // revert back to the original prometheus.yml
                if instance.Spec.Monitoring.ManagementState == operatorv1.Managed &amp;&amp; platform == cluster.ManagedRhoai </span><span class="cov0" title="0">{
                        log.Info("Monitoring enabled to restore back", "cluster", "Managed Service Mode")
                        if err := r.configureManagedMonitoring(ctx, instance, "revertbackup"); err != nil </span><span class="cov0" title="0">{
                                return reconcile.Result{}, err
                        }</span>
                }

                <span class="cov0" title="0">return ctrl.Result{}, nil</span>
        default:<span class="cov8" title="1">
                switch platform </span>{
                case cluster.SelfManagedRhoai:<span class="cov0" title="0">
                        if instance.Spec.Monitoring.ManagementState == operatorv1.Managed </span><span class="cov0" title="0">{
                                log.Info("Monitoring enabled", "cluster", "Self-Managed Mode")
                                if err = r.configureSegmentIO(ctx, instance); err != nil </span><span class="cov0" title="0">{
                                        return reconcile.Result{}, err
                                }</span>

                                <span class="cov0" title="0">if err = r.newMonitoringCR(ctx, instance); err != nil </span><span class="cov0" title="0">{
                                        return ctrl.Result{}, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                log.Info("Monitoring disabled", "cluster", "Self-Managed Mode")
                                if err := r.deleteMonitoringCR(ctx); err != nil </span><span class="cov0" title="0">{
                                        return reconcile.Result{}, err
                                }</span>
                        }
                case cluster.ManagedRhoai:<span class="cov0" title="0">
                        osdConfigsPath := filepath.Join(deploy.DefaultManifestPath, "osd-configs")
                        if err = deploy.DeployManifestsFromPath(ctx, r.Client, instance, osdConfigsPath, instance.Spec.ApplicationsNamespace, "osd", true); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "Failed to apply osd specific configs from manifests", "Manifests path", osdConfigsPath)
                                r.Recorder.Eventf(instance, corev1.EventTypeWarning, "DSCInitializationReconcileError", "Failed to apply "+osdConfigsPath)

                                return reconcile.Result{}, err
                        }</span>
                        // TODO: till we allow user to disable Monitoring in Managed cluster
                        <span class="cov0" title="0">log.Info("Monitoring enabled in initialization stage", "cluster", "Managed Service Mode")
                        if err = r.newMonitoringCR(ctx, instance); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">if err = r.configureManagedMonitoring(ctx, instance, "init"); err != nil </span><span class="cov0" title="0">{
                                return reconcile.Result{}, err
                        }</span>
                        <span class="cov0" title="0">if err = r.configureCommonMonitoring(ctx, instance); err != nil </span><span class="cov0" title="0">{
                                return reconcile.Result{}, err
                        }</span>
                default:<span class="cov8" title="1"> // TODO: see if this can be conbimed with self-managed case
                        if instance.Spec.Monitoring.ManagementState == operatorv1.Managed </span><span class="cov8" title="1">{
                                log.Info("Monitoring enabled", "cluster", "ODH Mode")
                                if err = r.newMonitoringCR(ctx, instance); err != nil </span><span class="cov0" title="0">{
                                        return ctrl.Result{}, err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                log.Info("Monitoring disabled", "cluster", "ODH Mode")
                                if err := r.deleteMonitoringCR(ctx); err != nil </span><span class="cov0" title="0">{
                                        return reconcile.Result{}, err
                                }</span>
                        }
                }

                // Create Auth
                <span class="cov8" title="1">if err = r.CreateAuth(ctx, platform); err != nil </span><span class="cov0" title="0">{
                        log.Info("failed to create Auth")
                        return ctrl.Result{}, err
                }</span>

                // Finish reconciling
                <span class="cov8" title="1">_, err = status.UpdateWithRetry(ctx, r.Client, instance, func(saved *dsciv1.DSCInitialization) </span><span class="cov8" title="1">{
                        status.SetCompleteCondition(&amp;saved.Status.Conditions, status.ReconcileCompleted, status.ReconcileCompletedMessage)
                        saved.Status.Phase = status.PhaseReady
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update DSCInitialization status after successfully completed reconciliation")
                        r.Recorder.Eventf(instance, corev1.EventTypeWarning, "DSCInitializationReconcileError", "Failed to update DSCInitialization status")
                }</span>

                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }
}

// SetupWithManager sets up the controller with the Manager.
func (r *DSCInitializationReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                // add predicates prevents meaningless reconciliations from being triggered
                // not use WithEventFilter() because it conflict with secret and configmap predicate
                For(
                        &amp;dsciv1.DSCInitialization{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{})),
                ).
                Owns(
                        &amp;corev1.Namespace{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;corev1.Secret{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;corev1.ConfigMap{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;networkingv1.NetworkPolicy{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;rbacv1.Role{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;rbacv1.RoleBinding{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;rbacv1.ClusterRole{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;rbacv1.ClusterRoleBinding{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;appsv1.Deployment{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;corev1.ServiceAccount{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;corev1.Service{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(
                        &amp;routev1.Route{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Owns(&amp;corev1.PersistentVolumeClaim{},
                        builder.WithPredicates(predicate.Or(predicate.GenerationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
                Watches(
                        &amp;dscv1.DataScienceCluster{},
                        handler.EnqueueRequestsFromMapFunc(func(ctx context.Context, a client.Object) []reconcile.Request </span><span class="cov0" title="0">{
                                return r.watchDSCResource(ctx)
                        }</span>),
                        builder.WithPredicates(rp.DSCDeletionPredicate), // TODO: is it needed?
                ).
                Watches(
                        &amp;corev1.Secret{},
                        handler.EnqueueRequestsFromMapFunc(r.watchMonitoringSecretResource),
                        builder.WithPredicates(rp.SecretContentChangedPredicate),
                ).
                Watches(
                        &amp;corev1.ConfigMap{},
                        handler.EnqueueRequestsFromMapFunc(r.watchMonitoringConfigMapResource),
                        builder.WithPredicates(rp.CMContentChangedPredicate),
                ).
                Watches(
                        &amp;serviceApi.Auth{},
                        handler.EnqueueRequestsFromMapFunc(r.watchAuthResource),
                ).
                Complete(r)
}

func (r *DSCInitializationReconciler) watchMonitoringConfigMapResource(ctx context.Context, a client.Object) []reconcile.Request <span class="cov8" title="1">{
        log := logf.FromContext(ctx)
        if a.GetName() == "prometheus" &amp;&amp; a.GetNamespace() == "redhat-ods-monitoring" </span><span class="cov0" title="0">{
                log.Info("Found monitoring configmap has updated, start reconcile")

                return []reconcile.Request{{NamespacedName: types.NamespacedName{Name: "prometheus", Namespace: "redhat-ods-monitoring"}}}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *DSCInitializationReconciler) watchMonitoringSecretResource(ctx context.Context, a client.Object) []reconcile.Request <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        operatorNs, err := cluster.GetOperatorNamespace()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if a.GetName() == "addon-managed-odh-parameters" &amp;&amp; a.GetNamespace() == operatorNs </span><span class="cov0" title="0">{
                log.Info("Found monitoring secret has updated, start reconcile")

                return []reconcile.Request{{NamespacedName: types.NamespacedName{Name: "addon-managed-odh-parameters", Namespace: operatorNs}}}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *DSCInitializationReconciler) watchDSCResource(ctx context.Context) []reconcile.Request <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        instanceList := &amp;dscv1.DataScienceClusterList{}
        if err := r.Client.List(ctx, instanceList); err != nil </span><span class="cov0" title="0">{
                // do not handle if cannot get list
                log.Error(err, "Failed to get DataScienceClusterList")
                return nil
        }</span>
        <span class="cov0" title="0">if len(instanceList.Items) == 0 &amp;&amp; !upgrade.HasDeleteConfigMap(ctx, r.Client) </span><span class="cov0" title="0">{
                log.Info("Found no DSC instance in cluster but not in uninstalltion process, reset monitoring stack config")

                return []reconcile.Request{{NamespacedName: types.NamespacedName{Name: "backup"}}}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *DSCInitializationReconciler) watchAuthResource(ctx context.Context, a client.Object) []reconcile.Request <span class="cov8" title="1">{
        log := logf.FromContext(ctx)
        instanceList := &amp;serviceApi.AuthList{}
        if err := r.Client.List(ctx, instanceList); err != nil </span><span class="cov0" title="0">{
                // do not handle if cannot get list
                log.Error(err, "Failed to get AuthList")
                return nil
        }</span>
        <span class="cov8" title="1">if len(instanceList.Items) == 0 </span><span class="cov0" title="0">{
                log.Info("Found no Auth instance in cluster, reconciling to recreate")

                return []reconcile.Request{{NamespacedName: types.NamespacedName{Name: "auth"}}}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *DSCInitializationReconciler) deleteMonitoringCR(ctx context.Context) error <span class="cov8" title="1">{
        defaultMonitoring := &amp;serviceApi.Monitoring{
                ObjectMeta: metav1.ObjectMeta{
                        Name: serviceApi.MonitoringInstanceName,
                },
        }
        err := r.Client.Delete(ctx, defaultMonitoring)
        if err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *DSCInitializationReconciler) newMonitoringCR(ctx context.Context, dsci *dsciv1.DSCInitialization) error <span class="cov8" title="1">{
        // Create Monitoring CR singleton
        defaultMonitoring := &amp;serviceApi.Monitoring{
                TypeMeta: metav1.TypeMeta{
                        Kind:       serviceApi.MonitoringKind,
                        APIVersion: serviceApi.GroupVersion.String(),
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: serviceApi.MonitoringInstanceName,
                },
                Spec: serviceApi.MonitoringSpec{
                        MonitoringCommonSpec: serviceApi.MonitoringCommonSpec{
                                Namespace: dsci.Spec.Monitoring.Namespace,
                        },
                },
        }

        if dsci.Spec.Monitoring.Metrics != nil </span><span class="cov0" title="0">{
                // when metrics has values set in resoures or storage. skip replicas since it cannot be 0 from CEL validation
                if dsci.Spec.Monitoring.Metrics.Storage != nil || dsci.Spec.Monitoring.Metrics.Resources != nil </span><span class="cov0" title="0">{
                        defaultMonitoring.Spec.Metrics = dsci.Spec.Monitoring.Metrics
                }</span> else<span class="cov0" title="0"> { // if metrics is set to metrics:{} to avoid  invalid value "null" to Apply() existing Monitoring CR
                        defaultMonitoring.Spec.Metrics = nil // explictliy set to nil, same as not set but for better readability
                }</span>
        }

        <span class="cov8" title="1">defaultMonitoring.Spec.Traces = dsci.Spec.Monitoring.Traces
        defaultMonitoring.Spec.Alerting = dsci.Spec.Monitoring.Alerting

        if err := controllerutil.SetOwnerReference(dsci, defaultMonitoring, r.Client.Scheme()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err := resources.Apply(
                ctx,
                r.Client,
                defaultMonitoring,
                client.FieldOwner(fieldManager),
                client.ForceOwnership,
        )

        if err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package dscinitialization

import (
        "context"
        b64 "encoding/base64"
        "fmt"
        "path/filepath"
        "strings"

        operatorv1 "github.com/openshift/api/operator/v1"
        routev1 "github.com/openshift/api/route/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/common"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

var (
        ComponentName           = "monitoring"
        alertManagerPath        = filepath.Join(deploy.DefaultManifestPath, ComponentName, "alertmanager")
        prometheusManifestsPath = filepath.Join(deploy.DefaultManifestPath, ComponentName, "prometheus", "base")
        prometheusConfigPath    = filepath.Join(deploy.DefaultManifestPath, ComponentName, "prometheus", "apps")
        networkpolicyPath       = filepath.Join(deploy.DefaultManifestPath, ComponentName, "networkpolicy")
)

// only when reconcile on DSCI CR, initial set to true
// if reconcile from monitoring, initial set to false, skip blackbox and rolebinding.
func (r *DSCInitializationReconciler) configureManagedMonitoring(ctx context.Context, dscInit *dsciv1.DSCInitialization, initial string) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        if initial == "init" </span><span class="cov0" title="0">{
                // configure Blackbox exporter
                if err := configureBlackboxExporter(ctx, dscInit, r); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error in configureBlackboxExporter: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if initial == "revertbackup" </span><span class="cov0" title="0">{
                // TODO: implement with a better solution
                // to have - before component name is to filter out the real rules file line
                // e.g line of "workbenches-recording.rules: |"
                err := common.MatchLineInFile(filepath.Join(prometheusConfigPath, "prometheus-configs.yaml"),
                        map[string]string{
                                "(.*)-(.*)workbenches(.*).rules":                     "",
                                "(.*)-(.*)rhods-dashboard(.*).rules":                 "",
                                "(.*)-(.*)codeflare(.*).rules":                       "",
                                "(.*)-(.*)data-science-pipelines-operator(.*).rules": "",
                                "(.*)-(.*)model-mesh(.*).rules":                      "",
                                "(.*)-(.*)odh-model-controller(.*).rules":            "",
                                "(.*)-(.*)ray(.*).rules":                             "",
                                "(.*)-(.*)trustyai(.*).rules":                        "",
                                "(.*)-(.*)kueue(.*).rules":                           "",
                                "(.*)-(.*)trainingoperator(.*).rules":                "",
                        })
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error to remove previous enabled component rules")
                        return err
                }</span>
        }

        // configure Alertmanager
        <span class="cov0" title="0">if err := configureAlertManager(ctx, dscInit, r); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in configureAlertManager: %w", err)
        }</span>

        // configure Prometheus
        <span class="cov0" title="0">if err := configurePrometheus(ctx, dscInit, r); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in configurePrometheus: %w", err)
        }</span>

        <span class="cov0" title="0">if initial == "init" </span><span class="cov0" title="0">{
                err := cluster.UpdatePodSecurityRolebinding(ctx, r.Client, dscInit.Spec.Monitoring.Namespace, "redhat-ods-monitoring")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error to update monitoring security rolebinding: %w", err)
                }</span>
        }

        <span class="cov0" title="0">log.Info("Success: finish config managed monitoring stack!")
        return nil</span>
}

func configureAlertManager(ctx context.Context, dsciInit *dsciv1.DSCInitialization, r *DSCInitializationReconciler) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        // Get Deadmansnitch secret
        deadmansnitchSecret, err := r.waitForManagedSecret(ctx, "redhat-rhods-deadmanssnitch", dsciInit.Spec.Monitoring.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error getting deadmansnitch secret", "namespace", dsciInit.Spec.Monitoring.Namespace)
                return err
        }</span>
        // log.Info("Success: got deadmansnitch secret")

        // Get PagerDuty Secret
        <span class="cov0" title="0">pagerDutySecret, err := r.waitForManagedSecret(ctx, "redhat-rhods-pagerduty", dsciInit.Spec.Monitoring.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error getting pagerduty secret", "namespace", dsciInit.Spec.Monitoring.Namespace)
                return err
        }</span>
        // log.Info("Success: got pagerduty secret")

        // Get Smtp Secret
        <span class="cov0" title="0">smtpSecret, err := r.waitForManagedSecret(ctx, "redhat-rhods-smtp", dsciInit.Spec.Monitoring.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error getting smtp secret", "namespace", dsciInit.Spec.Monitoring.Namespace)
                return err
        }</span>
        // log.Info("Success: got smtp secret")

        // Replace variables in alertmanager configmap for the initial time
        // TODO: Following variables can later be exposed by the API
        <span class="cov0" title="0">err = common.ReplaceStringsInFile(filepath.Join(alertManagerPath, "alertmanager-configs.yaml"),
                map[string]string{
                        "&lt;snitch_url&gt;":      string(deadmansnitchSecret.Data["SNITCH_URL"]),
                        "&lt;pagerduty_token&gt;": string(pagerDutySecret.Data["PAGERDUTY_KEY"]),
                        "&lt;smtp_host&gt;":       string(smtpSecret.Data["host"]),
                        "&lt;smtp_port&gt;":       string(smtpSecret.Data["port"]),
                        "&lt;smtp_username&gt;":   string(smtpSecret.Data["username"]),
                        "&lt;smtp_password&gt;":   string(smtpSecret.Data["password"]),
                })
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to inject data to alertmanager-configs.yaml")
                return err
        }</span>
        // log.Info("Success: inject alertmanage-configs.yaml")

        // special handling for dev-mod
        <span class="cov0" title="0">consolelinkDomain, err := cluster.GetDomain(ctx, r.Client)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting console route URL : %w", err)
        }</span>
        <span class="cov0" title="0">if strings.Contains(consolelinkDomain, "devshift.org") </span><span class="cov0" title="0">{
                log.Info("inject alertmanage-configs.yaml for dev mode1")
                err = common.ReplaceStringsInFile(filepath.Join(alertManagerPath, "alertmanager-configs.yaml"),
                        map[string]string{
                                "@devshift.net": "@rhmw.io",
                        })
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error to replace data for dev mode1 to alertmanager-configs.yaml")
                        return err
                }</span>
        }
        <span class="cov0" title="0">if strings.Contains(consolelinkDomain, "aisrhods") </span><span class="cov0" title="0">{
                log.Info("inject alertmanage-configs.yaml for dev mode2")
                err = common.ReplaceStringsInFile(filepath.Join(alertManagerPath, "alertmanager-configs.yaml"),
                        map[string]string{
                                "receiver: PagerDuty": "receiver: alerts-sink",
                        })
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error to replace data for dev mode2 to alertmanager-configs.yaml")
                        return err
                }</span>
        }

        // log.Info("Success: inject alertmanage-configs.yaml for dev mode")

        <span class="cov0" title="0">operatorNs, err := cluster.GetOperatorNamespace()
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error getting operator namespace for smtp secret")
                return err
        }</span>

        // Get SMTP receiver email secret (assume operator namespace for managed service is not configurable)
        <span class="cov0" title="0">smtpEmailSecret, err := r.waitForManagedSecret(ctx, "addon-managed-odh-parameters", operatorNs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting smtp receiver email secret: %w", err)
        }</span>
        // log.Info("Success: got smpt email secret")
        // replace smtpEmailSecret in alertmanager-configs.yaml
        <span class="cov0" title="0">if err = common.MatchLineInFile(filepath.Join(alertManagerPath, "alertmanager-configs.yaml"),
                map[string]string{
                        "- to: ": "- to: " + string(smtpEmailSecret.Data["notification-email"]),
                },
        ); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to update with new notification-email")
                return err
        }</span>
        // log.Info("Success: update alertmanage-configs.yaml with email")
        <span class="cov0" title="0">err = deploy.DeployManifestsFromPath(ctx, r.Client, dsciInit, alertManagerPath, dsciInit.Spec.Monitoring.Namespace, "alertmanager", true)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to deploy manifests", "path", alertManagerPath)
                return err
        }</span>
        // log.Info("Success: update alertmanager with manifests")

        // Create alertmanager-proxy secret
        <span class="cov0" title="0">if err := createMonitoringProxySecret(ctx, r.Client, "alertmanager-proxy", dsciInit); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to create secret alertmanager-proxy")
                return err
        }</span>
        // log.Info("Success: create alertmanager-proxy secret")
        <span class="cov0" title="0">return nil</span>
}

func configurePrometheus(ctx context.Context, dsciInit *dsciv1.DSCInitialization, r *DSCInitializationReconciler) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        // Update rolebinding-viewer
        err := common.ReplaceStringsInFile(filepath.Join(prometheusManifestsPath, "prometheus-rolebinding-viewer.yaml"),
                map[string]string{
                        "&lt;odh_monitoring_project&gt;": dsciInit.Spec.Monitoring.Namespace,
                })
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to inject data to prometheus-rolebinding-viewer.yaml")
                return err
        }</span>
        // Update prometheus-config for dashboard, dsp and workbench
        <span class="cov0" title="0">consolelinkDomain, err := cluster.GetDomain(ctx, r.Client)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting console route URL : %w", err)
        }</span>
        <span class="cov0" title="0">err = common.ReplaceStringsInFile(filepath.Join(prometheusConfigPath, "prometheus-configs.yaml"),
                map[string]string{
                        "&lt;odh_application_namespace&gt;": dsciInit.Spec.ApplicationsNamespace,
                        "&lt;odh_monitoring_project&gt;":    dsciInit.Spec.Monitoring.Namespace,
                        "&lt;console_domain&gt;":            consolelinkDomain,
                })
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to inject data to prometheus-configs.yaml")
                return err
        }</span>

        // Deploy prometheus manifests from prometheus/apps
        <span class="cov0" title="0">if err = deploy.DeployManifestsFromPath(
                ctx,
                r.Client,
                dsciInit,
                prometheusConfigPath,
                dsciInit.Spec.Monitoring.Namespace,
                "prometheus",
                dsciInit.Spec.Monitoring.ManagementState == operatorv1.Managed); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to deploy manifests for prometheus configs", "path", prometheusConfigPath)
                return err
        }</span>
        // log.Info("Success: create prometheus configmap 'prometheus'")

        // Get prometheus configmap
        <span class="cov0" title="0">prometheusConfigMap := &amp;corev1.ConfigMap{}
        err = r.Client.Get(ctx, client.ObjectKey{
                Namespace: dsciInit.Spec.Monitoring.Namespace,
                Name:      "prometheus",
        }, prometheusConfigMap)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to get configmap 'prometheus'")
                return err
        }</span>
        // log.Info("Success: got prometheus configmap")

        // Get encoded prometheus data from configmap 'prometheus'
        <span class="cov0" title="0">prometheusData, err := common.GetMonitoringData(fmt.Sprint(prometheusConfigMap.Data))
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to get prometheus data")
                return err
        }</span>
        // log.Info("Success: read encoded prometheus data from prometheus.yml in configmap")

        // Get alertmanager host
        <span class="cov0" title="0">alertmanagerRoute := &amp;routev1.Route{}
        err = r.Client.Get(ctx, client.ObjectKey{
                Namespace: dsciInit.Spec.Monitoring.Namespace,
                Name:      "alertmanager",
        }, alertmanagerRoute)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to get alertmanager route")
                return err
        }</span>
        // log.Info("Success: got alertmanager route")

        // Get alertmanager configmap
        <span class="cov0" title="0">alertManagerConfigMap := &amp;corev1.ConfigMap{}
        err = r.Client.Get(ctx, client.ObjectKey{
                Namespace: dsciInit.Spec.Monitoring.Namespace,
                Name:      "alertmanager",
        }, alertManagerConfigMap)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to get configmap 'alertmanager'")
                return err
        }</span>
        // log.Info("Success: got configmap 'alertmanager'")

        <span class="cov0" title="0">alertmanagerData, err := common.GetMonitoringData(alertManagerConfigMap.Data["alertmanager.yml"])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to get encoded alertmanager data from alertmanager.yml")
                return err
        }</span>
        // log.Info("Success: read alertmanager data from alertmanage.yml")

        // Update prometheus deployment with alertmanager and prometheus data
        <span class="cov0" title="0">err = common.ReplaceStringsInFile(filepath.Join(prometheusManifestsPath, "prometheus-deployment.yaml"),
                map[string]string{
                        "&lt;set_alertmanager_host&gt;": alertmanagerRoute.Spec.Host,
                })
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to inject set_alertmanager_host to prometheus-deployment.yaml")
                return err
        }</span>
        // log.Info("Success: update set_alertmanager_host in prometheus-deployment.yaml")
        <span class="cov0" title="0">err = common.MatchLineInFile(filepath.Join(prometheusManifestsPath, "prometheus-deployment.yaml"),
                map[string]string{
                        "alertmanager: ": "alertmanager: " + alertmanagerData,
                        "prometheus: ":   "prometheus: " + prometheusData,
                })
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to update annotations in prometheus-deployment.yaml")
                return err
        }</span>
        // log.Info("Success: update annotations in prometheus-deployment.yaml")

        // final apply prometheus manifests including prometheus deployment
        // Check if Prometheus deployment from legacy version exists(check for initContainer)
        // Need to delete wait-for-deployment initContainer
        <span class="cov0" title="0">existingPromDep := &amp;appsv1.Deployment{}
        err = r.Client.Get(ctx, client.ObjectKey{
                Namespace: dsciInit.Spec.Monitoring.Namespace,
                Name:      "prometheus",
        }, existingPromDep)
        if err != nil </span><span class="cov0" title="0">{
                if !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if len(existingPromDep.Spec.Template.Spec.InitContainers) &gt; 0 </span><span class="cov0" title="0">{
                err = r.Client.Delete(ctx, existingPromDep)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting legacy prometheus deployment %w", err)
                }</span>
        }

        <span class="cov0" title="0">err = deploy.DeployManifestsFromPath(ctx, r.Client, dsciInit, prometheusManifestsPath,
                dsciInit.Spec.Monitoring.Namespace, "prometheus", true)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to deploy manifests for prometheus", "path", prometheusManifestsPath)
                return err
        }</span>

        // Create prometheus-proxy secret
        <span class="cov0" title="0">if err := createMonitoringProxySecret(ctx, r.Client, "prometheus-proxy", dsciInit); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // log.Info("Success: create prometheus-proxy secret")
        <span class="cov0" title="0">return nil</span>
}

func configureBlackboxExporter(ctx context.Context, dsciInit *dsciv1.DSCInitialization, r *DSCInitializationReconciler) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        consoleRoute := &amp;routev1.Route{}
        err := r.Client.Get(ctx, client.ObjectKey{Name: cluster.NameConsoleLink, Namespace: cluster.NamespaceConsoleLink}, consoleRoute)
        if err != nil </span><span class="cov0" title="0">{
                if !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Check if Blackbox exporter deployment from legacy version exists(check for initContainer)
        // Need to delete wait-for-deployment initContainer
        <span class="cov0" title="0">existingBlackboxExp := &amp;appsv1.Deployment{}
        err = r.Client.Get(ctx, client.ObjectKey{
                Namespace: dsciInit.Spec.Monitoring.Namespace,
                Name:      "blackbox-exporter",
        }, existingBlackboxExp)
        if err != nil </span><span class="cov0" title="0">{
                if !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if len(existingBlackboxExp.Spec.Template.Spec.InitContainers) &gt; 0 </span><span class="cov0" title="0">{
                err = r.Client.Delete(ctx, existingBlackboxExp)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error deleting legacy blackbox deployment %w", err)
                }</span>
        }

        <span class="cov0" title="0">blackBoxPath := filepath.Join(deploy.DefaultManifestPath, "monitoring", "blackbox-exporter")
        if k8serr.IsNotFound(err) || strings.Contains(consoleRoute.Spec.Host, "redhat.com") </span><span class="cov0" title="0">{
                if err := deploy.DeployManifestsFromPath(ctx, r.Client,
                        dsciInit,
                        filepath.Join(blackBoxPath, "internal"),
                        dsciInit.Spec.Monitoring.Namespace,
                        "blackbox-exporter",
                        dsciInit.Spec.Monitoring.ManagementState == operatorv1.Managed); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error to deploy manifests: %w", "error", err)
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := deploy.DeployManifestsFromPath(ctx, r.Client,
                        dsciInit,
                        filepath.Join(blackBoxPath, "external"),
                        dsciInit.Spec.Monitoring.Namespace,
                        "blackbox-exporter",
                        dsciInit.Spec.Monitoring.ManagementState == operatorv1.Managed); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error to deploy manifests: %w", "error", err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func createMonitoringProxySecret(ctx context.Context, cli client.Client, name string, dsciInit *dsciv1.DSCInitialization) error <span class="cov0" title="0">{
        sessionSecret, err := GenerateRandomHex(32)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">desiredProxySecret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: dsciInit.Spec.Monitoring.Namespace,
                },
                Data: map[string][]byte{
                        "session_secret": []byte(b64.StdEncoding.EncodeToString(sessionSecret)),
                },
        }

        foundProxySecret := &amp;corev1.Secret{}
        err = cli.Get(ctx, client.ObjectKeyFromObject(desiredProxySecret), foundProxySecret)
        if err != nil </span><span class="cov0" title="0">{
                if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        // Set Controller reference
                        err = ctrl.SetControllerReference(dsciInit, desiredProxySecret, cli.Scheme())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">err = cli.Create(ctx, desiredProxySecret)
                        if err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *DSCInitializationReconciler) configureSegmentIO(ctx context.Context, dsciInit *dsciv1.DSCInitialization) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        // create segment.io only when configmap does not exist in the cluster
        segmentioConfigMap := &amp;corev1.ConfigMap{}
        if err := r.Client.Get(ctx, client.ObjectKey{
                Namespace: dsciInit.Spec.ApplicationsNamespace,
                Name:      "odh-segment-key-config",
        }, segmentioConfigMap); err != nil </span><span class="cov0" title="0">{
                if !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Error(err, "error to get configmap 'odh-segment-key-config'")
                        return err
                }</span> else<span class="cov0" title="0"> {
                        segmentPath := filepath.Join(deploy.DefaultManifestPath, "monitoring", "segment")
                        if err := deploy.DeployManifestsFromPath(
                                ctx,
                                r.Client,
                                dsciInit,
                                segmentPath,
                                dsciInit.Spec.ApplicationsNamespace,
                                "segment-io",
                                dsciInit.Spec.Monitoring.ManagementState == operatorv1.Managed); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "error to deploy manifests", "path", segmentPath)
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *DSCInitializationReconciler) configureCommonMonitoring(ctx context.Context, dsciInit *dsciv1.DSCInitialization) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        if err := r.configureSegmentIO(ctx, dsciInit); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // configure monitoring base
        <span class="cov0" title="0">monitoringBasePath := filepath.Join(deploy.DefaultManifestPath, "monitoring", "base")
        err := common.ReplaceStringsInFile(filepath.Join(monitoringBasePath, "rhods-servicemonitor.yaml"),
                map[string]string{
                        "&lt;odh_monitoring_project&gt;": dsciInit.Spec.Monitoring.Namespace,
                })
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to inject namespace to common monitoring")

                return err
        }</span>
        // do not set monitoring namespace here, it is hardcoded by manifests
        <span class="cov0" title="0">if err := deploy.DeployManifestsFromPath(
                ctx,
                r.Client,
                dsciInit,
                monitoringBasePath,
                "",
                "monitoring-base",
                dsciInit.Spec.Monitoring.ManagementState == operatorv1.Managed); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error to deploy manifests", "path", monitoringBasePath)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package dscinitialization

import (
        "context"
        "crypto/rand"
        "errors"
        "fmt"
        "time"

        operatorv1 "github.com/openshift/api/operator/v1"
        corev1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/wait"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

var (
        resourceInterval = 2 * time.Second
)

// createOperatorResource include steps:
// - 1. validate customized application namespace || create/update default application namespace
//   - patch application namespaces for managed cluster
//   - Odh specific labels for access
//   - Pod security labels for baseline permissions
//
// - 2. Patch monitoring namespace
// - 3. Network Policies 'opendatahub' that allow traffic between the ODH namespaces.
func (r *DSCInitializationReconciler) createOperatorResource(ctx context.Context, dscInit *dsciv1.DSCInitialization, platform common.Platform) error <span class="cov8" title="1">{
        log := logf.FromContext(ctx)

        if err := r.appNamespaceHandler(ctx, dscInit, platform); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error handle application namespace")
                return err
        }</span>

        <span class="cov8" title="1">if dscInit.Spec.Monitoring.ManagementState == operatorv1.Managed || platform == cluster.ManagedRhoai </span><span class="cov8" title="1">{
                if err := PatchMonitoringNS(ctx, r.Client, dscInit); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error patch monitoring namespace")
                        return err
                }</span>
        }

        // Create default NetworkPolicy for the namespace
        <span class="cov8" title="1">if err := ReconcileDefaultNetworkPolicy(ctx, r.Client, dscInit, platform); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *DSCInitializationReconciler) appNamespaceHandler(ctx context.Context, dscInit *dsciv1.DSCInitialization, platform common.Platform) error <span class="cov8" title="1">{
        log := logf.FromContext(ctx)

        nsList := &amp;corev1.NamespaceList{}
        ns := &amp;corev1.Namespace{}
        dsciNsName := dscInit.Spec.ApplicationsNamespace

        if err := r.Client.List(ctx, nsList, client.MatchingLabels{
                labels.CustomizedAppNamespace: labels.True,
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">switch len(nsList.Items) </span>{
        case 0:<span class="cov8" title="1">
                // create namespace if not exist
                desiredAppNS := &amp;corev1.Namespace{
                        ObjectMeta: metav1.ObjectMeta{
                                Name: dsciNsName,
                        },
                }
                if err := r.Client.Get(ctx, client.ObjectKeyFromObject(desiredAppNS), ns); err != nil </span><span class="cov8" title="1">{
                        if !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">log.Info("Application namespace set in DSCI not found, creating it with labels", "name", dsciNsName)
                // // ensure generatedd-namespace:true and security label always on it
                return r.createAppNamespace(ctx, dsciNsName, platform, map[string]string{labels.ODH.OwnedNamespace: labels.True})</span> // this indicate when uninstall, namespace will be deleted
        case 1:<span class="cov8" title="1">
                if nsList.Items[0].Name != dsciNsName </span><span class="cov0" title="0">{
                        return errors.New("DSCI must used the same namespace which has opendatahub.io/application-namespace=true label")
                }</span>
                // ensure security label always on it
                <span class="cov8" title="1">return r.createAppNamespace(ctx, dsciNsName, platform)</span>
        default:<span class="cov0" title="0">
                return errors.New("only support max. one namespace with label: opendatahub.io/application-namespace=true")</span>
        }
}

func (r *DSCInitializationReconciler) createAppNamespace(ctx context.Context, nsName string, platform common.Platform, extraLabel ...map[string]string) error <span class="cov8" title="1">{
        desiredDefaultNS := &amp;corev1.Namespace{
                ObjectMeta: metav1.ObjectMeta{Name: nsName},
        }
        labelList := map[string]string{
                labels.SecurityEnforce: "baseline",
        }

        // label only for managed cluster
        if platform == cluster.ManagedRhoai </span><span class="cov0" title="0">{
                labelList[labels.ClusterMonitoring] = labels.True
        }</span>

        <span class="cov8" title="1">for _, l := range extraLabel </span><span class="cov8" title="1">{
                for k, v := range l </span><span class="cov8" title="1">{
                        labelList[k] = v
                }</span>
        }

        <span class="cov8" title="1">_, err := controllerutil.CreateOrUpdate(ctx, r.Client, desiredDefaultNS, func() error </span><span class="cov8" title="1">{
                resources.SetLabels(desiredDefaultNS, labelList)
                return nil
        }</span>)
        <span class="cov8" title="1">return err</span>
}

func PatchMonitoringNS(ctx context.Context, cli client.Client, dscInit *dsciv1.DSCInitialization) error <span class="cov8" title="1">{
        log := logf.FromContext(ctx)
        monitoringName := dscInit.Spec.Monitoring.Namespace
        if dscInit.Spec.Monitoring.ManagementState != operatorv1.Managed || dscInit.Spec.ApplicationsNamespace == monitoringName </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Create Monitoring Namespace if it is enabled and not exists

        <span class="cov8" title="1">desiredMonitoringNamespace := &amp;corev1.Namespace{
                ObjectMeta: metav1.ObjectMeta{
                        Name: monitoringName,
                },
        }

        _, err := controllerutil.CreateOrUpdate(ctx, cli, desiredMonitoringNamespace, func() error </span><span class="cov8" title="1">{
                resources.SetLabels(desiredMonitoringNamespace, map[string]string{
                        labels.ODH.OwnedNamespace: labels.True,
                        labels.SecurityEnforce:    "baseline",
                        labels.ClusterMonitoring:  labels.True,
                })
                return nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Unable to create or patch monitoring namespace")
        }</span>
        <span class="cov8" title="1">return err</span>
}

func ReconcileDefaultNetworkPolicy(
        ctx context.Context,
        cli client.Client,
        dscInit *dsciv1.DSCInitialization,
        platform common.Platform,
) error <span class="cov8" title="1">{
        if platform == cluster.ManagedRhoai || platform == cluster.SelfManagedRhoai </span><span class="cov0" title="0">{
                log := logf.FromContext(ctx)

                // Get operator namepsace
                operatorNs, err := cluster.GetOperatorNamespace()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error getting operator namespace for networkpolicy creation")
                        return err
                }</span>
                // Deploy networkpolicy for operator namespace
                <span class="cov0" title="0">err = deploy.DeployManifestsFromPath(ctx, cli, dscInit, networkpolicyPath+"/operator", operatorNs, "networkpolicy", true)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error to set networkpolicy in operator namespace", "path", networkpolicyPath)
                        return err
                }</span>
                // Deploy networkpolicy for monitoring namespace only when it is managed cluster.
                <span class="cov0" title="0">if platform == cluster.ManagedRhoai </span><span class="cov0" title="0">{
                        err = deploy.DeployManifestsFromPath(ctx, cli, dscInit, networkpolicyPath+"/monitoring", dscInit.Spec.Monitoring.Namespace, "networkpolicy", true)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "error to set networkpolicy in monitoring namespace", "path", networkpolicyPath)
                                return err
                        }</span>
                }
                // Deploy networkpolicy for applications namespace
                <span class="cov0" title="0">err = deploy.DeployManifestsFromPath(ctx, cli, dscInit, networkpolicyPath+"/applications", dscInit.Spec.ApplicationsNamespace, "networkpolicy", true)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error to set networkpolicy in applications namespace", "path", networkpolicyPath)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Expected namespace for the given name in ODH
        <span class="cov8" title="1">np := networkingv1.NetworkPolicy{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      dscInit.Spec.ApplicationsNamespace,
                        Namespace: dscInit.Spec.ApplicationsNamespace,
                },
                Spec: networkingv1.NetworkPolicySpec{
                        Ingress: []networkingv1.NetworkPolicyIngressRule{{
                                From: createNetworkPolicyPeer(labels.ODH.OwnedNamespace, labels.True)}, {
                                From: createNetworkPolicyPeer(labels.CustomizedAppNamespace, labels.True)}, {
                                From: createNetworkPolicyPeer("network.openshift.io/policy-group", "ingress")}, {
                                From: createNetworkPolicyPeer("kubernetes.io/metadata.name", "openshift-host-network")}, {
                                From: createNetworkPolicyPeer("kubernetes.io/metadata.name", "openshift-monitoring")},
                        },
                        PolicyTypes: []networkingv1.PolicyType{
                                networkingv1.PolicyTypeIngress,
                        },
                },
        }

        if err := resources.EnsureGroupVersionKind(cli.Scheme(), &amp;np); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to set GVK to NetworkPolicy: %w", err)
        }</span>

        <span class="cov8" title="1">if err := controllerutil.SetControllerReference(dscInit, &amp;np, cli.Scheme()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to add OwnerReference to the Network policy: %w", err)
        }</span>

        <span class="cov8" title="1">err := resources.Apply(
                ctx,
                cli,
                &amp;np,
                client.FieldOwner(fieldManager),
                client.ForceOwnership,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *DSCInitializationReconciler) waitForManagedSecret(ctx context.Context, name string, namespace string) (*corev1.Secret, error) <span class="cov0" title="0">{
        managedSecret := &amp;corev1.Secret{}
        backoff := wait.Backoff{
                Duration: resourceInterval,
                Factor:   2.0,
                Steps:    5,
        }

        err := wait.ExponentialBackoffWithContext(ctx, backoff, func(ctx context.Context) (bool, error) </span><span class="cov0" title="0">{
                err := r.Client.Get(ctx, client.ObjectKey{
                        Namespace: namespace,
                        Name:      name,
                }, managedSecret)

                if err != nil </span><span class="cov0" title="0">{
                        return false, client.IgnoreNotFound(err)
                }</span>
                <span class="cov0" title="0">return true, nil</span>
        })

        <span class="cov0" title="0">return managedSecret, err</span>
}

func GenerateRandomHex(length int) ([]byte, error) <span class="cov0" title="0">{
        // Calculate the required number of bytes
        numBytes := length / 2

        // Create a byte slice with the appropriate size
        randomBytes := make([]byte, numBytes)

        // Read random bytes from the crypto/rand source
        if _, err := rand.Read(randomBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return randomBytes, nil</span>
}

func createNetworkPolicyPeer(key, value string) []networkingv1.NetworkPolicyPeer <span class="cov8" title="1">{
        return []networkingv1.NetworkPolicyPeer{{
                NamespaceSelector: &amp;metav1.LabelSelector{
                        MatchLabels: map[string]string{key: value},
                },
        }}
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package auth

import (
        "context"
        "errors"

        configv1 "github.com/openshift/api/config/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "sigs.k8s.io/controller-runtime/pkg/client"

        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
)

const (
        ServiceName = serviceApi.AuthServiceName
)

// IsDefaultAuthMethod returns true if the default authentication method is IntegratedOAuth or empty.
// This will give indication that Operator should create userGroups or not in the cluster.
func IsDefaultAuthMethod(ctx context.Context, cli client.Client) (bool, error) <span class="cov10" title="7">{
        authenticationobj := &amp;configv1.Authentication{}
        if err := cli.Get(ctx, client.ObjectKey{Name: cluster.ClusterAuthenticationObj, Namespace: ""}, authenticationobj); err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, &amp;meta.NoKindMatchError{}) </span><span class="cov0" title="0">{ // when CRD is missing, convert error type
                        return false, k8serr.NewNotFound(schema.GroupResource{Group: gvk.Auth.Group}, cluster.ClusterAuthenticationObj)
                }</span>
                <span class="cov4" title="2">return false, err</span>
        }

        // for now, HPC support "" "None" "IntegratedOAuth"(default) "OIDC"
        // other offering support "" "None" "IntegratedOAuth"(default)
        // we only create userGroups for "IntegratedOAuth" or "" and leave other or new supported type value in the future
        <span class="cov9" title="6">return authenticationobj.Spec.Type == configv1.AuthenticationTypeIntegratedOAuth || authenticationobj.Spec.Type == "", nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package auth

import (
        "context"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        sr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/template"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
)

//nolint:gochecknoinits
func init() <span class="cov5" title="2">{
        sr.Add(&amp;ServiceHandler{})
}</span>

type ServiceHandler struct {
}

func (h *ServiceHandler) Init(_ common.Platform) error <span class="cov5" title="2">{
        return nil
}</span>

func (h *ServiceHandler) GetName() string <span class="cov5" title="2">{
        return ServiceName
}</span>

func (h *ServiceHandler) GetManagementState(platform common.Platform, _ *dsciv1.DSCInitialization) operatorv1.ManagementState <span class="cov10" title="4">{
        return operatorv1.Managed
}</span>

func (h *ServiceHandler) NewReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(mgr, &amp;serviceApi.Auth{}).
                // operands - owned
                Owns(&amp;rbacv1.ClusterRoleBinding{}).
                Owns(&amp;rbacv1.ClusterRole{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                // actions
                WithAction(initialize).
                WithAction(template.NewAction()).
                WithAction(createDefaultGroup).
                WithAction(managePermissions).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                Build(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create the auth controller: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package auth

import (
        "context"
        "errors"
        "fmt"

        userv1 "github.com/openshift/api/user/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

func initialize(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov3" title="2">{
        rr.Templates = []odhtypes.TemplateInfo{
                {
                        FS:   resourcesFS,
                        Path: AdminGroupRoleTemplate,
                },
                {
                        FS:   resourcesFS,
                        Path: AllowedGroupRoleTemplate,
                },
                {
                        FS:   resourcesFS,
                        Path: AdminGroupClusterRoleTemplate,
                },
        }

        return nil
}</span>

func bindRole(ctx context.Context, rr *odhtypes.ReconciliationRequest, groups []string, roleBindingName string, roleName string) error <span class="cov7" title="6">{
        groupsToBind := []rbacv1.Subject{}
        for _, e := range groups </span><span class="cov10" title="14">{
                // we want to disallow adding system:authenticated to the adminGroups
                if roleName == "admingroup-role" &amp;&amp; e == "system:authenticated" || e == "" </span><span class="cov4" title="3">{
                        log := logf.FromContext(ctx)
                        log.Info("skipping adding invalid group to RoleBinding")
                        continue</span>
                }
                <span class="cov9" title="12">rs := rbacv1.Subject{
                        Kind:     gvk.Group.Kind,
                        APIGroup: gvk.Group.Group,
                        Name:     e,
                }
                groupsToBind = append(groupsToBind, rs)</span>
        }

        <span class="cov7" title="6">rb := &amp;rbacv1.RoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      roleBindingName,
                        Namespace: rr.DSCI.Spec.ApplicationsNamespace,
                },
                Subjects: groupsToBind,
                RoleRef: rbacv1.RoleRef{
                        APIGroup: gvk.Role.Group,
                        Kind:     gvk.Role.Kind,
                        Name:     roleName,
                },
        }
        err := rr.AddResources(rb)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("error creating RoleBinding for group")
        }</span>

        <span class="cov7" title="6">return nil</span>
}

func bindClusterRole(ctx context.Context, rr *odhtypes.ReconciliationRequest, groups []string, roleBindingName string, roleName string) error <span class="cov3" title="2">{
        groupsToBind := []rbacv1.Subject{}
        for _, e := range groups </span><span class="cov4" title="3">{
                // we want to disallow adding system:authenticated to the adminGroups
                if roleName == "admingroupcluster-role" &amp;&amp; e == "system:authenticated" || e == "" </span><span class="cov0" title="0">{
                        log := logf.FromContext(ctx)
                        log.Info("skipping adding invalid group to ClusterRoleBinding")
                        continue</span>
                }
                <span class="cov4" title="3">rs := rbacv1.Subject{
                        Kind:     gvk.Group.Kind,
                        APIGroup: gvk.Group.Group,
                        Name:     e,
                }

                groupsToBind = append(groupsToBind, rs)</span>
        }

        <span class="cov3" title="2">crb := &amp;rbacv1.ClusterRoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name: roleBindingName,
                },
                Subjects: groupsToBind,
                RoleRef: rbacv1.RoleRef{
                        Kind:     gvk.ClusterRole.Kind,
                        APIGroup: gvk.ClusterRole.Group,
                        Name:     roleName,
                },
        }
        err := rr.AddResources(crb)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("error creating RoleBinding for group")
        }</span>

        <span class="cov3" title="2">return nil</span>
}

func managePermissions(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov4" title="3">{
        ai, ok := rr.Instance.(*serviceApi.Auth)
        if !ok </span><span class="cov3" title="2">{
                return errors.New("instance is not of type *services.Auth")
        }</span>

        <span class="cov3" title="2">err := bindRole(ctx, rr, ai.Spec.AdminGroups, "admingroup-rolebinding", "admingroup-role")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">err = bindClusterRole(ctx, rr, ai.Spec.AdminGroups, "admingroupcluster-rolebinding", "admingroupcluster-role")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">err = bindRole(ctx, rr, ai.Spec.AllowedGroups, "allowedgroup-rolebinding", "allowedgroup-role")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">return nil</span>
}

func addUserGroup(ctx context.Context, rr *odhtypes.ReconciliationRequest, userGroupName string) error <span class="cov3" title="2">{
        namespace, err := actions.ApplicationNamespace(ctx, rr)
        if err != nil </span><span class="cov0" title="0">{
                logf.Log.Error(err, "error getting application namespace")
                return err
        }</span>
        <span class="cov3" title="2">userGroup := &amp;userv1.Group{
                ObjectMeta: metav1.ObjectMeta{
                        Name: userGroupName,
                        // Otherwise it errors with  "error": "an empty namespace may not be set during creation"
                        Namespace: namespace,
                        Annotations: map[string]string{
                                annotations.ManagedByODHOperator: "false",
                        },
                },
                // Otherwise is errors with "error": "Group.user.openshift.io \"odh-admins\" is invalid: users: Invalid value: \"null\": users in body must be of type array: \"null\""}
                Users: []string{},
        }
        err = rr.AddResources(userGroup)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to add user group: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

func createDefaultGroup(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov3" title="2">{
        ok, err := IsDefaultAuthMethod(ctx, rr.Client)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">if !ok </span><span class="cov0" title="0">{
                logf.Log.Info("default auth method is not enabled")
                return nil
        }</span>

        <span class="cov3" title="2">release := cluster.GetRelease()
        switch release.Name </span>{
        case cluster.ManagedRhoai:<span class="cov0" title="0">
                err = addUserGroup(ctx, rr, "rhods-admins")
                if err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        case cluster.SelfManagedRhoai:<span class="cov0" title="0">
                err = addUserGroup(ctx, rr, "rhods-admins")
                if err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov3" title="2">
                err = addUserGroup(ctx, rr, "odh-admins")
                if err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package certconfigmapgenerator

import (
        "context"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        sr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/registry"
)

const (
        ServiceName = "certconfigmapgenerator"
)

//nolint:gochecknoinits
func init() <span class="cov10" title="3">{
        sr.Add(&amp;serviceHandler{})
}</span>

type serviceHandler struct {
}

func (h *serviceHandler) Init(_ common.Platform) error <span class="cov0" title="0">{
        return nil
}</span>

func (h *serviceHandler) GetName() string <span class="cov0" title="0">{
        return ServiceName
}</span>

func (h *serviceHandler) GetManagementState(_ common.Platform, _ *dsciv1.DSCInitialization) operatorv1.ManagementState <span class="cov0" title="0">{
        return operatorv1.Managed
}</span>

func (h *serviceHandler) NewReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        if err := NewWithManager(ctx, mgr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create the %s controller: %w", ServiceName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">// Package certconfigmapgenerator contains generator logic of add cert configmap resource in user namespaces
package certconfigmapgenerator

import (
        "context"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/cache"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"

        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        respredicates "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        annotation "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
        odhlabels "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

// CertConfigmapGeneratorReconciler holds the controller configuration.
type CertConfigmapGeneratorReconciler struct {
        sharedClient client.Client
        certClient   client.Client
}

// NewWithManager sets up the controller with the Manager.
func NewWithManager(_ context.Context, mgr ctrl.Manager) error <span class="cov3" title="3">{
        r := CertConfigmapGeneratorReconciler{}

        targetCache, err := cache.New(mgr.GetConfig(), cache.Options{
                HTTPClient:                  mgr.GetHTTPClient(),
                Scheme:                      mgr.GetScheme(),
                Mapper:                      mgr.GetRESTMapper(),
                ReaderFailOnMissingInformer: true,
                ByObject: map[client.Object]cache.ByObject{
                        &amp;corev1.ConfigMap{}: {
                                // We don't need to cache all the configmaps, but only those designated to
                                // hold Trust CA Bundles, that can be discriminated using a label selector
                                // and a field selector (as the name is fixed).
                                Label: labels.Set{odhlabels.K8SCommon.PartOf: PartOf}.AsSelector(),
                                Field: fields.Set{"metadata.name": CAConfigMapName}.AsSelector(),
                        },
                },
                DefaultTransform: func(in any) (any, error) </span><span class="cov5" title="8">{
                        if obj, err := meta.Accessor(in); err == nil &amp;&amp; obj.GetManagedFields() != nil </span><span class="cov5" title="8">{
                                obj.SetManagedFields(nil)
                        }</span>

                        <span class="cov5" title="8">return in, nil</span>
                },
        })

        <span class="cov3" title="3">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create cache: %w", err)
        }</span>

        <span class="cov3" title="3">err = mgr.Add(targetCache)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to register target cache to manager: %w", err)
        }</span>

        // create a new client that uses the custom cache
        <span class="cov3" title="3">targetClient, err := client.New(mgr.GetConfig(), client.Options{
                HTTPClient: mgr.GetHTTPClient(),
                Scheme:     mgr.GetScheme(),
                Mapper:     mgr.GetRESTMapper(),
                Cache: &amp;client.CacheOptions{
                        Unstructured: true,
                        Reader:       targetCache,
                        DisableFor: []client.Object{
                                // Server-side apply removes the need to cache the ConfigMap, as we
                                // don’t need to access any of its fields. We only watch it to detect
                                // and revert any external modifications.
                                &amp;corev1.ConfigMap{},
                        },
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create client: %w", err)
        }</span>

        <span class="cov3" title="3">r.sharedClient = mgr.GetClient()
        r.certClient = targetClient

        b := ctrl.NewControllerManagedBy(mgr).
                Named("cert-configmap-generator-controller")

        //
        // Namespace
        //
        b = b.WatchesRawSource(
                // The Namespaces cache is unrestricted, so we rely on the shared cache.
                //
                // Currently, all Namespaces are cached because the controller must handle any
                // namespace (excluding reserved ones). We filter by namespace phase to skip
                // those in the process of termination.
                //
                // In the future, we should implement an opt-in mechanism to selectively cache
                // namespaces using label selectors. This would allow us to use a dedicated
                // cache for this controller and separate ones for components and services.
                source.TypedKind[client.Object, ctrl.Request](
                        mgr.GetCache(),
                        &amp;corev1.Namespace{},
                        handlers.RequestFromObject(),
                        respredicates.AnnotationChanged(annotation.InjectionOfCABundleAnnotatoion),
                ),
        )

        //
        // Configmap
        //
        b = b.WatchesRawSource(
                // Use a custom cache to avoid affecting the global cache managed by the controller manager.
                //
                // Server-side apply removes the need to cache the ConfigMap itself.
                // We only watch the ConfigMap to detect and revert any external modifications.
                //
                // Leveraging PartialObjectMetadata minimizes API server load and reduces network traffic
                // by fetching only metadata instead of the full object.
                source.TypedKind[client.Object, ctrl.Request](
                        targetCache,
                        resources.GvkToPartial(gvk.ConfigMap),
                        handlers.Fn(func(_ context.Context, obj client.Object) []reconcile.Request </span><span class="cov5" title="8">{
                                return []reconcile.Request{{
                                        NamespacedName: types.NamespacedName{
                                                Name: obj.GetNamespace(),
                                        },
                                }}
                        }</span>),
                ),
        )

        //
        // DSCInitialization
        //
        <span class="cov3" title="3">b = b.WatchesRawSource(
                // The DSCInitialization singleton is shared across nearly all controllers.
                // It uses the manager's shared cache to prevent the creation of redundant informers.
                source.TypedKind[client.Object, ctrl.Request](
                        mgr.GetCache(),
                        &amp;dsciv1.DSCInitialization{},
                        dsciEventHandler(r.sharedClient),
                        dsciPredicates(r.sharedClient),
                ),
        )

        return b.Complete(
                reconcile.AsReconciler[*corev1.Namespace](r.sharedClient, &amp;r),
        )</span>
}

// Reconcile will generate new configmap, odh-trusted-ca-bundle, that includes cluster-wide
// trusted-ca bundle and custom ca bundle in every new namespace created.
func (r *CertConfigmapGeneratorReconciler) Reconcile(ctx context.Context, ns *corev1.Namespace) (ctrl.Result, error) <span class="cov10" title="47">{
        l := logf.FromContext(ctx)

        if !cluster.IsActiveNamespace(ns) </span><span class="cov0" title="0">{
                l.V(3).Info("Namespace not active, skip")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov10" title="47">if cluster.IsReservedNamespace(ns) </span><span class="cov8" title="26">{
                l.V(3).Info("Namespace is reserved, skip")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov8" title="23">dsci, err := cluster.GetDSCI(ctx, r.sharedClient)
        switch </span>{
        case k8serr.IsNotFound(err):<span class="cov4" title="5">
                return ctrl.Result{}, nil</span>
        case err != nil:<span class="cov0" title="0">
                return ctrl.Result{}, fmt.Errorf("failed to retrieve DSCInitialization: %w", err)</span>
        }

        <span class="cov8" title="20">switch </span>{
        case dsci.Spec.TrustedCABundle == nil:<span class="cov4" title="5">
                l.Info("Trusted CA Bundle is not configured in DSCI, skip CA bundle injection and delete existing configmap")

                if err := DeleteOdhTrustedCABundleConfigMap(ctx, r.certClient, ns.Name); err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, fmt.Errorf("error deleting existing configmap: %w", err)
                }</span>

        case !ShouldInjectTrustedCABundle(ns):<span class="cov5" title="8">
                l.Info("Namespace has opted-out of CA bundle injection, deleting it")

                if err := DeleteOdhTrustedCABundleConfigMap(ctx, r.certClient, ns.Name); err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, fmt.Errorf("error deleting existing configmap: %w", err)
                }</span>

        case dsci.Spec.TrustedCABundle.ManagementState == operatorv1.Removed:<span class="cov4" title="4">
                l.Info("Trusted CA Bundle injection is set to `Removed` state, skip CA bundle injection and delete existing configmap")

                if err := DeleteOdhTrustedCABundleConfigMap(ctx, r.certClient, ns.Name); err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, fmt.Errorf("error deleting existing configmap: %w", err)
                }</span>

        case dsci.Spec.TrustedCABundle.ManagementState == operatorv1.Unmanaged:<span class="cov3" title="3">
                l.Info("Trusted CA Bundle injection is set to `Unmanaged` state, configmap is no longer managed by operator")</span>

        default:<span class="cov5" title="8">
                l.Info("Adding CA bundle configmap")

                if err := CreateOdhTrustedCABundleConfigMap(ctx, r.certClient, ns.Name, dsci.Spec.TrustedCABundle.CustomCABundle); err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, fmt.Errorf("error adding configmap to namespace: %w", err)
                }</span>
        }

        <span class="cov8" title="20">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Package trustedcabundle provides utility functions to create and check trusted CA bundle configmap from DSCI CRD
package certconfigmapgenerator

import (
        "context"
        "reflect"
        "strconv"
        "strings"

        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        annotation "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

const (
        CAConfigMapName           = "odh-trusted-ca-bundle"
        CADataFieldName           = "odh-ca-bundle.crt"
        TrustedCABundleFieldOwner = resources.PlatformFieldOwner + "/trustedcabundle"
        PartOf                    = "opendatahub-operator"
        NSListLimit               = 500
)

// CreateOdhTrustedCABundleConfigMap creates a configMap 'odh-trusted-ca-bundle' in given namespace with labels and data
// or update existing odh-trusted-ca-bundle configmap if already exists with new content of .data.odh-ca-bundle.crt
// this is certificates for the cluster trusted CA Cert Bundle.
func CreateOdhTrustedCABundleConfigMap(ctx context.Context, cli client.Client, namespace string, customCAData string) error <span class="cov5" title="8">{
        // Adding newline breaker if user input does not have it
        customCAData = strings.TrimSpace(customCAData) + "\n"

        // Expected configmap for the given namespace
        desiredConfigMap := &amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      CAConfigMapName,
                        Namespace: namespace,
                        Labels: map[string]string{
                                labels.K8SCommon.PartOf: PartOf,
                                // Label 'config.openshift.io/inject-trusted-cabundle' required for the Cluster Network Operator(CNO)
                                // to inject the cluster trusted CA bundle into .data["ca-bundle.crt"]
                                labels.InjectTrustCA: labels.True,
                        },
                },
                // Add the DSCInitialzation specified TrustedCABundle.CustomCABundle to CM's data.odh-ca-bundle.crt field
                //
                // Additionally, the CNO operator will automatically create and maintain ca-bundle.crt
                // if label 'config.openshift.io/inject-trusted-cabundle' is true
                Data: map[string]string{
                        CADataFieldName: customCAData,
                },
        }

        err := resources.Apply(
                ctx,
                cli,
                desiredConfigMap,
                client.FieldOwner(TrustedCABundleFieldOwner),
                client.ForceOwnership,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="8">return nil</span>
}

func DeleteOdhTrustedCABundleConfigMap(ctx context.Context, cli client.Client, namespace string) error <span class="cov6" title="13">{
        cm := corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      CAConfigMapName,
                        Namespace: namespace},
        }

        err := cli.Delete(ctx, &amp;cm)
        if err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="13">return nil</span>
}

func ShouldInjectTrustedCABundle(obj client.Object) bool <span class="cov8" title="25">{
        value, found := obj.GetAnnotations()[annotation.InjectionOfCABundleAnnotatoion]
        if !found </span><span class="cov6" title="12">{
                return true
        }</span>

        <span class="cov7" title="15">shouldInject, err := strconv.ParseBool(value)
        if err != nil </span><span class="cov3" title="3">{
                return true
        }</span>

        <span class="cov6" title="14">return shouldInject</span>
}

// dsciEventHandler creates an event handler for DSCInitialization events. When a DSCInitialization
// resource changes, this handler enqueues reconciliation requests for all namespaces in the cluster,
// allowing the controller to update CA Bundle configuration across all namespaces.
//
// Parameters:
//   - cli: Kubernetes client used to list namespaces
//
// Returns:
//   - handler.EventHandler: Event handler that maps DSCInitialization events to namespace reconcile requests
func dsciEventHandler(cli client.Client) handler.EventHandler <span class="cov3" title="3">{
        return handler.EnqueueRequestsFromMapFunc(func(ctx context.Context, obj client.Object) []reconcile.Request </span><span class="cov6" title="11">{
                requests := make([]reconcile.Request, 0)

                lo := client.ListOptions{
                        Limit: NSListLimit,
                }

                for </span><span class="cov6" title="11">{
                        namespaces := corev1.NamespaceList{}

                        if err := cli.List(ctx, &amp;namespaces, &amp;lo); err != nil </span><span class="cov0" title="0">{
                                return []reconcile.Request{}
                        }</span>

                        <span class="cov6" title="11">for _, ns := range namespaces.Items </span><span class="cov10" title="56">{
                                requests = append(requests, reconcile.Request{
                                        NamespacedName: resources.NamespacedNameFromObject(&amp;ns),
                                })
                        }</span>

                        <span class="cov6" title="11">if namespaces.Continue == "" </span><span class="cov6" title="11">{
                                break</span>
                        }

                        <span class="cov0" title="0">lo.Continue = namespaces.Continue</span>
                }

                <span class="cov6" title="11">return requests</span>
        })
}

// dsciPredicates creates predicates for filtering DSCInitialization events. It determines when
// reconciliation should be triggered based on relevant changes to DSCInitialization resources:
// - Always reconcile on resource creation
// - Reconcile on updates only when the TrustedCABundle configuration changes
// - Never reconcile on resource deletion
//
// Parameters:
//   - _: Unused client parameter (kept for interface compatibility)
//
// Returns:
//   - predicate.Funcs: Event filter predicates for DSCInitialization events
func dsciPredicates(_ client.Client) predicate.Funcs <span class="cov3" title="3">{
        return predicate.Funcs{
                CreateFunc: func(e event.CreateEvent) bool </span><span class="cov3" title="3">{
                        return true
                }</span>,

                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov5" title="6">{
                        dsciOld, ok := e.ObjectOld.(*dsciv1.DSCInitialization)
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov5" title="6">dsciNew, ok := e.ObjectNew.(*dsciv1.DSCInitialization)
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov5" title="6">return !reflect.DeepEqual(dsciOld.Spec.TrustedCABundle, dsciNew.Spec.TrustedCABundle)</span>
                },

                DeleteFunc: func(deleteEvent event.DeleteEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package monitoring

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/yaml.v3"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        ServiceName = serviceApi.MonitoringServiceName
)

var (
        prometheusConfigPath = filepath.Join(odhdeploy.DefaultManifestPath, ServiceName, "prometheus", "apps", "prometheus-configs.yaml")
)

// updatePrometheusConfig update prometheus-configs.yaml to include/exclude &lt;component&gt;.rules
// parameter enable when set to true to add new rules, when set to false to remove existing rules.
func updatePrometheusConfig(ctx context.Context, enable bool, component string) error <span class="cov0" title="0">{
        l := logf.FromContext(ctx)

        // create a struct to mock poremtheus.yml
        type ConfigMap struct {
                APIVersion string `yaml:"apiVersion"`
                Kind       string `yaml:"kind"`
                Metadata   struct {
                        Name      string `yaml:"name"`
                        Namespace string `yaml:"namespace"`
                } `yaml:"metadata"`
                Data struct {
                        PrometheusYML          string `yaml:"prometheus.yml"`
                        OperatorRules          string `yaml:"operator-recording.rules"`
                        DeadManSnitchRules     string `yaml:"deadmanssnitch-alerting.rules"`
                        CFRRules               string `yaml:"codeflare-recording.rules"`
                        CRARules               string `yaml:"codeflare-alerting.rules"`
                        DashboardRRules        string `yaml:"rhods-dashboard-recording.rules"`
                        DashboardARules        string `yaml:"rhods-dashboard-alerting.rules"`
                        DSPRRules              string `yaml:"data-science-pipelines-operator-recording.rules"`
                        DSPARules              string `yaml:"data-science-pipelines-operator-alerting.rules"`
                        MMRRules               string `yaml:"model-mesh-recording.rules"`
                        MMARules               string `yaml:"model-mesh-alerting.rules"`
                        OdhModelRRules         string `yaml:"odh-model-controller-recording.rules"`
                        OdhModelARules         string `yaml:"odh-model-controller-alerting.rules"`
                        RayARules              string `yaml:"ray-alerting.rules"`
                        WorkbenchesRRules      string `yaml:"workbenches-recording.rules"`
                        WorkbenchesARules      string `yaml:"workbenches-alerting.rules"`
                        KserveRRules           string `yaml:"kserve-recording.rules"`
                        KserveARules           string `yaml:"kserve-alerting.rules"`
                        TrustyAIRRules         string `yaml:"trustyai-recording.rules"`
                        TrustyAIARules         string `yaml:"trustyai-alerting.rules"`
                        KueueRRules            string `yaml:"kueue-recording.rules"`
                        KueueARules            string `yaml:"kueue-alerting.rules"`
                        TrainingOperatorRRules string `yaml:"trainingoperator-recording.rules"`
                        TrainingOperatorARules string `yaml:"trainingoperator-alerting.rules"`
                        ModelRegistryRRules    string `yaml:"model-registry-operator-recording.rules"`
                        ModelRegistryARules    string `yaml:"model-registry-operator-alerting.rules"`
                        FeastOperatorRRules    string `yaml:"feastoperator-recording.rules"`
                        FeastOperatorARules    string `yaml:"feastoperator-alerting.rules"`
                        LLSRRules              string `yaml:"llama-stack-k8s-operator-recording.rules"`
                        LLSARules              string `yaml:"llama-stack-k8s-operator-alerting.rules"`
                } `yaml:"data"`
        }

        var configMap ConfigMap
        // prometheusContent will represent content of prometheus.yml due to its dynamic struct
        var prometheusContent map[interface{}]interface{}

        // read prometheus.yml from local disk /opt/mainfests/monitoring/prometheus/apps/
        yamlData, err := os.ReadFile(prometheusConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := yaml.Unmarshal(yamlData, &amp;configMap); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // get prometheus.yml part from configmap
        <span class="cov0" title="0">if err := yaml.Unmarshal([]byte(configMap.Data.PrometheusYML), &amp;prometheusContent); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // to add component rules when it is not there yet
        <span class="cov0" title="0">if enable </span><span class="cov0" title="0">{
                // Check if the rule not yet exists in rule_files
                if !strings.Contains(configMap.Data.PrometheusYML, component+"*.rules") </span><span class="cov0" title="0">{
                        // check if have rule_files
                        if ruleFiles, ok := prometheusContent["rule_files"]; ok </span><span class="cov0" title="0">{
                                if ruleList, isList := ruleFiles.([]interface{}); isList </span><span class="cov0" title="0">{
                                        // add new component rules back to rule_files
                                        ruleList = append(ruleList, component+"*.rules")
                                        prometheusContent["rule_files"] = ruleList
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> { // to remove component rules if it is there
                l.Info("Removing prometheus rule: " + component + "*.rules")
                if ruleList, ok := prometheusContent["rule_files"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for i, item := range ruleList </span><span class="cov0" title="0">{
                                if rule, isStr := item.(string); isStr &amp;&amp; rule == component+"*.rules" </span><span class="cov0" title="0">{
                                        ruleList = append(ruleList[:i], ruleList[i+1:]...)

                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">prometheusContent["rule_files"] = ruleList</span>
                }
        }

        // Marshal back
        <span class="cov0" title="0">newDataYAML, err := yaml.Marshal(&amp;prometheusContent)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">configMap.Data.PrometheusYML = string(newDataYAML)

        newyamlData, err := yaml.Marshal(&amp;configMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write the modified content back to the file
        <span class="cov0" title="0">err = os.WriteFile(prometheusConfigPath, newyamlData, 0)

        return err</span>
}

func isComponentReady(ctx context.Context, cli client.Client, obj common.PlatformObject) (bool, error) <span class="cov0" title="0">{
        err := cli.Get(ctx, client.ObjectKeyFromObject(obj), obj)
        switch </span>{
        case k8serr.IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("failed to get component instance: %w", err)</span>
        default:<span class="cov0" title="0">
                return conditions.IsStatusConditionTrue(obj.GetStatus(), status.ConditionTypeReady), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file66" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package monitoring

import (
        "context"
        "errors"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        routev1 "github.com/openshift/api/route/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        sr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/gc"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render/template"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/status/deployments"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/reconciler"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
)

//nolint:gochecknoinits
func init() <span class="cov8" title="1">{
        sr.Add(&amp;serviceHandler{})
}</span>

type serviceHandler struct {
}

func (h *serviceHandler) Init(_ common.Platform) error <span class="cov0" title="0">{
        return nil
}</span>

func (h *serviceHandler) GetName() string <span class="cov0" title="0">{
        return ServiceName
}</span>

func (h *serviceHandler) GetManagementState(platform common.Platform, dsci *dsciv1.DSCInitialization) operatorv1.ManagementState <span class="cov0" title="0">{
        // Managed cluster must have monitoring enabled even if user manually turns it off
        if platform == cluster.ManagedRhoai </span><span class="cov0" title="0">{
                return operatorv1.Managed
        }</span>

        // If DSCI exists, use its monitoring configuration
        <span class="cov0" title="0">if dsci != nil </span><span class="cov0" title="0">{
                return dsci.Spec.Monitoring.ManagementState
        }</span>

        <span class="cov0" title="0">return operatorv1.Unmanaged</span>
}

// monitoringNamespace returns the namespace where monitoring resources should be deployed.
func monitoringNamespace(_ context.Context, rr *odhtypes.ReconciliationRequest) (string, error) <span class="cov0" title="0">{
        m, ok := rr.Instance.(*serviceApi.Monitoring)
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("instance is not of type *services.Monitoring")
        }</span>

        <span class="cov0" title="0">return m.Spec.Namespace, nil</span>
}

func (h *serviceHandler) NewReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        _, err := reconciler.ReconcilerFor(mgr, &amp;serviceApi.Monitoring{}).
                Owns(&amp;rbacv1.Role{}).
                Owns(&amp;rbacv1.RoleBinding{}).
                // operands - openshift
                Owns(&amp;routev1.Route{}).
                // operands - owned dynmically depends on external operators are installed for monitoring
                // TODO: add more here later when enable other operator
                OwnsGVK(gvk.MonitoringStack, reconciler.Dynamic(reconciler.CrdExists(gvk.MonitoringStack))).
                OwnsGVK(gvk.TempoMonolithic, reconciler.Dynamic(reconciler.CrdExists(gvk.TempoMonolithic))).
                OwnsGVK(gvk.TempoStack, reconciler.Dynamic(reconciler.CrdExists(gvk.TempoStack))).
                OwnsGVK(gvk.Instrumentation, reconciler.Dynamic(reconciler.CrdExists(gvk.Instrumentation))).
                OwnsGVK(gvk.OpenTelemetryCollector, reconciler.Dynamic(reconciler.CrdExists(gvk.OpenTelemetryCollector))).
                OwnsGVK(gvk.ServiceMonitor, reconciler.Dynamic(reconciler.CrdExists(gvk.ServiceMonitor))).
                OwnsGVK(gvk.PrometheusRule, reconciler.Dynamic(reconciler.CrdExists(gvk.PrometheusRule))).
                // operands - watched
                //
                // By default the Watches functions adds:
                // - an event handler mapping to a cluster scope resource identified by the
                //   components.platform.opendatahub.io/part-of annotation
                // - a predicate that check for generation change for Delete/Updates events
                //   for to objects that have the label components.platform.opendatahub.io/part-of
                // or services.platform.opendatahub.io/part-of set to the current owner
                //
                Watches(
                        &amp;dscv1.DataScienceCluster{},
                        reconciler.WithEventHandler(handlers.ToNamed(serviceApi.MonitoringInstanceName)),
                        reconciler.WithPredicates(resources.DSCComponentUpdatePredicate),
                ).
                // actions
                WithAction(deployments.NewAction(
                        deployments.InNamespaceFn(monitoringNamespace),
                )).
                Watches(
                        &amp;extv1.CustomResourceDefinition{},
                        reconciler.WithEventHandler(
                                handlers.ToNamed(serviceApi.MonitoringInstanceName)),
                ).
                // These are only for SRE Monitoring
                WithAction(initialize).
                WithAction(updatePrometheusConfigMap).
                // These are only for new monitoring stack dependent Operators
                WithAction(addMonitoringCapability).
                WithAction(deployMonitoringStack).
                WithAction(deployAlerting).
                WithAction(deployTempo).
                WithAction(deployOpenTelemetryCollector).
                WithAction(deployInstrumentation).
                WithAction(template.NewAction(
                        template.WithDataFn(getTemplateData),
                )).
                WithAction(deploy.NewAction(
                        deploy.WithCache(),
                )).
                WithAction(gc.NewAction()).
                Build(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create the monitoring controller: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package monitoring

import (
        "context"
        "embed"
        "errors"
        "fmt"

        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        cr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/registry"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
)

const (
        // Template files.
        MonitoringStackTemplate          = "resources/monitoring-stack.tmpl.yaml"
        TempoMonolithicTemplate          = "resources/tempo-monolithic.tmpl.yaml"
        TempoStackTemplate               = "resources/tempo-stack.tmpl.yaml"
        OpenTelemetryCollectorTemplate   = "resources/opentelemetry-collector.tmpl.yaml"
        CollectorServiceMonitorsTemplate = "resources/collector-servicemonitors.tmpl.yaml"
        CollectorRBACTemplate            = "resources/collector-rbac.tmpl.yaml"
        PrometheusRouteTemplate          = "resources/prometheus-route.tmpl.yaml"
        InstrumentationTemplate          = "resources/instrumentation.tmpl.yaml"
)

var componentRules = map[string]string{
        componentApi.DashboardComponentName:            "rhods-dashboard",
        componentApi.WorkbenchesComponentName:          "workbenches",
        componentApi.KueueComponentName:                "kueue",
        componentApi.CodeFlareComponentName:            "codeflare",
        componentApi.DataSciencePipelinesComponentName: "data-science-pipelines-operator",
        componentApi.ModelMeshServingComponentName:     "model-mesh",
        componentApi.RayComponentName:                  "ray",
        componentApi.TrustyAIComponentName:             "trustyai",
        componentApi.KserveComponentName:               "kserve",
        componentApi.TrainingOperatorComponentName:     "trainingoperator",
        componentApi.ModelRegistryComponentName:        "model-registry-operator",
        componentApi.ModelControllerComponentName:      "odh-model-controller",
        componentApi.FeastOperatorComponentName:        "feastoperator",
        componentApi.LlamaStackOperatorComponentName:   "llamastackoperator",
}

//go:embed resources
//go:embed monitoring
var resourcesFS embed.FS

// initialize handles all pre-deployment configurations.
func initialize(_ context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        // Only set prometheus configmap path
        rr.Manifests = []odhtypes.ManifestInfo{
                {
                        Path:       odhdeploy.DefaultManifestPath,
                        ContextDir: "monitoring/prometheus/apps",
                },
        }

        return nil
}</span>

// if DSC has component as Removed, we remove component's Prom Rules.
// only when DSC has component as Managed and component CR is in "Ready" state, we add rules to Prom Rules.
// all other cases, we do not change Prom rules for component.
func updatePrometheusConfigMap(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        // Skip update prom config: if cluster is NOT ManagedRhoai
        if rr.Release.Name != cluster.ManagedRhoai </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Map component names to their rule prefixes
        <span class="cov0" title="0">dsc, err := cluster.GetDSC(ctx, rr.Client)
        if err != nil </span><span class="cov0" title="0">{
                if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        // DSC doesn't exist, skip prometheus configmap update
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to retrieve DataScienceCluster: %w", err)</span>
        }

        <span class="cov0" title="0">return cr.ForEach(func(ch cr.ComponentHandler) error </span><span class="cov0" title="0">{
                ci := ch.NewCRObject(dsc)
                if ch.IsEnabled(dsc) </span><span class="cov0" title="0">{
                        ready, err := isComponentReady(ctx, rr.Client, ci)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get component status %w", err)
                        }</span>
                        <span class="cov0" title="0">if !ready </span><span class="cov0" title="0">{ // not ready, skip change on prom rules
                                return nil
                        }</span>
                        // add
                        <span class="cov0" title="0">return updatePrometheusConfig(ctx, true, componentRules[ch.GetName()])</span>
                } else<span class="cov0" title="0"> {
                        return updatePrometheusConfig(ctx, false, componentRules[ch.GetName()])
                }</span>
        })
}

func deployMonitoringStack(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        monitoring, ok := rr.Instance.(*serviceApi.Monitoring)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("instance is not of type *services.Monitoring")
        }</span>

        // No monitoring stack configuration
        <span class="cov0" title="0">if monitoring.Spec.Metrics == nil </span><span class="cov0" title="0">{
                rr.Conditions.MarkFalse(
                        status.ConditionMonitoringStackAvailable,
                        conditions.WithReason(status.MetricsNotConfiguredReason),
                        conditions.WithMessage(status.MetricsNotConfiguredMessage),
                )
                return nil
        }</span>

        <span class="cov0" title="0">msExists, err := cluster.HasCRD(ctx, rr.Client, gvk.MonitoringStack)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if CRD MonitoringStack exists: %w", err)
        }</span>
        <span class="cov0" title="0">if !msExists </span><span class="cov0" title="0">{
                // CRD not available, skip monitoring stack deployment (this is expected when monitoring stack operator is not installed)
                rr.Conditions.MarkFalse(
                        status.ConditionMonitoringStackAvailable,
                        conditions.WithReason(gvk.MonitoringStack.Kind+"CRDNotFoundReason"),
                        conditions.WithMessage("%s CRD Not Found", gvk.MonitoringStack.Kind),
                )
                return nil
        }</span>

        <span class="cov0" title="0">rr.Conditions.MarkTrue(status.ConditionMonitoringStackAvailable)

        template := []odhtypes.TemplateInfo{
                {
                        FS:   resourcesFS,
                        Path: MonitoringStackTemplate,
                },
                {
                        FS:   resourcesFS,
                        Path: PrometheusRouteTemplate,
                },
        }

        rr.Templates = append(rr.Templates, template...)

        return nil</span>
}

func deployOpenTelemetryCollector(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        monitoring, ok := rr.Instance.(*serviceApi.Monitoring)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("instance is not of type *services.Monitoring")
        }</span>

        // Read metrics and traces configuration directly from Monitoring CR
        <span class="cov0" title="0">if monitoring.Spec.Metrics == nil &amp;&amp; monitoring.Spec.Traces == nil </span><span class="cov0" title="0">{
                // No metrics and traces configuration - skip OpenTelemetry collector deployment
                rr.Conditions.MarkFalse(
                        status.ConditionOpenTelemetryCollectorAvailable,
                        conditions.WithReason(status.MetricsNotConfiguredReason+"And"+status.TracesNotConfiguredReason),
                        conditions.WithMessage(status.MetricsNotConfiguredMessage+"\n"+status.TracesNotConfiguredMessage),
                )
                return nil
        }</span>

        <span class="cov0" title="0">otcExists, err := cluster.HasCRD(ctx, rr.Client, gvk.OpenTelemetryCollector)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if CRD OpenTelemetryCollector exists: %w", err)
        }</span>
        <span class="cov0" title="0">if !otcExists </span><span class="cov0" title="0">{
                rr.Conditions.MarkFalse(
                        status.ConditionOpenTelemetryCollectorAvailable,
                        conditions.WithReason(gvk.OpenTelemetryCollector.Kind+"CRDNotFoundReason"),
                        conditions.WithMessage("%s CRD Not Found", gvk.OpenTelemetryCollector.Kind),
                )
                return nil
        }</span>

        // Mark OpenTelemetryCollector CRD as available when CRD exists
        <span class="cov0" title="0">rr.Conditions.MarkTrue(
                status.ConditionOpenTelemetryCollectorAvailable,
        )

        template := []odhtypes.TemplateInfo{
                {
                        FS:   resourcesFS,
                        Path: OpenTelemetryCollectorTemplate,
                },
                {
                        FS:   resourcesFS,
                        Path: CollectorRBACTemplate,
                },
                {
                        FS:   resourcesFS,
                        Path: CollectorServiceMonitorsTemplate,
                },
        }
        rr.Templates = append(rr.Templates, template...)

        return nil</span>
}

// deployTempo creates Tempo resources based on the Monitoring CR configuration.
func deployTempo(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        monitoring, ok := rr.Instance.(*serviceApi.Monitoring)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("instance is not of type *services.Monitoring")
        }</span>

        // Read traces configuration directly from Monitoring CR
        <span class="cov0" title="0">if monitoring.Spec.Traces == nil </span><span class="cov0" title="0">{
                // No traces configuration - GC action will clean up any existing Tempo resources
                rr.Conditions.MarkFalse(
                        status.ConditionTempoAvailable,
                        conditions.WithReason(status.TracesNotConfiguredReason),
                        conditions.WithMessage(status.TracesNotConfiguredMessage),
                )
                return nil
        }</span>

        <span class="cov0" title="0">traces := monitoring.Spec.Traces

        var requiredCRD schema.GroupVersionKind
        var templatePath string
        if traces.Storage.Backend == "pv" </span><span class="cov0" title="0">{
                requiredCRD = gvk.TempoMonolithic
                templatePath = TempoMonolithicTemplate
        }</span> else<span class="cov0" title="0"> {
                requiredCRD = gvk.TempoStack
                templatePath = TempoStackTemplate
        }</span>

        <span class="cov0" title="0">crdExists, err := cluster.HasCRD(ctx, rr.Client, requiredCRD)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if CRD exists: %w", err)
        }</span>
        <span class="cov0" title="0">if !crdExists </span><span class="cov0" title="0">{
                // CRD not available, skip tempo deployment (this is expected when tempo operator is not installed)
                rr.Conditions.MarkFalse(
                        status.ConditionTempoAvailable,
                        conditions.WithReason(requiredCRD.Kind+"CRDNotFoundReason"),
                        conditions.WithMessage("%s CRD Not Found", requiredCRD.Kind),
                )
                return nil
        }</span>

        <span class="cov0" title="0">rr.Conditions.MarkTrue(status.ConditionTempoAvailable)

        template := []odhtypes.TemplateInfo{
                {
                        FS:   resourcesFS,
                        Path: templatePath,
                },
        }
        rr.Templates = append(rr.Templates, template...)

        return nil</span>
}

// deployInstrumentation manages OpenTelemetry Instrumentation CRs using templates.
func deployInstrumentation(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        monitoring, ok := rr.Instance.(*serviceApi.Monitoring)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("instance is not of type *serviceApi.Monitoring")
        }</span>

        // Only create instrumentation CR if traces are configured
        <span class="cov0" title="0">if monitoring.Spec.Traces == nil </span><span class="cov0" title="0">{
                // If traces are not configured, GC will clean up any existing instrumentation CRs
                rr.Conditions.MarkFalse(
                        status.ConditionInstrumentationAvailable,
                        conditions.WithReason(status.TracesNotConfiguredReason),
                        conditions.WithMessage(status.TracesNotConfiguredMessage),
                )
                return nil
        }</span>

        // Traces are configured, check if Instrumentation CRD exists before creating the template
        <span class="cov0" title="0">instrumentationCRDExists, err := cluster.HasCRD(ctx, rr.Client, gvk.Instrumentation)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if Instrumentation CRD exists: %w", err)
        }</span>
        <span class="cov0" title="0">if !instrumentationCRDExists </span><span class="cov0" title="0">{
                rr.Conditions.MarkFalse(
                        status.ConditionInstrumentationAvailable,
                        conditions.WithReason(gvk.Instrumentation.Kind+"CRDNotFoundReason"),
                        conditions.WithMessage("%s CRD Not Found", gvk.Instrumentation.Kind),
                )
                return nil
        }</span>

        <span class="cov0" title="0">rr.Conditions.MarkTrue(status.ConditionInstrumentationAvailable)

        // Add instrumentation template to be rendered
        template := []odhtypes.TemplateInfo{
                {
                        FS:   resourcesFS,
                        Path: InstrumentationTemplate,
                },
        }
        rr.Templates = append(rr.Templates, template...)

        return nil</span>
}

func deployAlerting(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        monitoring, ok := rr.Instance.(*serviceApi.Monitoring)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("instance is not of type *services.Monitoring")
        }</span>

        <span class="cov0" title="0">if monitoring.Spec.Alerting == nil </span><span class="cov0" title="0">{
                rr.Conditions.MarkFalse(
                        status.ConditionAlertingAvailable,
                        conditions.WithReason(status.AlertingNotConfiguredReason),
                        conditions.WithMessage(status.AlertingNotConfiguredMessage),
                )
                return nil
        }</span>

        // Check required CRD for alerting
        <span class="cov0" title="0">exists, err := cluster.HasCRD(ctx, rr.Client, gvk.PrometheusRule)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if %s CRD exists: %w", gvk.PrometheusRule.Kind, err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                rr.Conditions.MarkFalse(
                        status.ConditionAlertingAvailable,
                        conditions.WithReason(gvk.PrometheusRule.Kind+"CRDNotFoundReason"),
                        conditions.WithMessage("%s CRD Not Found", gvk.PrometheusRule.Kind),
                )
                return nil
        }</span>

        <span class="cov0" title="0">rr.Conditions.MarkTrue(status.ConditionAlertingAvailable)
        // Add operator prometheus rules, we can deploy operator alerts without any components
        templates := []odhtypes.TemplateInfo{
                {
                        FS:   resourcesFS,
                        Path: "monitoring/operator-prometheusrules.tmpl.yaml",
                },
        }
        rr.Templates = append(rr.Templates, templates...)

        dsc, err := cluster.GetDSC(ctx, rr.Client)
        if err != nil </span><span class="cov0" title="0">{
                if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        // DSC doesn't exist
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to retrieve DataScienceCluster: %w", err)</span>
        }

        // Add component prometheus rules for each enabled and ready component.
        // Collect errors for each component and report them at the end.
        // Component A could succeed, component B could fail and component C could succeed.
        // Log which components actually failed rather than just bailing out early.
        <span class="cov0" title="0">var addErrors []error
        var cleanupErrors []error

        forEachErr := cr.ForEach(func(ch cr.ComponentHandler) error </span><span class="cov0" title="0">{
                componentName := ch.GetName()
                ci := ch.NewCRObject(dsc)

                if ch.IsEnabled(dsc) </span><span class="cov0" title="0">{
                        ready, err := isComponentReady(ctx, rr.Client, ci)
                        if err != nil </span><span class="cov0" title="0">{
                                addErrors = append(addErrors, fmt.Errorf("failed to get status for component %s: %w", componentName, err))
                                return nil // Continue processing other components
                        }</span>
                        <span class="cov0" title="0">if !ready </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        // component is ready, add alerting rules
                        <span class="cov0" title="0">if err := addPrometheusRules(componentName, rr); err != nil </span><span class="cov0" title="0">{
                                addErrors = append(addErrors, fmt.Errorf("failed to add prometheus rules for component %s: %w", componentName, err))
                                return nil // Continue processing other components
                        }</span>
                } else<span class="cov0" title="0"> {
                        // component is not enabled, check if prometheus rules exist and cleanup if they do
                        if err := cleanupPrometheusRules(ctx, componentName, rr); err != nil </span><span class="cov0" title="0">{
                                cleanupErrors = append(cleanupErrors, fmt.Errorf("failed to cleanup prometheus rules for component %s: %w", componentName, err))
                                return nil // Continue processing other components
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })

        // Handle registry iteration errors separately - something is wrong with the component registry itself
        <span class="cov0" title="0">if forEachErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to iterate components: %w", forEachErr)
        }</span>

        // If we fail to add prometheus rules for a component.
        <span class="cov0" title="0">if len(addErrors) &gt; 0 </span><span class="cov0" title="0">{
                // Log errors but don't fail the reconciliation
                for _, addErr := range addErrors </span><span class="cov0" title="0">{
                        logf.FromContext(ctx).Error(addErr, "Failed to add prometheus rules for component")
                }</span>
        }

        // If we fail to clean up prometheus rules for a component.
        <span class="cov0" title="0">if len(cleanupErrors) &gt; 0 </span><span class="cov0" title="0">{
                // Log errors but don't fail the reconciliation
                for _, cleanupErr := range cleanupErrors </span><span class="cov0" title="0">{
                        logf.FromContext(ctx).Error(cleanupErr, "Failed to cleanup prometheus rules for component")
                }</span>
        }

        <span class="cov0" title="0">if len(addErrors) &gt; 0 || len(cleanupErrors) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("errors occurred while adding or cleaning up prometheus rules for components")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package monitoring

import (
        "context"
        "errors"
        "fmt"
        "strconv"

        "github.com/hashicorp/go-multierror"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        componentMonitoring "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/common"
        odherrors "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/errors"
        cond "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        odhtypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
)

const (
        // Dependent operators names. match the one in the operatorcondition..
        opentelemetryOperator        = "opentelemetry-operator"
        clusterObservabilityOperator = "cluster-observability-operator"
        tempoOperator                = "tempo-operator"
)

func getTemplateData(ctx context.Context, rr *odhtypes.ReconciliationRequest) (map[string]any, error) <span class="cov8" title="1">{
        monitoring, ok := rr.Instance.(*serviceApi.Monitoring)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("instance is not of type services.Monitoring")
        }</span>

        <span class="cov8" title="1">templateData := map[string]any{
                "Namespace": monitoring.Spec.Namespace,
        }

        templateData["Traces"] = monitoring.Spec.Traces != nil
        templateData["Metrics"] = monitoring.Spec.Metrics != nil
        templateData["AcceleratorMetrics"] = monitoring.Spec.Metrics != nil
        templateData["ApplicationNamespace"] = rr.DSCI.Spec.ApplicationsNamespace

        if metrics := monitoring.Spec.Metrics; metrics != nil </span><span class="cov8" title="1">{
                // Handle Resources fields - provide defaults if Resources is nil
                if metrics.Resources != nil </span><span class="cov8" title="1">{
                        cpuLimit := metrics.Resources.CPULimit.String()
                        if cpuLimit == "" || cpuLimit == "0" </span><span class="cov8" title="1">{
                                cpuLimit = "500m"
                        }</span>
                        <span class="cov8" title="1">templateData["CPULimit"] = cpuLimit

                        memoryLimit := metrics.Resources.MemoryLimit.String()
                        if memoryLimit == "" || memoryLimit == "0" </span><span class="cov8" title="1">{
                                memoryLimit = "512Mi"
                        }</span>
                        <span class="cov8" title="1">templateData["MemoryLimit"] = memoryLimit

                        cpuRequest := metrics.Resources.CPURequest.String()
                        if cpuRequest == "" || cpuRequest == "0" </span><span class="cov8" title="1">{
                                cpuRequest = "100m"
                        }</span>
                        <span class="cov8" title="1">templateData["CPURequest"] = cpuRequest

                        memoryRequest := metrics.Resources.MemoryRequest.String()
                        if memoryRequest == "" || memoryRequest == "0" </span><span class="cov8" title="1">{
                                memoryRequest = "256Mi"
                        }</span>
                        <span class="cov8" title="1">templateData["MemoryRequest"] = memoryRequest</span>
                } else<span class="cov8" title="1"> {
                        // Use defaults when Resources is nil
                        templateData["CPULimit"] = "500m"
                        templateData["MemoryLimit"] = "512Mi"
                        templateData["CPURequest"] = "100m"
                        templateData["MemoryRequest"] = "256Mi"
                }</span>

                // Handle Storage fields - provide defaults if Storage is nil
                <span class="cov8" title="1">if metrics.Storage != nil </span><span class="cov8" title="1">{
                        storageSize := metrics.Storage.Size.String()
                        if storageSize == "" || storageSize == "0" </span><span class="cov8" title="1">{
                                storageSize = "5Gi"
                        }</span>
                        <span class="cov8" title="1">templateData["StorageSize"] = storageSize

                        retention := metrics.Storage.Retention
                        if retention == "" </span><span class="cov0" title="0">{
                                retention = "90d"
                        }</span>
                        <span class="cov8" title="1">templateData["StorageRetention"] = retention</span>
                } else<span class="cov8" title="1"> {
                        // Use defaults when Storage is nil
                        templateData["StorageSize"] = "5Gi"
                        templateData["StorageRetention"] = "90d"
                }</span>

                // only when either storage or resources is set, we take replicas into account
                // - if user did not set it / zero-value "0", we use default value of 2
                // - if user set it to Y, we pass Y to template
                <span class="cov8" title="1">var replicas int32 = 2 // default value to match monitoringstack CRD's default
                if (metrics.Storage != nil || metrics.Resources != nil) &amp;&amp; metrics.Replicas != 0 </span><span class="cov8" title="1">{
                        replicas = metrics.Replicas
                }</span>
                <span class="cov8" title="1">templateData["Replicas"] = strconv.Itoa(int(replicas))</span>
        }

        // Add traces-related data if traces are configured
        <span class="cov8" title="1">if traces := monitoring.Spec.Traces; traces != nil </span><span class="cov0" title="0">{
                templateData["OtlpEndpoint"] = fmt.Sprintf("http://data-science-collector.%s.svc.cluster.local:4317", monitoring.Spec.Namespace)
                templateData["SampleRatio"] = traces.SampleRatio
                templateData["Backend"] = traces.Storage.Backend // backend has default "pv" set in API

                // Add retention for all backends (both TempoMonolithic and TempoStack)
                templateData["TracesRetention"] = traces.Storage.Retention.Duration.String()

                // Add tempo-related data from traces.Storage fields (Storage is a struct, not a pointer)
                switch traces.Storage.Backend </span>{
                case "pv":<span class="cov0" title="0">
                        templateData["TempoEndpoint"] = fmt.Sprintf("tempo-data-science-tempomonolithic.%s.svc.cluster.local:4317", monitoring.Spec.Namespace)
                        templateData["Size"] = traces.Storage.Size</span>
                case "s3", "gcs":<span class="cov0" title="0">
                        templateData["TempoEndpoint"] = fmt.Sprintf("tempo-data-science-tempostack-gateway.%s.svc.cluster.local:4317", monitoring.Spec.Namespace)
                        templateData["Secret"] = traces.Storage.Secret</span>
                }
        }

        <span class="cov8" title="1">return templateData, nil</span>
}

func addMonitoringCapability(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)

        // Set initial condition state
        rr.Conditions.MarkUnknown(status.ConditionMonitoringAvailable)

        if err := checkMonitoringPreconditions(ctx, rr); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Monitoring preconditions failed")

                rr.Conditions.MarkFalse(
                        status.ConditionMonitoringAvailable,
                        cond.WithReason(status.MissingOperatorReason),
                        cond.WithMessage("Monitoring preconditions failed: %s", err.Error()),
                )

                return err
        }</span>

        <span class="cov0" title="0">rr.Conditions.MarkTrue(status.ConditionMonitoringAvailable)

        return nil</span>
}

func checkMonitoringPreconditions(ctx context.Context, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        monitoring, ok := rr.Instance.(*serviceApi.Monitoring)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("instance is not of type services.Monitoring")
        }</span>
        <span class="cov0" title="0">var allErrors *multierror.Error

        // Check for opentelemetry-product operator if either metrics or traces are enabled
        if monitoring.Spec.Metrics != nil || monitoring.Spec.Traces != nil </span><span class="cov0" title="0">{
                if found, err := cluster.OperatorExists(ctx, rr.Client, opentelemetryOperator); err != nil || !found </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return odherrors.NewStopErrorW(err)
                        }</span>
                        <span class="cov0" title="0">allErrors = multierror.Append(allErrors, odherrors.NewStopError(status.OpenTelemetryCollectorOperatorMissingMessage))</span>
                }
        }

        // Check for cluster-observability-operator if metrics are enabled
        <span class="cov0" title="0">if monitoring.Spec.Metrics != nil </span><span class="cov0" title="0">{
                if found, err := cluster.OperatorExists(ctx, rr.Client, clusterObservabilityOperator); err != nil || !found </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return odherrors.NewStopErrorW(err)
                        }</span>
                        <span class="cov0" title="0">allErrors = multierror.Append(allErrors, odherrors.NewStopError(status.COOMissingMessage))</span>
                }
        }

        // Check for tempo-product operator if traces are enabled
        <span class="cov0" title="0">if monitoring.Spec.Traces != nil </span><span class="cov0" title="0">{
                if found, err := cluster.OperatorExists(ctx, rr.Client, tempoOperator); err != nil || !found </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return odherrors.NewStopErrorW(err)
                        }</span>
                        <span class="cov0" title="0">allErrors = multierror.Append(allErrors, odherrors.NewStopError(status.TempoOperatorMissingMessage))</span>
                }
        }

        <span class="cov0" title="0">return allErrors.ErrorOrNil()</span>
}

func addPrometheusRules(componentName string, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        componentRules := fmt.Sprintf("%s/monitoring/%s-prometheusrules.tmpl.yaml", componentName, componentName)

        if !common.FileExists(componentMonitoring.ComponentRulesFS, componentRules) </span><span class="cov0" title="0">{
                return fmt.Errorf("prometheus rules file for component %s not found", componentName)
        }</span>

        <span class="cov0" title="0">rr.Templates = append(rr.Templates, odhtypes.TemplateInfo{
                FS:   componentMonitoring.ComponentRulesFS,
                Path: componentRules,
        })

        return nil</span>
}

// if a component is disabled, we need to delete the prometheus rules. If the DSCI is deleted
// the rules will be gc'd automatically.
func cleanupPrometheusRules(ctx context.Context, componentName string, rr *odhtypes.ReconciliationRequest) error <span class="cov0" title="0">{
        pr := &amp;unstructured.Unstructured{}
        pr.SetGroupVersionKind(gvk.PrometheusRule)
        pr.SetName(fmt.Sprintf("%s-prometheusrules", componentName))
        pr.SetNamespace(rr.DSCI.Spec.Monitoring.Namespace)

        if err := rr.Client.Delete(ctx, pr); err != nil </span><span class="cov0" title="0">{
                if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to delete prometheus rule for component %s: %w", componentName, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package secretgenerator

import (
        "crypto/rand"
        "encoding/base64"
        "errors"
        "math/big"
        "strconv"

        annotation "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

//nolint:golint,stylecheck //CAPS is preferred for const
const (
        SECRET_DEFAULT_COMPLEXITY = 16

        letterRunes = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

        errEmptyAnnotation        = "secret annotations is empty"
        errNameAnnotationNotFound = "name annotation not found in secret"
        errTypeAnnotationNotFound = "type annotation not found in secret"
        errUnsupportedType        = "secret type is not supported"
)

type Secret struct {
        Name             string
        Type             string
        Complexity       int
        Value            string
        OAuthClientRoute string
}

func NewSecretFrom(annotations map[string]string) (*Secret, error) <span class="cov8" title="1">{
        // Check if annotations is not empty
        if len(annotations) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New(errEmptyAnnotation)
        }</span>

        <span class="cov8" title="1">var secret Secret

        // Get name from annotation
        if secretName, found := annotations[annotation.SecretNameAnnotation]; found </span><span class="cov8" title="1">{
                secret.Name = secretName
        }</span> else<span class="cov8" title="1"> {
                return nil, errors.New(errNameAnnotationNotFound)
        }</span>

        // Get type from annotation
        <span class="cov8" title="1">if secretType, found := annotations[annotation.SecretTypeAnnotation]; found </span><span class="cov8" title="1">{
                secret.Type = secretType
        }</span> else<span class="cov8" title="1"> {
                return nil, errors.New(errTypeAnnotationNotFound)
        }</span>

        // Get complexity from annotation
        <span class="cov8" title="1">if secretComplexity, found := annotations[annotation.SecretLengthAnnotation]; found </span><span class="cov8" title="1">{
                secretComplexity, err := strconv.Atoi(secretComplexity)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">secret.Complexity = secretComplexity</span>
        } else<span class="cov8" title="1"> {
                secret.Complexity = SECRET_DEFAULT_COMPLEXITY
        }</span>

        <span class="cov8" title="1">if secretOAuthClientRoute, found := annotations[annotation.SecretOauthClientAnnotation]; found </span><span class="cov0" title="0">{
                secret.OAuthClientRoute = secretOAuthClientRoute
        }</span>

        <span class="cov8" title="1">if err := generateSecretValue(&amp;secret); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;secret, nil</span>
}

func NewSecret(name, secretType string, complexity int) (*Secret, error) <span class="cov8" title="1">{
        secret := &amp;Secret{
                Name:       name,
                Type:       secretType,
                Complexity: complexity,
        }

        err := generateSecretValue(secret)

        return secret, err
}</span>

func generateSecretValue(secret *Secret) error <span class="cov8" title="1">{
        switch secret.Type </span>{
        case "random":<span class="cov8" title="1">
                randomValue := make([]byte, secret.Complexity)
                for i := range secret.Complexity </span><span class="cov8" title="1">{
                        num, err := rand.Int(rand.Reader, big.NewInt(int64(len(letterRunes))))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">randomValue[i] = letterRunes[num.Int64()]</span>
                }
                <span class="cov8" title="1">secret.Value = string(randomValue)</span>
        case "oauth":<span class="cov8" title="1">
                randomValue := make([]byte, secret.Complexity)
                if _, err := rand.Read(randomValue); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">secret.Value = base64.StdEncoding.EncodeToString(
                        []byte(base64.StdEncoding.EncodeToString(randomValue)))</span>
        default:<span class="cov8" title="1">
                return errors.New(errUnsupportedType)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package secretgenerator

import (
        "context"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        ctrl "sigs.k8s.io/controller-runtime"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        sr "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/services/registry"
)

const (
        ServiceName = "secretgenerator"
)

//nolint:gochecknoinits
func init() <span class="cov8" title="1">{
        sr.Add(&amp;serviceHandler{})
}</span>

type serviceHandler struct {
}

func (h *serviceHandler) Init(_ common.Platform) error <span class="cov0" title="0">{
        return nil
}</span>

func (h *serviceHandler) GetName() string <span class="cov0" title="0">{
        return ServiceName
}</span>

func (h *serviceHandler) GetManagementState(_ common.Platform, _ *dsciv1.DSCInitialization) operatorv1.ManagementState <span class="cov0" title="0">{
        return operatorv1.Managed
}</span>

func (h *serviceHandler) NewReconciler(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        rec := &amp;SecretGeneratorReconciler{
                Client: mgr.GetClient(),
        }

        if err := rec.SetupWithManager(ctx, mgr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create the %s controller: %w", ServiceName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package secretgenerator contains generator logic of secret resources used in Open Data Hub operator
package secretgenerator

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        oauthv1 "github.com/openshift/api/oauth/v1"
        routev1 "github.com/openshift/api/route/v1"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/wait"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        annotation "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

const (
        resourceRetryInterval = 2 * time.Second
)

// SecretGeneratorReconciler holds the controller configuration.
type SecretGeneratorReconciler struct {
        Client client.Client
}

// SetupWithManager sets up the controller with the Manager.
func (r *SecretGeneratorReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager) error <span class="cov0" title="0">{
        logf.FromContext(ctx).Info("Adding controller for Secret Generation.")

        // Watch only new secrets with the corresponding annotation
        predicates := predicate.Funcs{
                CreateFunc: func(e event.CreateEvent) bool </span><span class="cov0" title="0">{
                        if _, found := e.Object.GetAnnotations()[annotation.SecretNameAnnotation]; found </span><span class="cov0" title="0">{
                                return true
                        }</span>

                        <span class="cov0" title="0">return false</span>
                },
                GenericFunc: func(e event.GenericEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
                // this only watch for secret deletion if has with annotation
                // e.g. dashboard-oauth-client but not dashboard-oauth-client-generated
                DeleteFunc: func(e event.DeleteEvent) bool <span class="cov0" title="0">{
                        if _, found := e.Object.GetAnnotations()[annotation.SecretNameAnnotation]; found </span><span class="cov0" title="0">{
                                return true
                        }</span>

                        <span class="cov0" title="0">return false</span>
                },
                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
        }

        <span class="cov0" title="0">secretBuilder := ctrl.NewControllerManagedBy(mgr).Named("secret-generator-controller")
        err := secretBuilder.For(&amp;corev1.Secret{}).
                Watches(
                        &amp;corev1.Secret{},
                        handler.EnqueueRequestsFromMapFunc(
                                func(_ context.Context, a client.Object) []reconcile.Request </span><span class="cov0" title="0">{
                                        namespacedName := types.NamespacedName{Name: a.GetName(), Namespace: a.GetNamespace()}
                                        return []reconcile.Request{{NamespacedName: namespacedName}}
                                }</span>,
                        ), builder.WithPredicates(predicates)).
                WithEventFilter(predicates).
                Complete(r)

        <span class="cov0" title="0">return err</span>
}

// Reconcile will generate new secret with random data for the annotated secret
// based on the specified type and complexity. This will avoid possible race
// conditions when a deployment mounts the secret before it is reconciled.
func (r *SecretGeneratorReconciler) Reconcile(ctx context.Context, request ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        foundSecret := &amp;corev1.Secret{}
        err := r.Client.Get(ctx, request.NamespacedName, foundSecret)
        if err != nil </span><span class="cov0" title="0">{
                if !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                // If Secret is deleted, delete OAuthClient if exists
                <span class="cov0" title="0">err = r.deleteOAuthClient(ctx, request.NamespacedName)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov0" title="0">return ctrl.Result{}, nil</span>
        }

        // Generate the secret if it does not previously exist
        <span class="cov0" title="0">generatedSecret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      foundSecret.Name + "-generated",
                        Namespace: foundSecret.Namespace,
                },
        }

        err = r.Client.Get(ctx, client.ObjectKeyFromObject(generatedSecret), generatedSecret)
        if err == nil || !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">err = r.generateSecret(ctx, foundSecret, generatedSecret)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Don't requeue if secret is created successfully
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

func (r *SecretGeneratorReconciler) generateSecret(ctx context.Context, foundSecret *corev1.Secret, generatedSecret *corev1.Secret) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx).WithName("SecretGenerator")

        // Generate secret random value
        log.Info("Generating a random value for a secret in a namespace",
                "secret", generatedSecret.Name, "namespace", generatedSecret.Namespace)

        generatedSecret.Labels = foundSecret.Labels

        generatedSecret.OwnerReferences = []metav1.OwnerReference{
                *metav1.NewControllerRef(foundSecret, foundSecret.GroupVersionKind()),
        }

        secret, err := NewSecretFrom(foundSecret.GetAnnotations())
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error creating secret %s in %s", generatedSecret.Name, generatedSecret.Namespace)
                return err
        }</span>

        <span class="cov0" title="0">generatedSecret.StringData = map[string]string{
                secret.Name: secret.Value,
        }

        err = r.Client.Create(ctx, generatedSecret)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Info("Done generating secret in namespace",
                "secret", generatedSecret.Name, "namespace", generatedSecret.Namespace)

        // check if annotation oauth-client-route exists
        if secret.OAuthClientRoute == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get OauthClient Route
        <span class="cov0" title="0">oauthClientRoute, err := r.getRoute(ctx, secret.OAuthClientRoute, foundSecret.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Unable to retrieve route from OAuthClient", "route-name", secret.OAuthClientRoute)
                return err
        }</span>

        // Generate OAuthClient for the generated secret
        <span class="cov0" title="0">log.Info("Generating an OAuthClient CR for route", "route-name", oauthClientRoute.Name)
        err = r.createOAuthClient(ctx, foundSecret.Name, secret.Value, oauthClientRoute.Spec.Host)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error creating oauth client resource. Recreate the Secret", "secret-name",
                        foundSecret.Name)

                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getRoute returns an OpenShift route object. It waits until the .spec.host value exists to avoid possible race conditions, fails otherwise.
func (r *SecretGeneratorReconciler) getRoute(ctx context.Context, name string, namespace string) (*routev1.Route, error) <span class="cov0" title="0">{
        route := &amp;routev1.Route{}
        // Get spec.host from route
        backoff := wait.Backoff{
                Duration: resourceRetryInterval,
                Factor:   2.0,
                Steps:    5,
        }
        // 1 minute timeout
        err := wait.ExponentialBackoffWithContext(ctx, backoff, func(ctx context.Context) (bool, error) </span><span class="cov0" title="0">{
                err := r.Client.Get(ctx, client.ObjectKey{
                        Name:      name,
                        Namespace: namespace,
                }, route)
                if err != nil </span><span class="cov0" title="0">{
                        return false, client.IgnoreNotFound(err)
                }</span>
                <span class="cov0" title="0">if route.Spec.Host == "" </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return true, nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return route, err</span>
}

func (r *SecretGeneratorReconciler) createOAuthClient(ctx context.Context, name string, secretName string, uri string) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        // Create OAuthClient resource
        oauthClient := &amp;oauthv1.OAuthClient{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "OAuthClient",
                        APIVersion: "oauth.openshift.io/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Secret:       secretName,
                RedirectURIs: []string{"https://" + uri},
                GrantMethod:  oauthv1.GrantHandlerAuto,
        }

        err := r.Client.Create(ctx, oauthClient)
        if err != nil </span><span class="cov0" title="0">{
                if k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                        log.Info("OAuth client resource already exists, patch it", "name", oauthClient.Name)
                        data, err := json.Marshal(oauthClient)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get DataScienceCluster custom resource data: %w", err)
                        }</span>
                        <span class="cov0" title="0">if err = r.Client.Patch(ctx, oauthClient, client.RawPatch(types.ApplyPatchType, data),
                                client.ForceOwnership, client.FieldOwner("rhods-operator")); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to patch existing OAuthClient CR: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        <span class="cov0" title="0">return err</span>
}

func (r *SecretGeneratorReconciler) deleteOAuthClient(ctx context.Context, secretNamespacedName types.NamespacedName) error <span class="cov0" title="0">{
        oauthClient := &amp;oauthv1.OAuthClient{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      secretNamespacedName.Name,
                        Namespace: secretNamespacedName.Namespace,
                },
        }

        err := r.Client.Delete(ctx, oauthClient)
        if err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("error deleting OAuthClient %s: %w", oauthClient.Name, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">//go:build !nowebhook

// Package datasciencecluster provides admission webhook logic for defaulting DataScienceCluster resources.
// It ensures required fields are set to their default values when not specified by the user.
package datasciencecluster

import (
        "context"
        "fmt"

        operatorv1 "github.com/openshift/api/operator/v1"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        modelregistryctrl "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/components/modelregistry"
        webhookutils "github.com/opendatahub-io/opendatahub-operator/v2/pkg/webhook"
)

//+kubebuilder:webhook:path=/mutate-datasciencecluster,mutating=true,failurePolicy=fail,sideEffects=None,groups=datasciencecluster.opendatahub.io,resources=datascienceclusters,verbs=create;update,versions=v1,name=datasciencecluster-defaulter.opendatahub.io,admissionReviewVersions=v1
//nolint:lll

// Defaulter implements webhook.CustomDefaulter for DataScienceCluster resources.
// It sets default values for fields in the DataScienceCluster CR, such as ModelRegistry.RegistriesNamespace.
type Defaulter struct {
        // Name is used for logging and webhook identification.
        Name string
}

// just assert that Defaulter implements webhook.CustomDefaulter.
var _ webhook.CustomDefaulter = &amp;Defaulter{}

// SetupWithManager registers the defaulting webhook with the provided controller-runtime manager.
//
// Parameters:
//   - mgr: The controller-runtime manager to register the webhook with.
//
// Returns:
//   - error: Always nil (for future extensibility).
func (d *Defaulter) SetupWithManager(mgr ctrl.Manager) error <span class="cov7" title="5">{
        mutateWebhook := admission.WithCustomDefaulter(mgr.GetScheme(), &amp;dscv1.DataScienceCluster{}, d)
        mutateWebhook.LogConstructor = webhookutils.NewWebhookLogConstructor(d.Name)
        mgr.GetWebhookServer().Register("/mutate-datasciencecluster", mutateWebhook)
        // No error to return currently, but return nil for future extensibility
        return nil
}</span>

// Default sets default values on the provided DataScienceCluster object.
//
// Parameters:
//   - ctx: Context for the admission request (logger is extracted from here).
//   - obj: The runtime.Object to default (should be a *DataScienceCluster).
//
// Returns:
//   - error: If the object is not a DataScienceCluster, or if defaulting fails.
func (d *Defaulter) Default(ctx context.Context, obj runtime.Object) error <span class="cov10" title="10">{
        dsc, isDSC := obj.(*dscv1.DataScienceCluster)
        if !isDSC </span><span class="cov0" title="0">{
                log := logf.FromContext(ctx)
                err := fmt.Errorf("expected DataScienceCluster but got a different type: %T", obj)
                log.Error(err, "Got wrong type")
                return err
        }</span>

        // Set default values
        <span class="cov10" title="10">d.applyDefaults(ctx, dsc)
        return nil</span>
}

// applyDefaults applies default values to the DataScienceCluster resource in-place.
// Logger is extracted from the context.
//
// Parameters:
//   - ctx: Context for the admission request (logger is extracted from here).
//   - dsc: The DataScienceCluster object to mutate.
func (d *Defaulter) applyDefaults(ctx context.Context, dsc *dscv1.DataScienceCluster) <span class="cov10" title="10">{
        log := logf.FromContext(ctx)
        // If ModelRegistry is enabled and RegistriesNamespace is empty, it sets it to the default value.
        modelRegistry := &amp;dsc.Spec.Components.ModelRegistry
        if modelRegistry.ManagementState == operatorv1.Managed </span><span class="cov6" title="4">{
                if modelRegistry.RegistriesNamespace == "" </span><span class="cov3" title="2">{
                        log.V(1).Info("Setting default RegistriesNamespace for ModelRegistry", "default", modelregistryctrl.DefaultModelRegistriesNamespace)
                        modelRegistry.RegistriesNamespace = modelregistryctrl.DefaultModelRegistriesNamespace
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file73" style="display: none">//go:build !nowebhook

package datasciencecluster

import (
        ctrl "sigs.k8s.io/controller-runtime"
)

// RegisterWebhooks registers the webhooks for DataScienceCluster.
func RegisterWebhooks(mgr ctrl.Manager) error <span class="cov10" title="5">{
        // Register the validating webhook
        if err := (&amp;Validator{
                Client: mgr.GetAPIReader(),
                Name:   "datasciencecluster-validating",
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Register the defaulting webhook
        <span class="cov10" title="5">if err := (&amp;Defaulter{
                Name: "datasciencecluster-defaulter",
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">//go:build !nowebhook

package datasciencecluster

import (
        "context"
        "fmt"

        admissionv1 "k8s.io/api/admission/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        webhookutils "github.com/opendatahub-io/opendatahub-operator/v2/pkg/webhook"
)

//+kubebuilder:webhook:path=/validate-datasciencecluster,mutating=false,failurePolicy=fail,sideEffects=None,groups=datasciencecluster.opendatahub.io,resources=datascienceclusters,verbs=create,versions=v1,name=datasciencecluster-validator.opendatahub.io,admissionReviewVersions=v1
//nolint:lll

// Validator implements webhook.AdmissionHandler for DataScienceCluster validation webhooks.
// It enforces singleton creation rules for DataScienceCluster resources and always allows their deletion.
type Validator struct {
        Client client.Reader
        Name   string
}

// Assert that Validator implements admission.Handler interface.
var _ admission.Handler = &amp;Validator{}

// SetupWithManager registers the validating webhook with the provided controller-runtime manager.
//
// Parameters:
//   - mgr: The controller-runtime manager to register the webhook with.
//
// Returns:
//   - error: Always nil (for future extensibility).
func (v *Validator) SetupWithManager(mgr ctrl.Manager) error <span class="cov7" title="5">{
        hookServer := mgr.GetWebhookServer()
        hookServer.Register("/validate-datasciencecluster", &amp;webhook.Admission{
                Handler:        v,
                LogConstructor: webhookutils.NewWebhookLogConstructor(v.Name),
        })
        return nil
}</span>

// Handle processes admission requests for create operations on DataScienceCluster resources.
// It enforces singleton rules, allowing other operations by default.
//
// Parameters:
//   - ctx: Context for the admission request (logger is extracted from here).
//   - req: The admission.Request containing the operation and object details.
//
// Returns:
//   - admission.Response: The result of the admission check, indicating whether the operation is allowed or denied.
func (v *Validator) Handle(ctx context.Context, req admission.Request) admission.Response <span class="cov10" title="9">{
        log := logf.FromContext(ctx)
        ctx = logf.IntoContext(ctx, log)

        var resp admission.Response

        switch req.Operation </span>{
        case admissionv1.Create:<span class="cov9" title="8">
                resp = webhookutils.ValidateSingletonCreation(ctx, v.Client, &amp;req, gvk.DataScienceCluster.Kind)</span>
        default:<span class="cov3" title="2">
                resp.Allowed = true</span> // initialize Allowed to be true in case Operation falls into "default" case
        }

        <span class="cov10" title="9">if !resp.Allowed </span><span class="cov5" title="3">{
                return resp
        }</span>

        <span class="cov8" title="7">return admission.Allowed(fmt.Sprintf("Operation %s on %s allowed", req.Operation, req.Kind.Kind))</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">//go:build !nowebhook

package dscinitialization

import (
        ctrl "sigs.k8s.io/controller-runtime"
)

// RegisterWebhooks registers the webhooks for DSCInitialization.
func RegisterWebhooks(mgr ctrl.Manager) error <span class="cov10" title="3">{
        if err := (&amp;Validator{
                Client: mgr.GetAPIReader(),
                Name:   "dscinitialization-validating",
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">//go:build !nowebhook

package dscinitialization

import (
        "context"
        "fmt"

        admissionv1 "k8s.io/api/admission/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        webhookutils "github.com/opendatahub-io/opendatahub-operator/v2/pkg/webhook"
)

//+kubebuilder:webhook:path=/validate-dscinitialization,mutating=false,failurePolicy=fail,sideEffects=None,groups=dscinitialization.opendatahub.io,resources=dscinitializations,verbs=create;delete,versions=v1,name=dscinitialization-validator.opendatahub.io,admissionReviewVersions=v1
//nolint:lll

// Validator implements webhook.AdmissionHandler for DSCInitialization validation webhooks.
// It enforces singleton creation and deletion rules for DSCInitialization resources.
type Validator struct {
        Client client.Reader
        Name   string
}

// Assert that Validator implements admission.Handler interface.
var _ admission.Handler = &amp;Validator{}

// SetupWithManager registers the validating webhook with the provided controller-runtime manager.
//
// Parameters:
//   - mgr: The controller-runtime manager to register the webhook with.
//
// Returns:
//   - error: Always nil (for future extensibility).
func (v *Validator) SetupWithManager(mgr ctrl.Manager) error <span class="cov5" title="3">{
        hookServer := mgr.GetWebhookServer()
        hookServer.Register("/validate-dscinitialization", &amp;webhook.Admission{
                Handler:        v,
                LogConstructor: webhookutils.NewWebhookLogConstructor(v.Name),
        })
        return nil
}</span>

// Handle processes admission requests for create and delete operations on DSCInitialization resources.
// It enforces singleton and deletion rules, allowing other operations by default.
//
// Parameters:
//   - ctx: Context for the admission request (logger is extracted from here).
//   - req: The admission.Request containing the operation and object details.
//
// Returns:
//   - admission.Response: The result of the admission check, indicating whether the operation is allowed or denied.
func (v *Validator) Handle(ctx context.Context, req admission.Request) admission.Response <span class="cov10" title="9">{
        log := logf.FromContext(ctx)
        ctx = logf.IntoContext(ctx, log)

        var resp admission.Response

        switch req.Operation </span>{
        case admissionv1.Create:<span class="cov8" title="6">
                resp = webhookutils.ValidateSingletonCreation(ctx, v.Client, &amp;req, gvk.DSCInitialization.Kind)</span>
        case admissionv1.Delete:<span class="cov6" title="4">
                resp = webhookutils.DenyCountGtZero(ctx, v.Client, gvk.DataScienceCluster,
                        "Cannot delete DSCInitialization object when DataScienceCluster object still exists")</span>
        default:<span class="cov0" title="0">
                resp.Allowed = true</span>
        }

        <span class="cov10" title="9">if !resp.Allowed </span><span class="cov6" title="4">{
                return resp
        }</span>

        <span class="cov8" title="6">return admission.Allowed(fmt.Sprintf("Operation %s on %s allowed", req.Operation, req.Kind.Kind))</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">//go:build !nowebhook

package hardwareprofile

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        admissionv1 "k8s.io/api/admission/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/intstr"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        hwpv1alpha1 "github.com/opendatahub-io/opendatahub-operator/v2/api/infrastructure/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
        webhookutils "github.com/opendatahub-io/opendatahub-operator/v2/pkg/webhook"
)

// Annotation constants.
const (
        HardwareProfileNameAnnotation      = "opendatahub.io/hardware-profile-name"
        HardwareProfileNamespaceAnnotation = "opendatahub.io/hardware-profile-namespace"
)

// WorkloadConfig defines path configuration for different workload types.
type WorkloadConfig struct {
        ContainersPath   []string
        NodeSelectorPath []string
        TolerationsPath  []string
}

// WorkloadConfigs maps Kubernetes resource kinds to their configuration paths.
var WorkloadConfigs = map[string]WorkloadConfig{
        gvk.Notebook.Kind: {
                ContainersPath:   []string{"spec", "template", "spec", "containers"},
                NodeSelectorPath: []string{"spec", "template", "spec", "nodeSelector"},
                TolerationsPath:  []string{"spec", "template", "spec", "tolerations"},
        },
        gvk.InferenceServices.Kind: {
                ContainersPath:   []string{"spec", "predictor", "podSpec", "containers"},
                NodeSelectorPath: []string{"spec", "predictor", "podSpec", "nodeSelector"},
                TolerationsPath:  []string{"spec", "predictor", "podSpec", "tolerations"},
        },
}

//+kubebuilder:webhook:path=/mutate-hardware-profile,mutating=true,failurePolicy=fail,groups=kubeflow.org,resources=notebooks,verbs=create;update,versions=v1,name=hardwareprofile-notebook-injector.opendatahub.io,sideEffects=None,admissionReviewVersions=v1
//+kubebuilder:webhook:path=/mutate-hardware-profile,mutating=true,failurePolicy=fail,groups=serving.kserve.io,resources=inferenceservices,verbs=create;update,versions=v1beta1,name=hardwareprofile-kserve-injector.opendatahub.io,sideEffects=None,admissionReviewVersions=v1
//nolint:lll

// Injector implements a mutating admission webhook for hardware profile injection.
type Injector struct {
        Client  client.Reader
        Decoder admission.Decoder
        Name    string
}

// Assert that Injector implements admission.Handler interface.
var _ admission.Handler = &amp;Injector{}

// SetupWithManager registers the validating webhook with the provided controller-runtime manager.
//
// Parameters:
//   - mgr: The controller-runtime manager to register the webhook with.
//
// Returns:
//   - error: Always nil (for future extensibility).
func (i *Injector) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        hookServer := mgr.GetWebhookServer()

        // Register single webhook path for both Notebooks and InferenceServices
        hookServer.Register("/mutate-hardware-profile", &amp;webhook.Admission{
                Handler:        i,
                LogConstructor: webhookutils.NewWebhookLogConstructor(i.Name),
        })

        return nil
}</span>

// Handle processes admission requests for workload resources with hardware profile annotations.
// This is the main entry point for the webhook and orchestrates the entire hardware profile
// injection process.
//
// The method performs the following operations:
//  1. Validates that the decoder is properly initialized
//  2. Checks if the resource kind is supported by the webhook
//  3. Routes CREATE and UPDATE operations to the injection logic
//  4. Allows all other operations (DELETE, CONNECT, etc.) without modification
//
// Error Handling:
//   - Returns HTTP 500 if the decoder is not initialized
//   - Returns HTTP 400 for unsupported resource kinds
//   - Delegates error handling to injection logic for supported operations
//
// Parameters:
//   - ctx: Request context containing logger and other contextual information
//   - req: The admission.Request containing operation type and resource details
//
// Returns:
//   - admission.Response: The result of the admission check with any mutations applied
func (i *Injector) Handle(ctx context.Context, req admission.Request) admission.Response <span class="cov8" title="1">{
        log := logf.FromContext(ctx)

        // Check if decoder is properly injected
        if i.Decoder == nil </span><span class="cov8" title="1">{
                log.Error(nil, "Decoder is nil - webhook not properly initialized")
                return admission.Errored(http.StatusInternalServerError, errors.New("webhook decoder not initialized"))
        }</span>

        // Validate that we're processing an expected resource kind
        <span class="cov8" title="1">if !isExpectedKind(req.Kind) </span><span class="cov8" title="1">{
                err := fmt.Errorf("unexpected kind: %s", req.Kind.Kind)
                log.Error(err, "got wrong kind")
                return admission.Errored(http.StatusBadRequest, err)
        }</span>

        // Decode the object to check deletion timestamp
        <span class="cov8" title="1">obj := &amp;unstructured.Unstructured{}
        if err := i.Decoder.Decode(req, obj); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Failed to decode object")
                return admission.Errored(http.StatusBadRequest, err)
        }</span>

        // Skip processing if object is marked for deletion
        <span class="cov8" title="1">if !obj.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return admission.Allowed("Object marked for deletion, skipping hardware profile injection")
        }</span>

        <span class="cov8" title="1">var resp admission.Response

        switch req.Operation </span>{
        case admissionv1.Create, admissionv1.Update:<span class="cov8" title="1">
                resp = i.performHardwareProfileInjection(ctx, &amp;req, obj)</span>
        default:<span class="cov8" title="1">
                resp = admission.Allowed(fmt.Sprintf("Operation %s on %s allowed", req.Operation, req.Kind.Kind))</span>
        }

        <span class="cov8" title="1">return resp</span>
}

// isExpectedKind checks if the given GroupVersionKind is supported by the webhook.
//
// Parameters:
//   - kind: The GroupVersionKind from the admission request to validate
//
// Returns:
//   - bool: true if the kind is supported by the webhook, false otherwise
func isExpectedKind(kind metav1.GroupVersionKind) bool <span class="cov8" title="1">{
        // expectedGVKs contains the list of resource types that the hardware profile webhook should handle.
        expectedGVKs := []schema.GroupVersionKind{
                gvk.Notebook,          // kubeflow.org/v1/Notebook
                gvk.InferenceServices, // serving.kserve.io/v1beta1/InferenceService
        }

        requestGVK := schema.GroupVersionKind{
                Group:   kind.Group,
                Version: kind.Version,
                Kind:    kind.Kind,
        }

        for _, expectedGVK := range expectedGVKs </span><span class="cov8" title="1">{
                if requestGVK == expectedGVK </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// performHardwareProfileInjection handles the core logic for hardware profile injection.
// This method orchestrates the entire process of applying hardware profile specifications
// to workload resources.
//
// The injection process follows these steps:
//  1. Decode the workload object from the admission request
//  2. Check for hardware profile annotations on the object
//  3. Determine the namespace for the hardware profile lookup
//  4. Fetch the HardwareProfile resource from the Kubernetes API
//  5. Validate that the hardware profile has meaningful configuration
//  6. Set the hardware profile namespace annotation if not present
//  7. Apply hardware profile specifications to the workload
//  8. Return the modified object as a patch response
//
// Annotation Handling:
//   - opendatahub.io/hardware-profile-name: Required annotation specifying the profile name
//   - opendatahub.io/hardware-profile-namespace: Optional annotation for cross-namespace profiles
//
// Error Conditions:
//   - Returns HTTP 400 for object decoding failures or missing profile namespace
//   - Returns HTTP 400 for non-existent hardware profiles
//   - Returns HTTP 500 for internal errors during profile application or object marshaling
//
// Parameters:
//   - ctx: Request context containing logger and other contextual information
//   - req: The admission.Request containing the workload object and operation details
//
// Returns:
//   - admission.Response: Success response with object patch or error response with details
func (i *Injector) performHardwareProfileInjection(ctx context.Context, req *admission.Request, obj *unstructured.Unstructured) admission.Response <span class="cov8" title="1">{
        log := logf.FromContext(ctx)

        // Check if the object has hardware profile annotations
        profileName := resources.GetAnnotation(obj, HardwareProfileNameAnnotation)
        if profileName == "" </span><span class="cov8" title="1">{
                return admission.Allowed("No hardware profile annotation found")
        }</span>

        // Determine the namespace for the hardware profile
        <span class="cov8" title="1">profileNamespace := resources.GetAnnotation(obj, HardwareProfileNamespaceAnnotation)
        if profileNamespace == "" </span><span class="cov8" title="1">{
                profileNamespace = obj.GetNamespace()
        }</span>
        <span class="cov8" title="1">if profileNamespace == "" </span><span class="cov8" title="1">{
                return admission.Errored(http.StatusBadRequest, errors.New("unable to determine hardware profile namespace"))
        }</span>

        // Get the hardware profile
        <span class="cov8" title="1">hwp, err := i.fetchHardwareProfile(ctx, profileNamespace, profileName)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err, "Failed to get hardware profile", "profile", profileName, "namespace", profileNamespace)
                return admission.Errored(http.StatusForbidden, err)
        }</span>

        // Early exit if hardware profile has no meaningful configuration
        <span class="cov8" title="1">if len(hwp.Spec.Identifiers) == 0 &amp;&amp; hwp.Spec.SchedulingSpec == nil </span><span class="cov8" title="1">{
                return admission.Allowed("Hardware profile has no configuration to apply")
        }</span>

        // Set the hardware profile namespace annotation
        <span class="cov8" title="1">resources.SetAnnotation(obj, HardwareProfileNamespaceAnnotation, profileNamespace)

        // Apply hardware profile specifications
        if err := i.applyHardwareProfileToWorkload(ctx, obj, hwp); err != nil </span><span class="cov8" title="1">{
                log.Error(err, "Failed to apply hardware profile", "profile", profileName)
                return admission.Errored(http.StatusInternalServerError, err)
        }</span>

        // Marshal the modified object
        <span class="cov8" title="1">marshaledObj, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Failed to marshal modified object")
                return admission.Errored(http.StatusInternalServerError, err)
        }</span>

        // Return the admission response with the modified object
        <span class="cov8" title="1">return admission.PatchResponseFromRaw(req.Object.Raw, marshaledObj)</span>
}

// fetchHardwareProfile retrieves the HardwareProfile resource from the Kubernetes API server.
// This method handles the lookup of hardware profiles with proper error handling for
// common scenarios like missing resources.
//
// The method performs the following operations:
//  1. Constructs a namespaced name for the hardware profile lookup
//  2. Attempts to fetch the resource using the Kubernetes client
//  3. Provides specific error messages for not found vs. other API errors
//
// Error Handling:
//   - Returns a descriptive error for non-existent hardware profiles (404)
//   - Returns a generic error for other API failures (network, permissions, etc.)
//
// Parameters:
//   - ctx: Request context for the Kubernetes API call
//   - namespace: The namespace containing the HardwareProfile resource
//   - name: The name of the HardwareProfile resource to fetch
//
// Returns:
//   - *hwpv1alpha1.HardwareProfile: The fetched HardwareProfile resource
//   - error: Descriptive error for lookup failures, nil on success
func (i *Injector) fetchHardwareProfile(ctx context.Context, namespace, name string) (*hwpv1alpha1.HardwareProfile, error) <span class="cov8" title="1">{
        hwp := &amp;hwpv1alpha1.HardwareProfile{}
        key := types.NamespacedName{Name: name, Namespace: namespace}

        if err := i.Client.Get(ctx, key, hwp); err != nil </span><span class="cov8" title="1">{
                if k8serr.IsNotFound(err) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to get hardware profile '%s' in namespace '%s': %w", name, namespace, err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get hardware profile '%s': %w", name, err)</span>
        }

        <span class="cov8" title="1">return hwp, nil</span>
}

// applyHardwareProfileToWorkload applies hardware profile specifications to any supported
// Kubernetes workload resource. This method is the central orchestrator for applying
// all hardware profile configurations to workload resources.
//
// The method handles two main categories of hardware profile specifications:
//  1. Resource Requirements: CPU, memory, and custom resource identifiers (e.g., GPUs)
//  2. Scheduling Configuration: Kueue queue assignments and node scheduling constraints
//
// Resource Application Strategy:
//   - Only applies resource requirements to containers that don't already have them
//   - Preserves existing resource specifications in containers
//   - Supports both standard resources (CPU, memory) and custom resources (nvidia.com/gpu)
//
// Scheduling Configuration:
//   - Applies Kueue LocalQueue labels for queue-based scheduling
//   - Applies node scheduling constraints (nodeSelector, tolerations)
//   - Always applies scheduling configuration regardless of existing values
//
// Parameters:
//   - ctx: Request context containing logger for operation tracking
//   - obj: The unstructured workload object to modify (Notebook, InferenceService, etc.)
//   - hwp: The HardwareProfile resource containing specifications to apply
//
// Returns:
//   - error: Any error encountered during hardware profile application, nil on success
func (i *Injector) applyHardwareProfileToWorkload(ctx context.Context, obj *unstructured.Unstructured, hwp *hwpv1alpha1.HardwareProfile) error <span class="cov8" title="1">{
        log := logf.FromContext(ctx)

        log.V(1).Info("applying hardware profile to workload", "workload", obj.GetName(), "kind", obj.GetKind(), "hardwareProfile", hwp.Name)

        // Apply resource requirements to containers (only if there are identifiers)
        if len(hwp.Spec.Identifiers) &gt; 0 </span><span class="cov8" title="1">{
                if err := i.applyResourceRequirementsToWorkload(obj, hwp); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to apply resource requirements: %w", err)
                }</span>
        }

        // Apply scheduling configuration if present
        <span class="cov8" title="1">if hwp.Spec.SchedulingSpec != nil </span><span class="cov8" title="1">{
                // Apply Kueue LocalQueue label
                if hwp.Spec.SchedulingSpec.Kueue != nil &amp;&amp; hwp.Spec.SchedulingSpec.Kueue.LocalQueueName != "" </span><span class="cov8" title="1">{
                        resources.SetLabel(obj, cluster.KueueQueueNameLabel, hwp.Spec.SchedulingSpec.Kueue.LocalQueueName)
                }</span>

                // Apply Node scheduling configuration
                <span class="cov8" title="1">if hwp.Spec.SchedulingSpec.Node != nil </span><span class="cov8" title="1">{
                        if err := i.applyNodeSchedulingConfiguration(obj, hwp); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to apply node scheduling configuration: %w", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetWorkloadConfig returns the workload configuration for a given kind.
//
// This function provides access to the workload-specific configuration paths
// that define where containers, nodeSelector, and tolerations are located
// within different Kubernetes resource types.
//
// Parameters:
//   - kind: The Kubernetes resource kind (e.g., "Notebook", "InferenceService")
//
// Returns:
//   - WorkloadConfig: Configuration containing JSON paths for the workload type
//   - error: Error if the workload kind is not supported by the webhook
func GetWorkloadConfig(kind string) (WorkloadConfig, error) <span class="cov8" title="1">{
        config, exists := WorkloadConfigs[kind]
        if !exists </span><span class="cov0" title="0">{
                return WorkloadConfig{}, fmt.Errorf("unsupported workload kind: %s", kind)
        }</span>
        <span class="cov8" title="1">return config, nil</span>
}

// applyResourceRequirementsToWorkload applies resource requirements to all containers
// in a workload resource. This method handles the container-level resource injection
// for both standard and custom resource types.
//
// Parameters:
//   - obj: The unstructured workload object containing containers to modify
//   - hwp: The HardwareProfile resource containing resource identifiers to apply
//
// Returns:
//   - error: Any error encountered during resource requirement application, nil on success

func (i *Injector) applyResourceRequirementsToWorkload(obj *unstructured.Unstructured, hwp *hwpv1alpha1.HardwareProfile) error <span class="cov8" title="1">{
        config, err := GetWorkloadConfig(obj.GetKind())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get containers from the workload
        <span class="cov8" title="1">containers, found, err := unstructured.NestedSlice(obj.Object, config.ContainersPath...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get containers: %w", err)
        }</span>
        <span class="cov8" title="1">if !found || len(containers) == 0 </span><span class="cov0" title="0">{
                return nil // No containers found
        }</span>

        // Apply resource requirements to each container
        <span class="cov8" title="1">for idx, container := range containers </span><span class="cov8" title="1">{
                if err := i.applyIdentifiersToContainer(container, hwp.Spec.Identifiers); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to apply resources to container %d: %w", idx, err)
                }</span>
        }

        // Update the object with modified containers
        <span class="cov8" title="1">return unstructured.SetNestedSlice(obj.Object, containers, config.ContainersPath...)</span>
}

// applyIdentifiersToContainer applies resource requirements to a single container.
// This method implements the granular resource application logic that only adds
// resource requirements for identifiers that don't already exist in the container.
//
// Parameters:
//   - container: The container interface{} to modify (must be map[string]interface{})
//   - identifiers: Array of hardware identifiers to apply from the hardware profile
//
// Returns:
//   - error: Any error encountered during resource application, nil on success
func (i *Injector) applyIdentifiersToContainer(container interface{}, identifiers []hwpv1alpha1.HardwareIdentifier) error <span class="cov8" title="1">{
        containerMap, ok := container.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return errors.New("container is not a map[string]interface{}")
        }</span>

        // Get or create resources section
        <span class="cov8" title="1">resourcesMap, err := webhookutils.GetOrCreateNestedMap(containerMap, "resources")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get or create requests section
        <span class="cov8" title="1">requests, err := webhookutils.GetOrCreateNestedMap(resourcesMap, "requests")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Apply hardware profile resource requirements only for identifiers that don't already exist
        <span class="cov8" title="1">if err := i.applyIdentifiersToRequests(requests, identifiers); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update container with modified resources
        <span class="cov8" title="1">resourcesMap["requests"] = requests
        containerMap["resources"] = resourcesMap
        return nil</span>
}

// applyIdentifiersToRequests applies hardware identifiers to a container's resource requests map.
// This method implements the core logic for selectively adding resource requirements
// while preserving existing specifications.
//
// The method iterates through all hardware identifiers and:
//  1. Checks if the resource identifier already exists in the requests map
//  2. Skips identifiers that are already present (preserving user specifications)
//  3. Converts the hardware profile's default count to a Kubernetes resource quantity
//  4. Adds the resource requirement to the requests map
//
// Parameters:
//   - requests: The container's resource requests map to modify
//   - identifiers: Array of hardware identifiers from the hardware profile
//
// Returns:
//   - error: Any error encountered during identifier application or quantity conversion
func (i *Injector) applyIdentifiersToRequests(requests map[string]interface{}, identifiers []hwpv1alpha1.HardwareIdentifier) error <span class="cov8" title="1">{
        for _, identifier := range identifiers </span><span class="cov8" title="1">{
                // Skip if the resource identifier already exists
                if _, exists := requests[identifier.Identifier]; exists </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">quantity, err := convertIntOrStringToQuantity(identifier.DefaultCount)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to convert resource quantity for %s: %w", identifier.Identifier, err)
                }</span>
                <span class="cov8" title="1">requests[identifier.Identifier] = quantity.String()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// applyNodeSchedulingConfiguration applies node scheduling constraints to the workload.
// This method handles the application of nodeSelector and tolerations from the hardware
// profile to ensure workloads are scheduled on appropriate nodes.
//
// The method applies two types of node scheduling constraints:
//  1. NodeSelector: Key-value pairs that must match node labels
//  2. Tolerations: Specifications that allow scheduling on nodes with matching taints
//
// Configuration Application:
//   - NodeSelector is applied as a complete replacement of existing values
//   - Tolerations are applied as a complete replacement of existing values
//   - Both configurations are applied only if present in the hardware profile
//
// Parameters:
//   - obj: The unstructured workload object to modify
//   - hwp: The HardwareProfile resource containing node scheduling specifications
//
// Returns:
//   - error: Any error encountered during node scheduling configuration application
func (i *Injector) applyNodeSchedulingConfiguration(obj *unstructured.Unstructured, hwp *hwpv1alpha1.HardwareProfile) error <span class="cov8" title="1">{
        nodeSpec := hwp.Spec.SchedulingSpec.Node

        config, err := GetWorkloadConfig(obj.GetKind())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported workload kind for node scheduling: %s", obj.GetKind())
        }</span>

        // Apply nodeSelector if present
        <span class="cov8" title="1">if len(nodeSpec.NodeSelector) &gt; 0 </span><span class="cov8" title="1">{
                if err := unstructured.SetNestedStringMap(obj.Object, nodeSpec.NodeSelector, config.NodeSelectorPath...); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to set nodeSelector: %w", err)
                }</span>
        }

        // Apply tolerations if present
        <span class="cov8" title="1">if len(nodeSpec.Tolerations) &gt; 0 </span><span class="cov8" title="1">{
                tolerationsSlice := make([]interface{}, len(nodeSpec.Tolerations))
                for i, toleration := range nodeSpec.Tolerations </span><span class="cov8" title="1">{
                        tolerationUnstructured, err := resources.ToUnstructured(&amp;toleration)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to convert toleration to unstructured: %w", err)
                        }</span>
                        <span class="cov8" title="1">tolerationsSlice[i] = tolerationUnstructured.Object</span>
                }

                <span class="cov8" title="1">if err := unstructured.SetNestedSlice(obj.Object, tolerationsSlice, config.TolerationsPath...); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set tolerations: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// convertIntOrStringToQuantity converts an IntOrString value to a Kubernetes resource.Quantity.
// This utility function handles the conversion of hardware profile resource counts to
// the proper Kubernetes resource quantity format.
//
// Parameters:
//   - value: The IntOrString value from the hardware profile to convert
//
// Returns:
//   - resource.Quantity: The converted Kubernetes resource quantity
//   - error: Any error encountered during conversion or parsing
func convertIntOrStringToQuantity(value intstr.IntOrString) (resource.Quantity, error) <span class="cov8" title="1">{
        switch value.Type </span>{
        case intstr.Int:<span class="cov8" title="1">
                return *resource.NewQuantity(int64(value.IntVal), resource.DecimalSI), nil</span>
        case intstr.String:<span class="cov8" title="1">
                return resource.ParseQuantity(value.StrVal)</span>
        default:<span class="cov0" title="0">
                return resource.Quantity{}, fmt.Errorf("invalid IntOrString type: %v", value.Type)</span>
        }
}
</pre>
		
		<pre class="file" id="file78" style="display: none">//go:build !nowebhook

package hardwareprofile

import (
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// RegisterWebhooks registers the webhooks for hardware profile injection.
//
// Parameters:
//   - mgr: The controller-runtime manager to register webhooks with.
//
// Returns:
//   - error: Any error encountered during webhook registration.
func RegisterWebhooks(mgr ctrl.Manager) error <span class="cov8" title="1">{
        if err := (&amp;Injector{
                Client:  mgr.GetAPIReader(),
                Decoder: admission.NewDecoder(mgr.GetScheme()),
                Name:    "hardwareprofile-injector",
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">//go:build !nowebhook

package inferenceservice

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        admissionv1 "k8s.io/api/admission/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        webhookutils "github.com/opendatahub-io/opendatahub-operator/v2/pkg/webhook"
)

// create new type for connection types.
type ConnectionType string

const (
        // ConnectionTypeURI represents uri connections.
        ConnectionTypeURI ConnectionType = "uri-v1"
        // ConnectionTypeS3 represents s3 connections.
        ConnectionTypeS3 ConnectionType = "s3"
        // ConnectionTypeOCI represents oci connections.
        ConnectionTypeOCI ConnectionType = "oci-v1"
)

func (ct ConnectionType) String() string <span class="cov8" title="1">{
        return string(ct)
}</span>

type InferenceServingPath struct {
        ModelPath           []string
        ImagePullSecretPath []string
        StorageUriPath      []string
}

var IsvcConfigs = InferenceServingPath{
        ModelPath:           []string{"spec", "predictor", "model"},               // used by S3, has map
        ImagePullSecretPath: []string{"spec", "predictor", "imagePullSecrets"},    // used by OCI, has slice
        StorageUriPath:      []string{"spec", "predictor", "model", "storageUri"}, // used by URI, has string
}

//+kubebuilder:webhook:path=/platform-connection-isvc,mutating=true,failurePolicy=fail,groups=serving.kserve.io,resources=inferenceservices,verbs=create;update,versions=v1beta1,name=connection-isvc.opendatahub.io,sideEffects=None,admissionReviewVersions=v1
//nolint:lll

type ConnectionWebhook struct {
        Client  client.Reader
        Decoder admission.Decoder
        Name    string
}

var _ admission.Handler = &amp;ConnectionWebhook{}

func (w *ConnectionWebhook) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        hookServer := mgr.GetWebhookServer()
        hookServer.Register("/platform-connection-isvc", &amp;webhook.Admission{
                Handler:        w,
                LogConstructor: webhookutils.NewWebhookLogConstructor(w.Name),
        })
        return nil
}</span>

func (w *ConnectionWebhook) Handle(ctx context.Context, req admission.Request) admission.Response <span class="cov8" title="1">{
        log := logf.FromContext(ctx)

        if w.Decoder == nil </span><span class="cov0" title="0">{
                log.Error(nil, "Decoder is nil - webhook not properly initialized")
                return admission.Errored(http.StatusInternalServerError, errors.New("webhook decoder not initialized"))
        }</span>

        // Decode the object once
        <span class="cov8" title="1">obj, err := webhookutils.DecodeUnstructured(w.Decoder, req)
        if err != nil </span><span class="cov0" title="0">{
                return admission.Errored(http.StatusInternalServerError, err)
        }</span>

        // Skip processing if object is marked for deletion
        <span class="cov8" title="1">if !obj.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return admission.Allowed("Object marked for deletion, skipping connection logic")
        }</span>

        <span class="cov8" title="1">switch req.Operation </span>{
        case admissionv1.Create, admissionv1.Update:<span class="cov8" title="1">

                // allowed connection types for connection validation on isvc.
                allowedTypes := []string{
                        ConnectionTypeURI.String(),
                        ConnectionTypeS3.String(),
                        ConnectionTypeOCI.String(),
                }

                // validate the connection annotation
                // - if has matched annoataion
                // - if annaotation has valid value as that secret exists in the same namespace(permission allowed)
                validationResp, shouldInject, secretName, connectionType := webhookutils.ValidateInferenceServiceConnectionAnnotation(ctx, w.Client, obj, req, allowedTypes)
                if !validationResp.Allowed </span><span class="cov8" title="1">{
                        return validationResp
                }</span>

                // only proceed with injection if the annotation is valid and shouldInject is true
                <span class="cov8" title="1">if !shouldInject </span><span class="cov8" title="1">{
                        return admission.Allowed(fmt.Sprintf("Connection validation passed in namespace %s for %s, no injection needed", req.Namespace, req.Kind.Kind))
                }</span>

                <span class="cov8" title="1">injectionPerformed, err := w.performConnectionInjection(ctx, req, secretName, connectionType, obj)
                if err != nil </span><span class="cov8" title="1">{
                        log.Error(err, "Failed to perform connection injection")
                        return admission.Errored(http.StatusInternalServerError, err)
                }</span>

                // finally, write updated object back to k8s
                <span class="cov8" title="1">if injectionPerformed </span><span class="cov8" title="1">{
                        marshaledObj, err := json.Marshal(obj)
                        if err != nil </span><span class="cov0" title="0">{
                                return admission.Errored(http.StatusInternalServerError, err)
                        }</span>
                        <span class="cov8" title="1">return admission.PatchResponseFromRaw(req.Object.Raw, marshaledObj)</span>
                }

                // If no injection was performed, allow the operation
                <span class="cov0" title="0">return admission.Allowed(fmt.Sprintf("No injection performed for %s in namespace %s", req.Kind.Kind, req.Namespace))</span>

        default:<span class="cov8" title="1">
                return admission.Allowed(fmt.Sprintf("Operation %s on %s allowed in namespace %s", req.Operation, req.Kind.Kind, req.Namespace))</span>
        }
}

func (w *ConnectionWebhook) performConnectionInjection(
        ctx context.Context,
        req admission.Request,
        secretName string,
        connectionType string,
        decodedObj *unstructured.Unstructured,
) (bool, error) <span class="cov8" title="1">{
        log := logf.FromContext(ctx)

        log.V(1).Info("Decoded InferenceService object", "connectionType", connectionType, "operation", req.Operation)

        // injection based on connection type
        switch ConnectionType(connectionType) </span>{
        case ConnectionTypeOCI:<span class="cov8" title="1">
                if err := w.injectOCIImagePullSecrets(decodedObj, secretName); err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to inject OCI imagePullSecrets: %w", err)
                }</span>
                <span class="cov8" title="1">log.V(1).Info("Successfully injected OCI imagePullSecrets", "secretName", secretName)
                return true, nil</span>

        case ConnectionTypeURI:<span class="cov8" title="1">
                if err := w.injectURIStorageUri(ctx, decodedObj, secretName, req.Namespace); err != nil </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("failed to inject URI storageUri: %w", err)
                }</span>
                <span class="cov8" title="1">log.V(1).Info("Successfully injected URI storageUri from secret", "secretName", secretName)
                return true, nil</span>

        case ConnectionTypeS3:<span class="cov8" title="1">
                if err := w.injectS3StorageKey(decodedObj, secretName); err != nil </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("failed to inject S3 storage.key: %w", err)
                }</span>
                <span class="cov8" title="1">log.V(1).Info("Successfully injected S3 storage key", "secretName", secretName)
                return true, nil</span>

        default:<span class="cov0" title="0"> // this should not enter since ValidateConnectionAnnotation ensures valid types, but keep it for safety
                log.V(1).Info("Unknown connection type, skipping injection", "connectionType", connectionType)
                return false, nil</span>
        }
}

// injectOCIImagePullSecrets injects imagePullSecrets into spec.predictor.imagePullSecrets for OCI connections.
func (w *ConnectionWebhook) injectOCIImagePullSecrets(obj *unstructured.Unstructured, secretName string) error <span class="cov8" title="1">{
        imagePullSecrets, err := webhookutils.GetOrCreateNestedSlice(obj.Object, IsvcConfigs.ImagePullSecretPath...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get spec.predictor.imagePullSecrets: %w", err)
        }</span>

        // Check if the secret is already in the list, fast exist
        <span class="cov8" title="1">for _, secret := range imagePullSecrets </span><span class="cov0" title="0">{
                if secretMap, ok := secret.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if name, exists := secretMap["name"]; exists &amp;&amp; name == secretName </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }

        // Add new secret to the slice(upon UPDATE)
        <span class="cov8" title="1">newImagePullSecret := map[string]interface{}{
                "name": secretName,
        }
        imagePullSecrets = append(imagePullSecrets, newImagePullSecret)

        return webhookutils.SetNestedValue(obj.Object, imagePullSecrets, IsvcConfigs.ImagePullSecretPath)</span>
}

// injectURIStorageUri injects storageUri into spec.predictor.model.storageUri for URI connections.
func (w *ConnectionWebhook) injectURIStorageUri(ctx context.Context, obj *unstructured.Unstructured, secretName, namespace string) error <span class="cov8" title="1">{
        // Fetch the secret to get the URI data
        secret := &amp;corev1.Secret{}
        if err := w.Client.Get(ctx, types.NamespacedName{Name: secretName, Namespace: namespace}, secret); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get secret %s: %w", secretName, err)
        }</span>

        <span class="cov8" title="1">var storageUri string
        uri, exists := secret.Data["URI"]
        if !exists </span><span class="cov8" title="1">{
                return errors.New("secret does not contain 'URI' data key")
        }</span>
        // The secret data is already base64 decoded by Kubernetes, so we can use it directly
        <span class="cov8" title="1">storageUri = string(uri)

        // Set the storageUri directly
        return webhookutils.SetNestedValue(obj.Object, storageUri, IsvcConfigs.StorageUriPath)</span>
}

// injectS3StorageKey injects storage key into spec.predictor.model.storage.key for S3 connections.
func (w *ConnectionWebhook) injectS3StorageKey(obj *unstructured.Unstructured, secretName string) error <span class="cov8" title="1">{
        model, found, err := unstructured.NestedMap(obj.Object, IsvcConfigs.ModelPath...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get spec.predictor.model: %w", err)
        }</span>
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return errors.New("found no spec.predictor.model set in resource")
        }</span>

        <span class="cov8" title="1">storageMap, err := webhookutils.GetOrCreateNestedMap(model, "storage")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get or create nested map for storage: %w", err)
        }</span>
        <span class="cov8" title="1">storageMap["key"] = secretName
        model["storage"] = storageMap

        return webhookutils.SetNestedValue(obj.Object, model, IsvcConfigs.ModelPath)</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">//go:build !nowebhook

package inferenceservice

import (
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// RegisterWebhooks registers the combined connection webhook that handles both validation and mutation.
func RegisterWebhooks(mgr ctrl.Manager) error <span class="cov0" title="0">{
        if err := (&amp;ConnectionWebhook{
                Client:  mgr.GetAPIReader(),
                Decoder: admission.NewDecoder(mgr.GetScheme()),
                Name:    "connection-isvc",
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">//go:build !nowebhook

package kueue

import (
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// RegisterWebhooks registers the webhooks for kueue label validation.
//
// Parameters:
//   - mgr: The controller-runtime manager to register webhooks with.
//
// Returns:
//   - error: Any error encountered during webhook registration.
func RegisterWebhooks(mgr ctrl.Manager) error <span class="cov0" title="0">{
        if err := (&amp;Validator{
                Client:  mgr.GetAPIReader(),
                Decoder: admission.NewDecoder(mgr.GetScheme()),
                Name:    "kueue-validating",
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">//go:build !nowebhook

package kueue

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        operatorv1 "github.com/openshift/api/operator/v1"
        admissionv1 "k8s.io/api/admission/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
        webhookutils "github.com/opendatahub-io/opendatahub-operator/v2/pkg/webhook"
)

// Webhooks for Kueue label validation:
// - kubeflow.org/v1: pytorchjobs, notebooks
// - ray.io/v1 and v1alpha1: rayjobs, rayclusters
// - serving.kserve.io/v1beta1: inferenceservices

//+kubebuilder:webhook:path=/validate-kueue,mutating=false,failurePolicy=fail,sideEffects=None,groups=kubeflow.org,resources=pytorchjobs;notebooks,verbs=create;update,versions=v1,name=kubeflow-kueuelabels-validator.opendatahub.io,admissionReviewVersions=v1
//+kubebuilder:webhook:path=/validate-kueue,mutating=false,failurePolicy=fail,sideEffects=None,groups=ray.io,resources=rayjobs;rayclusters,verbs=create;update,versions=v1;v1alpha1,name=ray-kueuelabels-validator.opendatahub.io,admissionReviewVersions=v1
//+kubebuilder:webhook:path=/validate-kueue,mutating=false,failurePolicy=fail,sideEffects=None,groups=serving.kserve.io,resources=inferenceservices,verbs=create;update,versions=v1beta1,name=kserve-kueuelabels-validator.opendatahub.io,admissionReviewVersions=v1
//nolint:lll

var (
        // Error messages for Kueue label validation.
        ErrMissingRequiredLabel = fmt.Errorf("missing required label %q", cluster.KueueQueueNameLabel)
        ErrEmptyRequiredLabel   = fmt.Errorf("label %q is set but empty", cluster.KueueQueueNameLabel)
)

// Validator implements webhook.AdmissionHandler for Kueue validation webhooks.
type Validator struct {
        Client  client.Reader
        Decoder admission.Decoder
        Name    string
}

// Assert that Validator implements admission.Handler interface.
var _ admission.Handler = &amp;Validator{}

// SetupWithManager registers the validating webhook with the provided controller-runtime manager.
//
// Parameters:
//   - mgr: The controller-runtime manager to register the webhook with.
//
// Returns:
//   - error: Always nil (for future extensibility).
func (v *Validator) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        hookServer := mgr.GetWebhookServer()
        hookServer.Register("/validate-kueue", &amp;webhook.Admission{
                Handler:        v,
                LogConstructor: webhookutils.NewWebhookLogConstructor(v.Name),
        })
        return nil
}</span>

// Handle processes admission requests for create and update operations on kueue workload-related resources.
//
// Parameters:
//   - ctx: Context for the admission request (logger is extracted from here).
//   - req: The admission.Request containing the operation and object details.
//
// Returns:
//   - admission.Response: The result of the admission check, indicating whether the operation is allowed or denied.
func (v *Validator) Handle(ctx context.Context, req admission.Request) admission.Response <span class="cov8" title="1">{
        log := logf.FromContext(ctx)

        // Check if decoder is properly injected
        if v.Decoder == nil </span><span class="cov8" title="1">{
                log.Error(nil, "Decoder is nil - webhook not properly initialized")
                return admission.Errored(http.StatusInternalServerError, errors.New("webhook decoder not initialized"))
        }</span>

        // Validate that we're processing an expected resource kind
        <span class="cov8" title="1">if !isExpectedKind(req.Kind) </span><span class="cov8" title="1">{
                err := fmt.Errorf("unexpected kind: %s", req.Kind.Kind)
                log.Error(err, "got wrong kind", "group", req.Kind.Group, "version", req.Kind.Version, "kind", req.Kind.Kind)
                return admission.Errored(http.StatusBadRequest, err)
        }</span>

        // Decode the object to check deletion timestamp
        <span class="cov8" title="1">obj := &amp;unstructured.Unstructured{}
        if err := v.Decoder.Decode(req, obj); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to decode object")
                return admission.Errored(http.StatusBadRequest, fmt.Errorf("failed to decode object: %w", err))
        }</span>

        // Skip processing if object is marked for deletion
        <span class="cov8" title="1">if !obj.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return admission.Allowed("Object marked for deletion, skipping Kueue label validation")
        }</span>

        <span class="cov8" title="1">var resp admission.Response

        switch req.Operation </span>{
        case admissionv1.Create, admissionv1.Update:<span class="cov8" title="1">
                resp = v.performLabelValidation(ctx, &amp;req, obj)</span>
        default:<span class="cov8" title="1">
                resp = admission.Allowed(fmt.Sprintf("Operation %s on %s allowed", req.Operation, req.Kind.Kind))</span>
        }

        <span class="cov8" title="1">return resp</span>
}

// isExpectedKind checks if the given GroupVersionKind is one of the expected resource types
// that the Kueue webhook should handle.
//
// Parameters:
//   - kind: The GroupVersionKind from the admission request
//
// Returns:
//   - bool: true if the kind is expected, false otherwise
func isExpectedKind(kind metav1.GroupVersionKind) bool <span class="cov8" title="1">{
        // List of expected resource types that the Kueue webhook should handle
        expectedGVKs := []schema.GroupVersionKind{
                gvk.Notebook,           // kubeflow.org/v1/Notebook
                gvk.PyTorchJob,         // kubeflow.org/v1/PyTorchJob
                gvk.RayJobV1Alpha1,     // ray.io/v1alpha1/RayJob
                gvk.RayJobV1,           // ray.io/v1/RayJob
                gvk.RayClusterV1Alpha1, // ray.io/v1alpha1/RayCluster
                gvk.RayClusterV1,       // ray.io/v1/RayCluster
                gvk.InferenceServices,  // serving.kserve.io/v1beta1/InferenceService
        }

        requestGVK := schema.GroupVersionKind{
                Group:   kind.Group,
                Version: kind.Version,
                Kind:    kind.Kind,
        }

        for _, expectedGVK := range expectedGVKs </span><span class="cov8" title="1">{
                if requestGVK == expectedGVK </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// isKueueEnabledInDSC checks if Kueue is enabled in the DataScienceCluster (DSC).
//
// Parameters:
//   - ctx: Context for the API call
//   - cli: The controller-runtime client to use for checking Kueue status in the DSC
//
// Returns:
//   - bool: true if Kueue is enabled, false otherwise
//   - error: Any error encountered while checking Kueue status in the DSC
func isKueueEnabledInDSC(ctx context.Context, cli client.Reader) (bool, error) <span class="cov8" title="1">{
        dsc, err := cluster.GetDSC(ctx, cli)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">state := dsc.Status.Components.Kueue.ManagementState
        // Kueue is considered enabled if it is either Managed or Unmanaged
        return state == operatorv1.Managed || state == operatorv1.Unmanaged, nil</span>
}

// validateNamespaceLabels checks if the given namespace is labeled for Kueue management.
//
// Parameters:
//   - ns: The namespace metadata to check for Kueue labels
//
// Returns:
//   - bool: true if the namespace is labeled for Kueue management, false otherwise
func validateNamespaceLabels(ns client.Object) bool <span class="cov8" title="1">{
        return resources.HasLabel(ns, cluster.KueueManagedLabelKey, "true") ||
                resources.HasLabel(ns, cluster.KueueLegacyManagedLabelKey, "true")
}</span>

// isNamespaceManagedByKueue checks if the given namespace is labeled for Kueue management.
//
// Parameters:
//   - ctx: Context for the API call
//   - cli: The controller-runtime client to use for checking the namespace labels
//   - namespace: The name of the namespace to check
//
// Returns:
//   - bool: true if the namespace is labeled for Kueue, false otherwise
//   - error: Any error encountered while checking the namespace labels
func isNamespaceManagedByKueue(ctx context.Context, cli client.Reader, namespace string) (bool, error) <span class="cov8" title="1">{
        ns := &amp;metav1.PartialObjectMetadata{}
        ns.SetGroupVersionKind(gvk.Namespace)

        if err := cli.Get(ctx, types.NamespacedName{Name: namespace}, ns); err != nil </span><span class="cov0" title="0">{
                // Unable to get the namespace, return an error
                return false, err
        }</span>

        <span class="cov8" title="1">return validateNamespaceLabels(ns), nil</span>
}

// validateKueueLabels checks if the required Kueue labels are present and valid.
//
// Parameters:
//   - labels: The map of labels to validate
//
// Returns:
//   - error: If the required label is missing or empty, returns an error
func validateKueueLabels(labels map[string]string) error <span class="cov8" title="1">{
        if labels == nil </span><span class="cov8" title="1">{
                // Labels map is nil, which means no labels are set
                return ErrMissingRequiredLabel
        }</span>

        <span class="cov8" title="1">queueName, ok := labels[cluster.KueueQueueNameLabel]

        if !ok </span><span class="cov0" title="0">{
                // Required label is missing
                return ErrMissingRequiredLabel
        }</span>

        <span class="cov8" title="1">if queueName == "" </span><span class="cov8" title="1">{
                // Required label is present but empty
                return ErrEmptyRequiredLabel
        }</span>

        // All required labels are present and valid
        <span class="cov8" title="1">return nil</span>
}

// performLabelValidation checks if the Kueue labels are present and valid for the given request.
//
// Parameters:
//   - ctx: Context for the admission request
//   - req: The admission.Request containing the operation and object details
//
// Returns:
//   - admission.Response: The result of the label validation, indicating whether the operation is allowed or denied
func (v *Validator) performLabelValidation(ctx context.Context, req *admission.Request, obj *unstructured.Unstructured) admission.Response <span class="cov8" title="1">{
        log := logf.FromContext(ctx)
        namespace := req.Namespace

        // Object already decoded in Handle method and passed as parameter

        // Check if the namespace is labeled for Kueue management
        // TODO: to be removed: https://issues.redhat.com/browse/RHOAIENG-27558
        kueueManagedNamespace, err := isNamespaceManagedByKueue(ctx, v.Client, namespace)
        if err != nil </span><span class="cov0" title="0">{
                // Unable to determine if the namespace is labeled for Kueue, return an error response
                log.Error(err, "failed to check namespace Kueue labels", "namespace", namespace)
                return admission.Errored(http.StatusInternalServerError, fmt.Errorf("failed to check if namespace %q is labeled for Kueue: %w", namespace, err))
        }</span>

        <span class="cov8" title="1">if !kueueManagedNamespace </span><span class="cov8" title="1">{
                // Namespace is not labeled for Kueue
                return admission.Allowed(fmt.Sprintf("Namespace %q is not labeled for Kueue (%q), skipping Kueue label validation", namespace, cluster.KueueManagedLabelKey))
        }</span>

        // Check if Kueue is enabled in the DataScienceCluster (DSC)
        <span class="cov8" title="1">kueueEnabled, err := isKueueEnabledInDSC(ctx, v.Client)

        switch </span>{
        case err != nil &amp;&amp; k8serr.IsNotFound(err):<span class="cov0" title="0">
                // DSC not found — skip validation
                return admission.Allowed("No DataScienceCluster found, skipping Kueue label validation")</span>
        case err != nil:<span class="cov0" title="0">
                // Unable to determine if Kueue is enabled, return an error response
                log.Error(err, "failed to check if Kueue is enabled in DSC")
                return admission.Errored(http.StatusInternalServerError, fmt.Errorf("failed to check if Kueue is enabled: %w", err))</span>
        case !kueueEnabled:<span class="cov8" title="1">
                // Kueue is not enabled in the DSC
                return admission.Allowed("Kueue is not enabled in DSC, skipping Kueue label validation")</span>
        }

        // Check if the workload has Kueue labels
        <span class="cov8" title="1">if err := validateKueueLabels(obj.GetLabels()); err != nil </span><span class="cov8" title="1">{
                // No Kueue labels found
                return admission.Denied(fmt.Sprintf("Kueue label validation failed: %v", err))
        }</span>

        // Kueue is enabled, namespace is labeled for Kueue, and workload has Kueue labels
        <span class="cov8" title="1">return admission.Allowed(fmt.Sprintf("Kueue label validation passed for %q in namespace %q", req.Kind.Kind, namespace))</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">//go:build !nowebhook

package notebook

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"

        admissionv1 "k8s.io/api/admission/v1"
        authorizationv1 "k8s.io/api/authorization/v1"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
        webhookutils "github.com/opendatahub-io/opendatahub-operator/v2/pkg/webhook"
)

var (
        NotebookContainersPath = []string{"spec", "template", "spec", "containers"}
)

//+kubebuilder:webhook:path=/platform-connection-notebook,mutating=true,failurePolicy=fail,groups=kubeflow.org,resources=notebooks,verbs=create;update,versions=v1,name=connection-notebook.opendatahub.io,sideEffects=None,admissionReviewVersions=v1
//nolint:lll

// Validator implements webhook.AdmissionHandler for Notebook connection validation webhooks.
type NotebookWebhook struct {
        Client    client.Client // used to create SubjectAccessReview
        APIReader client.Reader // used to read secrets in namespaces that are not cached
        Decoder   admission.Decoder
        Name      string
}

// Assert that NotebookWebhook implements admission.Handler interface.
var _ admission.Handler = &amp;NotebookWebhook{}

func (w *NotebookWebhook) SetupWithManager(mgr ctrl.Manager) error <span class="cov7" title="9">{
        hookServer := mgr.GetWebhookServer()
        hookServer.Register("/platform-connection-notebook", &amp;webhook.Admission{
                Handler:        w,
                LogConstructor: webhookutils.NewWebhookLogConstructor(w.Name),
        })
        return nil
}</span>

func (w *NotebookWebhook) Handle(ctx context.Context, req admission.Request) admission.Response <span class="cov9" title="26">{
        log := logf.FromContext(ctx)

        if w.Decoder == nil </span><span class="cov0" title="0">{
                log.Error(nil, "Decoder is nil - webhook not properly initialized")
                return admission.Errored(http.StatusInternalServerError, errors.New("webhook decoder not initialized"))
        }</span>

        // Decode the notebook from the request
        <span class="cov9" title="26">notebook := &amp;unstructured.Unstructured{}
        if err := w.Decoder.Decode(req, notebook); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to decode object")
                return admission.Errored(http.StatusBadRequest, fmt.Errorf("failed to decode object: %w", err))
        }</span>

        // Skip processing if object is marked for deletion
        <span class="cov9" title="26">if !notebook.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return admission.Allowed("Object marked for deletion, skipping connection logic")
        }</span>

        <span class="cov9" title="26">var resp admission.Response

        switch req.Operation </span>{
        case admissionv1.Create, admissionv1.Update:<span class="cov9" title="25">
                validationResp, shouldInject, secretRefs := w.validateNotebookConnectionAnnotation(ctx, notebook, &amp;req)
                if !validationResp.Allowed </span><span class="cov7" title="12">{
                        return validationResp
                }</span>

                // Skip proceeding to injection if shouldInject is false or the secretRefs nil
                <span class="cov8" title="14">if !shouldInject || secretRefs == nil </span><span class="cov5" title="5">{
                        return admission.Allowed(fmt.Sprintf("Connection annotation validation passed in namespace %s for %s, no injection needed", req.Namespace, req.Kind.Kind))
                }</span>

                <span class="cov7" title="10">injectionPerformed, obj, err := w.performConnectionInjection(notebook, secretRefs)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Failed to perform connection injection")
                        return admission.Errored(http.StatusInternalServerError, err)
                }</span>

                <span class="cov7" title="10">if injectionPerformed </span><span class="cov7" title="10">{
                        marshaledObj, err := json.Marshal(obj)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "Failed to marshal modified object")
                                return admission.Errored(http.StatusInternalServerError, err)
                        }</span>
                        <span class="cov7" title="10">return admission.PatchResponseFromRaw(req.Object.Raw, marshaledObj)</span>
                }

        default:<span class="cov2" title="2">
                resp = admission.Allowed(fmt.Sprintf("Operation %s on %s allowed", req.Operation, req.Kind.Kind))</span>
        }

        <span class="cov2" title="2">return resp</span>
}

// validateNotebookConnectionAnnotation validates the connection annotation "opendatahub.io/connections"
// If the annotation exists and has a non-empty value, it validates that the value references valid secret(s).
// Additionally, it checks that user requesting the notebook operation has the required permissions to get the secret(s)
// If the annotation doesn't exist or is empty, it allows the operation.
func (w *NotebookWebhook) validateNotebookConnectionAnnotation(
        ctx context.Context,
        nb *unstructured.Unstructured,
        req *admission.Request,
) (admission.Response, bool, []corev1.SecretReference) <span class="cov9" title="25">{
        log := logf.FromContext(ctx)

        annotationValue := resources.GetAnnotation(nb, annotations.Connection)
        if annotationValue == "" </span><span class="cov4" title="4">{
                return admission.Allowed(fmt.Sprintf("Annotation '%s' not present or empty value, skipping validation", annotations.Connection)), false, nil
        }</span>

        // Parse the connections annotation
        <span class="cov9" title="22">connectionSecrets, err := parseConnectionsAnnotation(annotationValue)
        if err != nil </span><span class="cov6" title="7">{
                log.Error(err, "failed to parse connections annotation", "annotationValue", annotationValue)
                return admission.Denied(fmt.Sprintf("failed to parse connections annotation: %v", err)), false, nil
        }</span>

        // Validate each connection secret exists and the user has permission to get each secret
        <span class="cov8" title="16">secretExistsErrors, permissionsErrors, err := w.checkSecretsExistsAndUserHasPermissions(ctx, req, connectionSecrets)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error verifying secret(s) exist or confirming user has get permissions for the secret(s)", "connectionSecrets", connectionSecrets)
                return admission.Errored(http.StatusInternalServerError, fmt.Errorf("error verifying secret(s) exist/user has permissions for them %s: %w", connectionSecrets, err)), false, nil
        }</span>

        <span class="cov8" title="16">if len(secretExistsErrors) &gt; 0 </span><span class="cov4" title="4">{
                return admission.Denied(fmt.Sprintf("some of the connection secret(s) do not exist or are outside the Notebook's namespace: %s",
                        strings.Join(secretExistsErrors, ", "))), false, nil
        }</span>

        <span class="cov8" title="13">if len(permissionsErrors) &gt; 0 </span><span class="cov4" title="3">{
                return admission.Denied(fmt.Sprintf("user does not have permission to access the following connection secret(s): %s", strings.Join(permissionsErrors, ", "))), false, nil
        }</span>

        <span class="cov7" title="11">return admission.Allowed("Connection permissions validated successfully"), true, connectionSecrets</span>
}

// parseConnectionsAnnotation parses the connections annotation value into a list of secret references.
// The annotation value should be a comma-separated list of fully qualified secret names (namespace/name).
func parseConnectionsAnnotation(value string) ([]corev1.SecretReference, error) <span class="cov9" title="22">{
        if strings.TrimSpace(value) == "" </span><span class="cov2" title="2">{
                return nil, nil
        }</span>

        <span class="cov9" title="21">parts := strings.Split(value, ",")
        secretRefs := make([]corev1.SecretReference, 0)

        for _, part := range parts </span><span class="cov10" title="27">{
                part = strings.TrimSpace(part)
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse namespace/name format
                <span class="cov10" title="27">secretParts := strings.Split(part, "/")
                if len(secretParts) != 2 </span><span class="cov4" title="3">{
                        return nil, fmt.Errorf("invalid secret reference format '%s' - expected 'namespace/name'", part)
                }</span>

                <span class="cov9" title="25">namespace := strings.TrimSpace(secretParts[0])
                name := strings.TrimSpace(secretParts[1])

                if namespace == "" || name == "" </span><span class="cov5" title="5">{
                        return nil, fmt.Errorf("invalid secret reference '%s' - namespace and name cannot be empty", part)
                }</span>

                <span class="cov9" title="21">secretRefs = append(secretRefs, corev1.SecretReference{
                        Name:      name,
                        Namespace: namespace,
                })</span>
        }

        <span class="cov8" title="15">return secretRefs, nil</span>
}

// checkSecretsExistsAndUserHasPermissions checks that each connection secret exists
// It also verifies that the user has permission to "get" the specified secrets using SubjectAccessReviews.
func (w *NotebookWebhook) checkSecretsExistsAndUserHasPermissions(ctx context.Context, req *admission.Request, secretRefs []corev1.SecretReference) ([]string, []string, error) <span class="cov8" title="16">{
        log := logf.FromContext(ctx)

        var secretExistsErrors []string
        var permissionErrors []string

        for _, secretRef := range secretRefs </span><span class="cov9" title="21">{
                // First check if the secret is in the same namespace as the notebook
                // TODO: this can be removed once we support cross-namespace secret references.
                log.V(1).Info("checking that secret in the same namespace as the notebook CR")
                if secretRef.Namespace != req.Namespace </span><span class="cov4" title="3">{
                        secretExistsErrors = append(secretExistsErrors, fmt.Sprintf("%s/%s", secretRef.Namespace, secretRef.Name))
                        continue</span>
                }
                // Second check if the secret even exists using APIReader to bypass cache
                <span class="cov9" title="19">log.V(1).Info("checking that secret exists", "secret", secretRef.Name, "namespace", secretRef.Namespace)
                if err := w.APIReader.Get(ctx, client.ObjectKey{Namespace: secretRef.Namespace, Name: secretRef.Name}, &amp;corev1.Secret{}); err != nil </span><span class="cov4" title="4">{
                        if k8serr.IsNotFound(err) </span><span class="cov4" title="4">{
                                secretExistsErrors = append(secretExistsErrors, fmt.Sprintf("%s/%s", secretRef.Namespace, secretRef.Name))
                                continue</span>
                        }
                        <span class="cov0" title="0">log.Error(err, "failed to check if secret exists", "secret", secretRef.Name, "namespace", secretRef.Namespace)
                        return nil, nil, fmt.Errorf("failed to check if secret exists: %w", err)</span>
                }

                // Create a SubjectAccessReview to check if the user can "get" the secret
                <span class="cov8" title="16">log.V(1).Info("checking permission for secret", "secret", secretRef.Name, "namespace", secretRef.Namespace)
                sar := &amp;authorizationv1.SubjectAccessReview{
                        Spec: authorizationv1.SubjectAccessReviewSpec{
                                User:   req.UserInfo.Username,
                                Groups: req.UserInfo.Groups,
                                ResourceAttributes: &amp;authorizationv1.ResourceAttributes{
                                        Namespace: secretRef.Namespace,
                                        Verb:      "get",
                                        Group:     "",
                                        Version:   "v1",
                                        Resource:  "secrets",
                                        Name:      secretRef.Name,
                                },
                        },
                }

                // Send the SubjectAccessReview to the API server to verify permission
                if err := w.Client.Create(ctx, sar); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to create SubjectAccessReview", "secret", secretRef.Name, "namespace", secretRef.Namespace)
                        return nil, nil, fmt.Errorf("failed to create SubjectAccessReview: %w", err)
                }</span>

                // Check the result
                <span class="cov8" title="16">if !sar.Status.Allowed </span><span class="cov4" title="3">{
                        log.V(1).Info("user does not have permission to access secret",
                                "secret", secretRef.Name,
                                "namespace", secretRef.Namespace,
                                "reason", sar.Status.Reason,
                                "evaluationError", sar.Status.EvaluationError,
                        )
                        permissionErrors = append(permissionErrors, fmt.Sprintf("%s/%s", secretRef.Namespace, secretRef.Name))
                }</span>

                <span class="cov8" title="16">log.V(1).Info("user has permission to access secret", "secret", secretRef.Name, "namespace", secretRef.Namespace)</span>
        }

        <span class="cov8" title="16">return secretExistsErrors, permissionErrors, nil</span>
}

func (w *NotebookWebhook) performConnectionInjection(nb *unstructured.Unstructured, secretRefs []corev1.SecretReference) (bool, *unstructured.Unstructured, error) <span class="cov7" title="10">{
        // Get the notebook containers
        containers, found, err := unstructured.NestedSlice(nb.Object, NotebookContainersPath...)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get containers array: %w", err)
        }</span>
        <span class="cov7" title="10">if !found || len(containers) == 0 </span><span class="cov0" title="0">{
                return false, nil, errors.New("no containers found in notebook")
        }</span>

        // The notebook only has one container, so we can get the envFrom from the first container
        <span class="cov7" title="10">container, ok := containers[0].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return false, nil, errors.New("first container is not a map[string]interface{}")
        }</span>

        // Get existing envFrom from the container
        <span class="cov7" title="10">existingEnvFrom, _ := container["envFrom"].([]interface{})

        // Keep only non-secretRef entries (like configMapRef)
        var preservedEntries []interface{}
        for _, entry := range existingEnvFrom </span><span class="cov4" title="3">{
                if entryMap, ok := entry.(map[string]interface{}); ok </span><span class="cov4" title="3">{
                        if _, hasSecretRef := entryMap["secretRef"]; !hasSecretRef </span><span class="cov2" title="2">{
                                preservedEntries = append(preservedEntries, entry)
                        }</span>
                }
        }

        // Add all connection secrets
        <span class="cov7" title="10">newEnvFrom := preservedEntries
        for _, secretRef := range secretRefs </span><span class="cov7" title="12">{
                secretEntry := map[string]interface{}{
                        "secretRef": map[string]interface{}{
                                "name": secretRef.Name,
                        },
                }
                newEnvFrom = append(newEnvFrom, secretEntry)
        }</span>

        // Set the updated envFrom back to the container
        <span class="cov7" title="10">container["envFrom"] = newEnvFrom

        // Update the first container in the containers array
        containers[0] = container

        // Set the modified containers array back to the object
        if err := unstructured.SetNestedSlice(nb.Object, containers, NotebookContainersPath...); err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to set containers array: %w", err)
        }</span>

        <span class="cov7" title="10">return true, nb, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">//go:build !nowebhook

package notebook

import (
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// RegisterWebhooks registers the combined connection webhook that handles both validation and mutation for notebooks.
func RegisterWebhooks(mgr ctrl.Manager) error <span class="cov0" title="0">{
        if err := (&amp;NotebookWebhook{
                Client:    mgr.GetClient(),
                APIReader: mgr.GetAPIReader(),
                Decoder:   admission.NewDecoder(mgr.GetScheme()),
                Name:      "notebook-webhook",
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package cluster

import (
        "bytes"
        "context"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "net"
        "strings"
        "time"

        operatorv1 "github.com/openshift/api/operator/v1"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

const (
        CertFieldOwner   = resources.PlatformFieldOwner + "/cert"
        IngressNamespace = "openshift-ingress"
)

var IngressControllerName = types.NamespacedName{
        Namespace: "openshift-ingress-operator",
        Name:      "default",
}

func CreateSelfSignedCertificate(ctx context.Context, c client.Client, secretName, domain, namespace string, metaOptions ...MetaOptions) error <span class="cov0" title="0">{
        certSecret, err := GenerateSelfSignedCertificateAsSecret(secretName, domain, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed generating self-signed certificate: %w", err)
        }</span>

        <span class="cov0" title="0">if errApply := ApplyMetaOptions(certSecret, metaOptions...); errApply != nil </span><span class="cov0" title="0">{
                return errApply
        }</span>

        <span class="cov0" title="0">opts := []client.PatchOption{
                client.ForceOwnership,
                client.FieldOwner(CertFieldOwner),
        }
        err = resources.Apply(ctx, c, certSecret, opts...)
        if err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func GenerateSelfSignedCertificateAsSecret(name, addr, namespace string) (*corev1.Secret, error) <span class="cov0" title="0">{
        cert, key, err := generateCertificate(addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error generating certificate: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;corev1.Secret{
                TypeMeta: metav1.TypeMeta{
                        Kind:       gvk.Secret.Kind,
                        APIVersion: gvk.Secret.Version,
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Data: map[string][]byte{
                        corev1.TLSCertKey:       cert,
                        corev1.TLSPrivateKeyKey: key,
                },
                Type: corev1.SecretTypeTLS,
        }, nil</span>
}

func generateCertificate(addr string) ([]byte, []byte, error) <span class="cov0" title="0">{
        key, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error generating key: %w", err)
        }</span>

        <span class="cov0" title="0">seededRand, cryptErr := rand.Int(rand.Reader, big.NewInt(time.Now().UnixNano()))
        if cryptErr != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error generating random: %w", cryptErr)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        tmpl := x509.Certificate{
                SerialNumber: seededRand,
                Subject: pkix.Name{
                        CommonName:   addr,
                        Organization: []string{"opendatahub-self-signed"},
                },
                NotBefore:             now.UTC(),
                NotAfter:              now.Add(time.Second * 60 * 60 * 24 * 365).UTC(),
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                BasicConstraintsValid: true,
                IsCA:                  true,
        }

        if ip := net.ParseIP(addr); ip != nil </span><span class="cov0" title="0">{
                tmpl.IPAddresses = append(tmpl.IPAddresses, ip)
        }</span> else<span class="cov0" title="0"> {
                if strings.HasPrefix(addr, "*.") </span><span class="cov0" title="0">{
                        tmpl.DNSNames = append(tmpl.DNSNames, addr[2:])
                }</span>
                <span class="cov0" title="0">tmpl.DNSNames = append(tmpl.DNSNames, addr)</span>
        }

        <span class="cov0" title="0">tmpl.DNSNames = append(tmpl.DNSNames, "localhost")

        certDERBytes, err := x509.CreateCertificate(rand.Reader, &amp;tmpl, &amp;tmpl, key.Public(), key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error creating certificate: %w", err)
        }</span>
        <span class="cov0" title="0">certificate, err := x509.ParseCertificate(certDERBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error parsing certificate: %w", err)
        }</span>

        <span class="cov0" title="0">certBuffer := bytes.Buffer{}
        if err := pem.Encode(&amp;certBuffer, &amp;pem.Block{
                Type:  "CERTIFICATE",
                Bytes: certificate.Raw,
        }); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error encoding pem: %w", err)
        }</span>

        <span class="cov0" title="0">keyBuffer := bytes.Buffer{}
        if err := pem.Encode(&amp;keyBuffer, &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(key),
        }); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error encoding pem: %w", err)
        }</span>

        <span class="cov0" title="0">return certBuffer.Bytes(), keyBuffer.Bytes(), nil</span>
}

func FindDefaultIngressSecret(ctx context.Context, c client.Client) (*corev1.Secret, error) <span class="cov0" title="0">{
        defaultIngressCtrl, err := FindAvailableIngressController(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get ingress controller: %w", err)
        }</span>

        <span class="cov0" title="0">defaultIngressCertName := GetDefaultIngressCertSecretName(defaultIngressCtrl)

        defaultIngressSecret, err := GetSecret(ctx, c, IngressNamespace, defaultIngressCertName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return defaultIngressSecret, nil</span>
}

// PropagateDefaultIngressCertificate copies ingress cert secrets from openshift-ingress ns to given namespace.
func PropagateDefaultIngressCertificate(ctx context.Context, c client.Client, secretName, namespace string) error <span class="cov0" title="0">{
        defaultIngressSecret, err := FindDefaultIngressSecret(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return copySecretToNamespace(ctx, c, defaultIngressSecret, secretName, namespace)</span>
}

func FindAvailableIngressController(ctx context.Context, c client.Client) (*operatorv1.IngressController, error) <span class="cov0" title="0">{
        defaultIngressCtrl := &amp;operatorv1.IngressController{}

        err := c.Get(ctx, IngressControllerName, defaultIngressCtrl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting ingresscontroller resource :%w", err)
        }</span>
        <span class="cov0" title="0">return defaultIngressCtrl, nil</span>
}

func GetDefaultIngressCertSecretName(ingressCtrl *operatorv1.IngressController) string <span class="cov0" title="0">{
        if ingressCtrl.Spec.DefaultCertificate != nil </span><span class="cov0" title="0">{
                return ingressCtrl.Spec.DefaultCertificate.Name
        }</span>
        <span class="cov0" title="0">return "router-certs-" + ingressCtrl.Name</span>
}

func GetSecret(ctx context.Context, c client.Client, namespace, name string) (*corev1.Secret, error) <span class="cov0" title="0">{
        secret := &amp;corev1.Secret{}
        err := c.Get(ctx, client.ObjectKey{Namespace: namespace, Name: name}, secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return secret, nil</span>
}

func copySecretToNamespace(ctx context.Context, c client.Client, secret *corev1.Secret, newSecretName, namespace string) error <span class="cov0" title="0">{
        newSecret := &amp;corev1.Secret{
                TypeMeta: metav1.TypeMeta{
                        Kind:       gvk.Secret.Kind,
                        APIVersion: gvk.Secret.Version,
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      newSecretName,
                        Namespace: namespace,
                },
                Data: secret.Data,
                Type: secret.Type,
        }

        opts := []client.PatchOption{
                client.ForceOwnership,
                client.FieldOwner(CertFieldOwner),
        }
        err := resources.Apply(ctx, c, newSecret, opts...)
        if err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package cluster

import (
        "context"
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/blang/semver/v4"
        "github.com/go-logr/logr"
        configv1 "github.com/openshift/api/config/v1"
        "github.com/operator-framework/api/pkg/lib/version"
        ofapiv1alpha1 "github.com/operator-framework/api/pkg/operators/v1alpha1"
        "github.com/spf13/viper"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/yaml"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
)

type ClusterInfo struct {
        Type        string                  `json:"type,omitempty"` // openshift , TODO: can be other value if we later support other type
        Version     version.OperatorVersion `json:"version,omitempty"`
        FipsEnabled bool                    `json:"fips_enabled,omitempty"`
}

var clusterConfig struct {
        Namespace   string
        Release     common.Release
        ClusterInfo ClusterInfo
}

type InstallConfig struct {
        FIPS bool `json:"fips"`
}

// Init initializes cluster configuration variables on startup
// init() won't work since it is needed to check the error.
func Init(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        var err error
        log := logf.FromContext(ctx)

        clusterConfig.Namespace, err = getOperatorNamespace()
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "unable to find operator namespace")
                // not fatal, fallback to ""
        }</span>

        <span class="cov0" title="0">clusterConfig.Release, err = getRelease(ctx, cli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">clusterConfig.ClusterInfo, err = getClusterInfo(ctx, cli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = setManagedMonitoringNamespace(ctx, cli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">printClusterConfig(log)
        return nil</span>
}

func printClusterConfig(log logr.Logger) <span class="cov0" title="0">{
        log.Info("Cluster config",
                "Operator Namespace", clusterConfig.Namespace,
                "Release", clusterConfig.Release,
                "Cluster", clusterConfig.ClusterInfo)
}</span>

func GetOperatorNamespace() (string, error) <span class="cov0" title="0">{
        if clusterConfig.Namespace == "" </span><span class="cov0" title="0">{
                return "", errors.New("unable to find operator namespace")
        }</span>
        <span class="cov0" title="0">return clusterConfig.Namespace, nil</span>
}

func GetRelease() common.Release <span class="cov0" title="0">{
        return clusterConfig.Release
}</span>

func GetClusterInfo() ClusterInfo <span class="cov0" title="0">{
        return clusterConfig.ClusterInfo
}</span>

func GetDomain(ctx context.Context, c client.Client) (string, error) <span class="cov0" title="0">{
        ingress := &amp;unstructured.Unstructured{}
        ingress.SetGroupVersionKind(gvk.OpenshiftIngress)

        if err := c.Get(ctx, client.ObjectKey{
                Namespace: "",
                Name:      "cluster",
        }, ingress); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed fetching cluster's ingress details: %w", err)
        }</span>

        <span class="cov0" title="0">domain, found, err := unstructured.NestedString(ingress.Object, "spec", "domain")
        if !found </span><span class="cov0" title="0">{
                return "", errors.New("spec.domain not found")
        }</span>

        <span class="cov0" title="0">return domain, err</span>
}

// This is an Openshift specific implementation.
func getOCPVersion(ctx context.Context, c client.Client) (version.OperatorVersion, error) <span class="cov0" title="0">{
        clusterVersion := &amp;configv1.ClusterVersion{}
        if err := c.Get(ctx, client.ObjectKey{
                Name: OpenShiftVersionObj,
        }, clusterVersion); err != nil </span><span class="cov0" title="0">{
                return version.OperatorVersion{}, errors.New("unable to get OCP version")
        }</span>
        <span class="cov0" title="0">v, err := semver.ParseTolerant(clusterVersion.Status.History[0].Version)
        if err != nil </span><span class="cov0" title="0">{
                return version.OperatorVersion{}, errors.New("unable to parse OCP version")
        }</span>
        <span class="cov0" title="0">return version.OperatorVersion{Version: v}, nil</span>
}

func getOperatorNamespace() (string, error) <span class="cov0" title="0">{
        operatorNS, exist := os.LookupEnv("OPERATOR_NAMESPACE")
        if exist &amp;&amp; operatorNS != "" </span><span class="cov0" title="0">{
                return operatorNS, nil
        }</span>
        <span class="cov0" title="0">data, err := os.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace")
        return string(data), err</span>
}

func IsNotReservedNamespace(ns *corev1.Namespace) bool <span class="cov0" title="0">{
        return !IsReservedNamespace(ns)
}</span>

func IsReservedNamespace(ns *corev1.Namespace) bool <span class="cov0" title="0">{
        switch </span>{
        case strings.HasPrefix(ns.GetName(), "openshift-"):<span class="cov0" title="0">
                return true</span>
        case strings.HasPrefix(ns.GetName(), "kube-"):<span class="cov0" title="0">
                return true</span>
        case ns.GetName() == "default":<span class="cov0" title="0">
                return true</span>
        case ns.GetName() == "openshift":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func IsActiveNamespace(ns *corev1.Namespace) bool <span class="cov0" title="0">{
        return ns.Status.Phase == corev1.NamespaceActive
}</span>

// GetClusterServiceVersion retries CSV only from the defined namespace.
func GetClusterServiceVersion(ctx context.Context, c client.Client, namespace string) (*ofapiv1alpha1.ClusterServiceVersion, error) <span class="cov0" title="0">{
        clusterServiceVersionList := &amp;ofapiv1alpha1.ClusterServiceVersionList{}
        paginateListOption := &amp;client.ListOptions{
                Limit:     100,
                Namespace: namespace,
        }
        for </span><span class="cov0" title="0">{ // for the case we have very big size of CSV even just in one namespace
                if err := c.List(ctx, clusterServiceVersionList, paginateListOption); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed listing cluster service versions for %s: %w", namespace, err)
                }</span>
                <span class="cov0" title="0">for _, csv := range clusterServiceVersionList.Items </span><span class="cov0" title="0">{
                        for _, operatorCR := range csv.Spec.CustomResourceDefinitions.Owned </span><span class="cov0" title="0">{
                                if operatorCR.Kind == "DataScienceCluster" </span><span class="cov0" title="0">{
                                        return &amp;csv, nil
                                }</span>
                        }
                }
                <span class="cov0" title="0">if paginateListOption.Continue = clusterServiceVersionList.GetContinue(); paginateListOption.Continue == "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil, k8serr.NewNotFound(
                schema.GroupResource{Group: gvk.ClusterServiceVersion.Group},
                gvk.ClusterServiceVersion.Kind)</span>
}

// detectSelfManaged detects if it is Self Managed Rhoai or OpenDataHub.
func detectSelfManaged(ctx context.Context, cli client.Client) (common.Platform, error) <span class="cov0" title="0">{
        exists, err := OperatorExists(ctx, cli, "rhods-operator")
        if exists </span><span class="cov0" title="0">{
                return SelfManagedRhoai, nil
        }</span>

        <span class="cov0" title="0">return OpenDataHub, err</span>
}

// detectManagedRhoai checks if catsrc CR add-on exists ManagedRhoai.
func detectManagedRhoai(ctx context.Context, cli client.Client) (common.Platform, error) <span class="cov0" title="0">{
        catalogSource := &amp;ofapiv1alpha1.CatalogSource{}
        operatorNs, err := GetOperatorNamespace()
        if err != nil </span><span class="cov0" title="0">{
                operatorNs = "redhat-ods-operator"
        }</span>
        <span class="cov0" title="0">err = cli.Get(ctx, client.ObjectKey{Name: "addon-managed-odh-catalog", Namespace: operatorNs}, catalogSource)
        if err != nil </span><span class="cov0" title="0">{
                return OpenDataHub, client.IgnoreNotFound(err)
        }</span>
        <span class="cov0" title="0">return ManagedRhoai, nil</span>
}

func getPlatform(ctx context.Context, cli client.Client) (common.Platform, error) <span class="cov0" title="0">{
        switch os.Getenv("ODH_PLATFORM_TYPE") </span>{
        case "OpenDataHub":<span class="cov0" title="0">
                return OpenDataHub, nil</span>
        case "ManagedRHOAI":<span class="cov0" title="0">
                return ManagedRhoai, nil</span>
        case "SelfManagedRHOAI":<span class="cov0" title="0">
                return SelfManagedRhoai, nil</span>
        default:<span class="cov0" title="0">
                // fall back to detect platform if ODH_PLATFORM_TYPE env is not provided in CSV or set to ""
                platform, err := detectManagedRhoai(ctx, cli)
                if err != nil </span><span class="cov0" title="0">{
                        return OpenDataHub, err
                }</span>
                <span class="cov0" title="0">if platform == ManagedRhoai </span><span class="cov0" title="0">{
                        return ManagedRhoai, nil
                }</span>
                <span class="cov0" title="0">return detectSelfManaged(ctx, cli)</span>
        }
}

func getRelease(ctx context.Context, cli client.Client) (common.Release, error) <span class="cov0" title="0">{
        initRelease := common.Release{
                // dummy version set to name "", version 0.0.0
                Version: version.OperatorVersion{
                        Version: semver.Version{},
                },
        }

        // Set platform
        platform, err := getPlatform(ctx, cli)
        if err != nil </span><span class="cov0" title="0">{
                return initRelease, err
        }</span>
        <span class="cov0" title="0">initRelease.Name = platform

        // For unit-tests
        if os.Getenv("CI") == "true" </span><span class="cov0" title="0">{
                return initRelease, nil
        }</span>

        // Set Version
        // Get watchNamespace
        <span class="cov0" title="0">operatorNamespace, err := GetOperatorNamespace()
        if err != nil </span><span class="cov0" title="0">{
                // unit test does not have k8s file or env var set, return default
                return initRelease, err
        }</span>
        <span class="cov0" title="0">csv, err := GetClusterServiceVersion(ctx, cli, operatorNamespace)
        if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                // hide not found, return default
                return initRelease, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return initRelease, err
        }</span>
        <span class="cov0" title="0">initRelease.Version = csv.Spec.Version
        return initRelease, nil</span>
}

func getClusterInfo(ctx context.Context, cli client.Client) (ClusterInfo, error) <span class="cov0" title="0">{
        c := ClusterInfo{
                Version: version.OperatorVersion{
                        Version: semver.Version{},
                },
                Type:        "OpenShift",
                FipsEnabled: false,
        }
        // Set OCP
        ocpVersion, err := getOCPVersion(ctx, cli)
        if err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>
        <span class="cov0" title="0">c.Version = ocpVersion

        // Check for FIPs
        if fipsEnabled, err := IsFipsEnabled(ctx, cli); err == nil </span><span class="cov0" title="0">{
                c.FipsEnabled = fipsEnabled
        }</span> else<span class="cov0" title="0"> {
                logf.FromContext(ctx).Info("could not determine FIPS status, defaulting to false", "error", err)
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

func IsFipsEnabled(ctx context.Context, cli client.Client) (bool, error) <span class="cov10" title="65">{
        // Check the install-config for the fips flag and it's value
        // https://access.redhat.com/solutions/6525331
        cm := &amp;corev1.ConfigMap{}
        namespacedName := types.NamespacedName{
                Name:      "cluster-config-v1",
                Namespace: "kube-system",
        }

        if err := cli.Get(ctx, namespacedName, cm); err != nil </span><span class="cov7" title="17">{
                return false, err
        }</span>

        <span class="cov9" title="49">installConfigStr := cm.Data["install-config"]
        if installConfigStr == "" </span><span class="cov5" title="9">{
                // No install-config found or empty
                return false, nil
        }</span>

        <span class="cov9" title="41">var installConfig InstallConfig
        if err := yaml.Unmarshal([]byte(installConfigStr), &amp;installConfig); err != nil </span><span class="cov0" title="0">{
                // fallback: ignore unmarshal error and fall back to string search
                return strings.Contains(strings.ToLower(installConfigStr), "fips: true"), nil //nolint:nilerr
        }</span>

        <span class="cov9" title="41">return installConfig.FIPS, nil</span>
}

func setManagedMonitoringNamespace(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        platform, err := getPlatform(ctx, cli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ok := viper.IsSet("dsc-monitoring-namespace")
        if !ok </span><span class="cov0" title="0">{
                switch platform </span>{
                case ManagedRhoai, SelfManagedRhoai:<span class="cov0" title="0">
                        viper.Set("dsc-monitoring-namespace", DefaultMonitoringNamespaceRHOAI)</span>
                default:<span class="cov0" title="0">
                        viper.Set("dsc-monitoring-namespace", DefaultMonitoringNamespaceODH)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package cluster

import (
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

// MetaOptions allows to add additional settings for the object being created through a chain
// of functions which are applied on metav1.Object before actual resource creation.
type MetaOptions func(obj metav1.Object) error

func ApplyMetaOptions(obj metav1.Object, opts ...MetaOptions) error <span class="cov10" title="12">{
        for _, opt := range opts </span><span class="cov8" title="8">{
                if err := opt(obj); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov10" title="12">return nil</span>
}

func WithOwnerReference(ownerReferences ...metav1.OwnerReference) MetaOptions <span class="cov3" title="2">{
        return func(obj metav1.Object) error </span><span class="cov3" title="2">{
                obj.SetOwnerReferences(ownerReferences)
                return nil
        }</span>
}

// OwnedBy sets the owner reference for the object being created. It requires scheme to be passed
// as TypeMeta might not be set for the owning object, see: https://github.com/kubernetes-sigs/controller-runtime/issues/1517
func OwnedBy(owner metav1.Object, scheme *runtime.Scheme) MetaOptions <span class="cov0" title="0">{
        return func(obj metav1.Object) error </span><span class="cov0" title="0">{
                return controllerutil.SetOwnerReference(owner, obj, scheme)
        }</span>
}

func ControlledBy(owner metav1.Object, scheme *runtime.Scheme) MetaOptions <span class="cov0" title="0">{
        return func(obj metav1.Object) error </span><span class="cov0" title="0">{
                return controllerutil.SetControllerReference(owner, obj, scheme)
        }</span>
}

func WithLabels(labels ...string) MetaOptions <span class="cov6" title="5">{
        return func(obj metav1.Object) error </span><span class="cov6" title="5">{
                labelsMap, err := extractKeyValues(labels)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed unable to set labels: %w", err)
                }</span>

                <span class="cov6" title="5">obj.SetLabels(labelsMap)

                return nil</span>
        }
}

func InNamespace(ns string) MetaOptions <span class="cov3" title="2">{
        return func(obj metav1.Object) error </span><span class="cov3" title="2">{
                obj.SetNamespace(ns)
                return nil
        }</span>
}

func WithAnnotations(annotationKeyValue ...string) MetaOptions <span class="cov3" title="2">{
        return func(obj metav1.Object) error </span><span class="cov3" title="2">{
                annotationsMap, err := extractKeyValues(annotationKeyValue)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set labels: %w", err)
                }</span>

                <span class="cov3" title="2">obj.SetAnnotations(annotationsMap)

                return nil</span>
        }
}

func extractKeyValues(keyValues []string) (map[string]string, error) <span class="cov7" title="6">{
        lenKV := len(keyValues)
        if lenKV%2 != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("passed elements should be in key/value pairs, but got %d elements", lenKV)
        }</span>

        <span class="cov7" title="6">kvMap := make(map[string]string)
        for i := 0; i &lt; lenKV; i += 2 </span><span class="cov7" title="6">{
                kvMap[keyValues[i]] = keyValues[i+1]
        }</span>

        <span class="cov7" title="6">return kvMap, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package cluster

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/operator-framework/api/pkg/operators/v1alpha1"
        ofapiv2 "github.com/operator-framework/api/pkg/operators/v2"
        apiextv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/wait"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// GetSubscription checks if a Subscription for the operator exists in the given namespace.
// if exists, return object; otherwise, return error.
func GetSubscription(ctx context.Context, cli client.Client, namespace string, name string) (*v1alpha1.Subscription, error) <span class="cov0" title="0">{
        sub := &amp;v1alpha1.Subscription{}
        if err := cli.Get(ctx, client.ObjectKey{Namespace: namespace, Name: name}, sub); err != nil </span><span class="cov0" title="0">{
                // real error or 'not found' both return here
                return nil, err
        }</span>
        <span class="cov0" title="0">return sub, nil</span>
}

func SubscriptionExists(ctx context.Context, cli client.Client, name string) (bool, error) <span class="cov0" title="0">{
        subscriptionList := &amp;v1alpha1.SubscriptionList{}
        if err := cli.List(ctx, subscriptionList); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">for _, sub := range subscriptionList.Items </span><span class="cov0" title="0">{
                if sub.Name == name </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

// DeleteExistingSubscription deletes given Subscription if it exists
// Do not error if the Subscription does not exist.
func DeleteExistingSubscription(ctx context.Context, cli client.Client, operatorNs string, subsName string) error <span class="cov0" title="0">{
        sub, err := GetSubscription(ctx, cli, operatorNs, subsName)
        if err != nil </span><span class="cov0" title="0">{
                return client.IgnoreNotFound(err)
        }</span>

        <span class="cov0" title="0">if err := cli.Delete(ctx, sub); client.IgnoreNotFound(err) != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error deleting subscription %s: %w", sub.Name, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OperatorExists checks if an Operator with 'operatorPrefix' is installed.
// Return true if found it, false if not.
// if we need to check exact version of the operator installed, can append vX.Y.Z later.
func OperatorExists(ctx context.Context, cli client.Client, operatorPrefix string) (bool, error) <span class="cov0" title="0">{
        opConditionList := &amp;ofapiv2.OperatorConditionList{}
        err := cli.List(ctx, opConditionList)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">for _, opCondition := range opConditionList.Items </span><span class="cov0" title="0">{
                if strings.HasPrefix(opCondition.Name, operatorPrefix) </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

// CustomResourceDefinitionExists checks if a CustomResourceDefinition with the given GVK exists.
func CustomResourceDefinitionExists(ctx context.Context, cli client.Client, crdGK schema.GroupKind) error <span class="cov0" title="0">{
        crd := &amp;apiextv1.CustomResourceDefinition{}
        name := strings.ToLower(fmt.Sprintf("%ss.%s", crdGK.Kind, crdGK.Group)) // we need plural form of the kind

        backoff := wait.Backoff{
                Duration: 1 * time.Second,
                Factor:   1.0,
                Steps:    5,
        }
        // 5 second timeout
        err := wait.ExponentialBackoffWithContext(ctx, backoff, func(ctx context.Context) (bool, error) </span><span class="cov0" title="0">{
                err := cli.Get(ctx, client.ObjectKey{Name: name}, crd)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                        <span class="cov0" title="0">return false, err</span>
                }

                <span class="cov0" title="0">for _, condition := range crd.Status.Conditions </span><span class="cov0" title="0">{
                        if condition.Type == apiextv1.Established </span><span class="cov0" title="0">{
                                if condition.Status == apiextv1.ConditionTrue </span><span class="cov0" title="0">{
                                        return true, nil
                                }</span>
                        }
                }
                <span class="cov0" title="0">return false, nil</span>
        })

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package cluster

import (
        "context"
        "errors"
        "fmt"
        "reflect"
        "slices"
        "time"

        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/apiextensions-apiserver/pkg/apihelpers"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/wait"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

// GetSingleton retrieves a singleton instance of a Kubernetes resource of type T.
//
// It ensures that only one instance exists and updates the provided object pointer
// with the retrieved data and:
//   - If no instances are found, it returns a "NotFound" error.
//   - If multiple instances are found, it returns an error indicating an unexpected
//     number of instances.
//   - A generic error in case of other failures
//
// Generic Parameters:
//   - T: A Kubernetes API resource that implements client.Object.
//     T **must be a pointer to a struct**, allowing the function to update its contents.
//
// Parameters:
//   - ctx: The context for the API request, allowing for cancellation and timeouts.
//   - cli: The Kubernetes client used to interact with the cluster.
//   - obj: A **pointer to a struct** that implements client.Object, which will be populated with the retrieved resource.
//
// Returns:
//   - nil if exactly one instance of the resource is found and successfully assigned to obj.
//   - An error if no instances or multiple instances are found, or if any failure occurs.
func GetSingleton[T client.Object](ctx context.Context, cli client.Client, obj T) error <span class="cov10" title="33">{
        if reflect.ValueOf(obj).IsNil() </span><span class="cov6" title="9">{
                return errors.New("obj must be a pointer")
        }</span>

        <span class="cov9" title="25">objGVK, err := resources.GetGroupVersionKindForObject(cli.Scheme(), obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="25">instances := unstructured.UnstructuredList{}
        instances.SetAPIVersion(objGVK.GroupVersion().String())
        instances.SetKind(objGVK.Kind)

        if err := cli.List(ctx, &amp;instances); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list resources of type %s: %w", objGVK, err)
        }</span>

        <span class="cov9" title="25">switch len(instances.Items) </span>{
        case 1:<span class="cov6" title="9">
                if err := cli.Scheme().Convert(&amp;instances.Items[0], obj, ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert resource to %T: %w", obj, err)
                }</span>
                <span class="cov6" title="9">return nil</span>
        case 0:<span class="cov6" title="9">
                mapping, err := cli.RESTMapper().RESTMapping(objGVK.GroupKind(), objGVK.Version)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get REST mapping for %s: %w", objGVK, err)
                }</span>

                <span class="cov6" title="9">return k8serr.NewNotFound(
                        schema.GroupResource{
                                Group:    objGVK.Group,
                                Resource: mapping.Resource.Resource,
                        },
                        "",
                )</span>
        default:<span class="cov6" title="9">
                return fmt.Errorf("failed to get a valid %s instance, expected to find 1 instance, found %d", objGVK, len(instances.Items))</span>
        }
}

// GetDSC retrieves the DataScienceCluster (DSC) instance from the Kubernetes cluster.
func GetDSC(ctx context.Context, cli client.Reader) (*dscv1.DataScienceCluster, error) <span class="cov9" title="25">{
        instances := dscv1.DataScienceClusterList{}
        if err := cli.List(ctx, &amp;instances); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list resources of type %s: %w", gvk.DataScienceCluster, err)
        }</span>

        <span class="cov9" title="25">switch len(instances.Items) </span>{
        case 1:<span class="cov6" title="9">
                return &amp;instances.Items[0], nil</span>
        case 0:<span class="cov6" title="9">
                return nil, k8serr.NewNotFound(
                        schema.GroupResource{
                                Group:    gvk.DataScienceCluster.Group,
                                Resource: "datascienceclusters",
                        },
                        "",
                )</span>
        default:<span class="cov6" title="9">
                return nil, fmt.Errorf("failed to get a valid %s instance, expected to find 1 instance, found %d", gvk.DataScienceCluster, len(instances.Items))</span>
        }
}

// GetDSCI retrieves the DSCInitialization (DSCI) instance from the Kubernetes cluster.
func GetDSCI(ctx context.Context, cli client.Client) (*dsciv1.DSCInitialization, error) <span class="cov9" title="25">{
        instances := dsciv1.DSCInitializationList{}
        if err := cli.List(ctx, &amp;instances); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list resources of type %s: %w", gvk.DSCInitialization, err)
        }</span>

        <span class="cov9" title="25">switch len(instances.Items) </span>{
        case 1:<span class="cov6" title="9">
                return &amp;instances.Items[0], nil</span>
        case 0:<span class="cov6" title="9">
                return nil, k8serr.NewNotFound(
                        schema.GroupResource{
                                Group:    gvk.DSCInitialization.Group,
                                Resource: "dscinitializations",
                        },
                        "",
                )</span>
        default:<span class="cov6" title="9">
                return nil, fmt.Errorf("failed to get a valid %s instance, expected to find 1 instance, found %d", gvk.DSCInitialization, len(instances.Items))</span>
        }
}

// UpdatePodSecurityRolebinding update default rolebinding which is created in applications namespace by manifests
// being used by different components and SRE monitoring.
func UpdatePodSecurityRolebinding(ctx context.Context, cli client.Client, namespace string, serviceAccountsList ...string) error <span class="cov0" title="0">{
        foundRoleBinding := &amp;rbacv1.RoleBinding{}
        if err := cli.Get(ctx, client.ObjectKey{Name: namespace, Namespace: namespace}, foundRoleBinding); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error to get rolebinding %s from namespace %s: %w", namespace, namespace, err)
        }</span>

        <span class="cov0" title="0">for _, sa := range serviceAccountsList </span><span class="cov0" title="0">{
                // Append serviceAccount if not added already
                if !SubjectExistInRoleBinding(foundRoleBinding.Subjects, sa, namespace) </span><span class="cov0" title="0">{
                        foundRoleBinding.Subjects = append(foundRoleBinding.Subjects, rbacv1.Subject{
                                Kind:      rbacv1.ServiceAccountKind,
                                Name:      sa,
                                Namespace: namespace,
                        })
                }</span>
        }

        <span class="cov0" title="0">if err := cli.Update(ctx, foundRoleBinding); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error update rolebinding %s with serviceaccount: %w", namespace, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SubjectExistInRoleBinding return whether RoleBinding matching service account and namespace exists or not.
func SubjectExistInRoleBinding(subjectList []rbacv1.Subject, serviceAccountName, namespace string) bool <span class="cov0" title="0">{
        for _, subject := range subjectList </span><span class="cov0" title="0">{
                if subject.Name == serviceAccountName &amp;&amp; subject.Namespace == namespace </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// CreateOrUpdateConfigMap creates a new configmap or updates an existing one.
// If the configmap already exists, it will be updated with the merged Data and MetaOptions, if any.
// ConfigMap.ObjectMeta.Name and ConfigMap.ObjectMeta.Namespace are both required, it returns an error otherwise.
func CreateOrUpdateConfigMap(ctx context.Context, c client.Client, desiredCfgMap *corev1.ConfigMap, metaOptions ...MetaOptions) error <span class="cov5" title="5">{
        if applyErr := ApplyMetaOptions(desiredCfgMap, metaOptions...); applyErr != nil </span><span class="cov0" title="0">{
                return applyErr
        }</span>

        <span class="cov5" title="5">if desiredCfgMap.GetName() == "" || desiredCfgMap.GetNamespace() == "" </span><span class="cov0" title="0">{
                return errors.New("configmap name and namespace must be set")
        }</span>

        // Explicitly setting the TypeMeta is required to use resources.Apply()
        // Otherwise will return error stating that the unstructured object has no kind
        <span class="cov5" title="5">desiredCfgMap.TypeMeta = metav1.TypeMeta{
                APIVersion: gvk.ConfigMap.Version,
                Kind:       gvk.ConfigMap.Kind,
        }

        opts := []client.PatchOption{
                client.ForceOwnership,
                client.FieldOwner(resources.PlatformFieldOwner),
        }
        err := resources.Apply(ctx, c, desiredCfgMap, opts...)
        if err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="5">return nil</span>
}

// CreateNamespace creates a namespace and apply metadata.
// If a namespace already exists, the operation has no effect on it.
func CreateNamespace(ctx context.Context, cli client.Client, namespace string, metaOptions ...MetaOptions) (*corev1.Namespace, error) <span class="cov6" title="8">{
        desiredNamespace := &amp;corev1.Namespace{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: gvk.Namespace.Version,
                        Kind:       gvk.Namespace.Kind,
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: namespace,
                },
        }

        if err := ApplyMetaOptions(desiredNamespace, metaOptions...); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="8">opts := []client.PatchOption{
                client.ForceOwnership,
                client.FieldOwner(resources.PlatformFieldOwner),
        }
        err := resources.Apply(ctx, cli, desiredNamespace, opts...)
        if err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="8">return desiredNamespace, nil</span>
}

// ExecuteOnAllNamespaces executes the passed function for all namespaces in the cluster retrieved in batches.
func ExecuteOnAllNamespaces(ctx context.Context, cli client.Client, processFunc func(*corev1.Namespace) error) error <span class="cov0" title="0">{
        namespaces := &amp;corev1.NamespaceList{}
        paginateListOption := &amp;client.ListOptions{
                Limit: 500,
        }

        for </span><span class="cov0" title="0">{ // loop over all paged results
                if err := cli.List(ctx, namespaces, paginateListOption); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for i := range namespaces.Items </span><span class="cov0" title="0">{
                        ns := &amp;namespaces.Items[i]
                        if err := processFunc(ns); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if paginateListOption.Continue = namespaces.GetContinue(); namespaces.GetContinue() == "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func CreateWithRetry(ctx context.Context, cli client.Client, obj client.Object) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        backoff := wait.Backoff{
                Duration: 2 * time.Second,
                Factor:   2.0,
                Steps:    5,
        }
        // 1 minute timeout
        return wait.ExponentialBackoffWithContext(ctx, backoff, func(ctx context.Context) (bool, error) </span><span class="cov0" title="0">{
                // Create can return:
                // If webhook enabled:
                //   - no error (err == nil)
                //   - 500 InternalError likely if webhook is not available (yet)
                //   - 403 Forbidden if webhook blocks creation (check of existence)
                //   - some problem (real error)
                // else, if webhook disabled:
                //   - no error (err == nil)
                //   - 409 AlreadyExists if object exists
                //   - some problem (real error)
                errCreate := cli.Create(ctx, obj)
                if errCreate == nil </span><span class="cov0" title="0">{
                        return true, nil
                }</span>

                // check existence, success case for the function, covers 409 and 403 (or newly created)
                <span class="cov0" title="0">errGet := cli.Get(ctx, client.ObjectKeyFromObject(obj), obj)
                if errGet == nil </span><span class="cov0" title="0">{
                        return true, nil
                }</span>

                // retry if 500, assume webhook is not available
                <span class="cov0" title="0">if k8serr.IsInternalError(errCreate) </span><span class="cov0" title="0">{
                        log.Info("Error creating object, retrying...", "reason", errCreate)
                        return false, nil
                }</span>

                // some other error
                <span class="cov0" title="0">return false, errCreate</span>
        })
}

func GetCRD(ctx context.Context, cli client.Client, name string) (apiextensionsv1.CustomResourceDefinition, error) <span class="cov9" title="25">{
        obj := apiextensionsv1.CustomResourceDefinition{}
        err := cli.Get(ctx, client.ObjectKey{Name: name}, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return obj, err
        }</span>

        <span class="cov9" title="25">return obj, nil</span>
}

func HasCRD(ctx context.Context, cli client.Client, gvk schema.GroupVersionKind) (bool, error) <span class="cov0" title="0">{
        return HasCRDWithVersion(ctx, cli, gvk.GroupKind(), gvk.Version)
}</span>

// HasCRDWithVersion checks if a CustomResourceDefinition (CRD) exists with the specified version.
// It verifies the CRD's existence, ensures that the version is stored, and checks if the CRD is under deletion.
//
// Parameters:
//   - ctx: The context for the request.
//   - cli: A controller-runtime client to interact with the Kubernetes API.
//   - gk: The GroupKind of the CRD to look up.
//   - version: The specific version to check for within the CRD.
//
// Returns:
//   - (true, nil) if the CRD with the specified version exists and is not terminating.
//   - (false, nil) if the CRD does not exist, does not store the requested version, or is terminating.
//   - (false, error) if there was an error fetching the CRD.
func HasCRDWithVersion(ctx context.Context, cli client.Client, gk schema.GroupKind, version string) (bool, error) <span class="cov9" title="25">{
        m, err := cli.RESTMapper().RESTMapping(gk, version)
        if err != nil </span><span class="cov0" title="0">{
                if meta.IsNoMatchError(err) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov9" title="25">crd, err := GetCRD(ctx, cli, m.Resource.GroupResource().String())
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return false, client.IgnoreNotFound(err)</span>
        case apihelpers.IsCRDConditionTrue(&amp;crd, apiextensionsv1.Terminating):<span class="cov6" title="9">
                return false, nil</span>
        case !slices.Contains(crd.Status.StoredVersions, version):<span class="cov6" title="9">
                return false, nil</span>
        default:<span class="cov6" title="9">
                return true, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package cacher

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
)

type CachingKeyFn func(rr *types.ReconciliationRequest) ([]byte, error)

type Cacher[T any] struct {
        cachingKeyFn    CachingKeyFn
        cachingKey      []byte
        cachedResources T
}

func Zero[T any]() T <span class="cov8" title="1">{
        return *new(T)
}</span>

// SetKeyFn installs the function which calculates hash of resource sources,
// taking ReconciliationRequest as the argument and returning []byte
// The returned hash MUST NOT be empty by the contract.
func (s *Cacher[T]) SetKeyFn(key CachingKeyFn) <span class="cov8" title="1">{
        s.cachingKeyFn = key
}</span>

// InvalidateCache invalidates both caching key and cached resources
// what forces Render() to regenerate them.
func (s *Cacher[T]) InvalidateCache() <span class="cov8" title="1">{
        s.cachingKey = nil
}</span>

func (s *Cacher[T]) reRender(ctx context.Context, cachingKey []byte, rr *types.ReconciliationRequest,
        r func(ctx context.Context, rr *types.ReconciliationRequest) (T, error)) (T, bool, error) <span class="cov8" title="1">{
        var err error
        log := logf.FromContext(ctx)

        log.V(4).Info("cache is not valid, rendering resources")
        res, err := r(ctx, rr)
        if err != nil </span><span class="cov8" title="1">{
                return Zero[T](), false, err
        }</span>

        // does not matter at this point if it's empty or not, because the next run:
        // if the keyFn is nil, anyway rerender
        // if the keyFn returns empty, it's a error
        // otherwise comparing non-empty new key with empty will cause rerender.
        <span class="cov8" title="1">s.cachingKey = cachingKey
        s.cachedResources = res

        return res, true, nil</span>
}

func (s *Cacher[T]) Render(ctx context.Context, rr *types.ReconciliationRequest,
        r func(ctx context.Context, rr *types.ReconciliationRequest) (T, error)) (T, bool, error) <span class="cov8" title="1">{
        var err error
        var cachingKey []byte
        log := logf.FromContext(ctx)

        if s.cachingKeyFn == nil </span><span class="cov8" title="1">{
                return s.reRender(ctx, nil, rr, r)
        }</span>

        <span class="cov8" title="1">cachingKey, err = s.cachingKeyFn(rr)
        if err != nil </span><span class="cov8" title="1">{
                return Zero[T](), false, fmt.Errorf("unable to calculate caching key: %w", err)
        }</span>
        // Contract
        <span class="cov8" title="1">if len(cachingKey) == 0 </span><span class="cov8" title="1">{
                return Zero[T](), false, errors.New("calculated empty hash")
        }</span>

        // s.cachingKey can be empty (invalidated) causing cache rebuild
        <span class="cov8" title="1">if bytes.Equal(cachingKey, s.cachingKey) </span><span class="cov8" title="1">{
                log.V(4).Info("using cached resources")
                return s.cachedResources, false, nil
        }</span>

        <span class="cov8" title="1">return s.reRender(ctx, cachingKey, rr, r)</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package deleteresource

import (
        "context"

        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
)

type Action struct {
        types  []client.Object
        labels map[string]string
}

type ActionOpts func(*Action)

func WithDeleteResourcesTypes(values ...client.Object) ActionOpts <span class="cov8" title="1">{
        return func(action *Action) </span><span class="cov8" title="1">{
                action.types = append(action.types, values...)
        }</span>
}

func WithDeleteResourcesLabel(k string, v string) ActionOpts <span class="cov8" title="1">{
        return func(action *Action) </span><span class="cov8" title="1">{
                action.labels[k] = v
        }</span>
}

func WithDeleteResourcesLabels(values map[string]string) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                for k, v := range values </span><span class="cov0" title="0">{
                        action.labels[k] = v
                }</span>
        }
}

func (r *Action) run(ctx context.Context, rr *types.ReconciliationRequest) error <span class="cov8" title="1">{
        for i := range r.types </span><span class="cov8" title="1">{
                opts := make([]client.DeleteAllOfOption, 0)

                if len(r.labels) &gt; 0 </span><span class="cov8" title="1">{
                        opts = append(opts, client.MatchingLabels(r.labels))
                }</span>

                <span class="cov8" title="1">namespaced, err := rr.Client.IsObjectNamespaced(r.types[i])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if namespaced </span><span class="cov8" title="1">{
                        opts = append(opts, client.InNamespace(rr.DSCI.Spec.ApplicationsNamespace))
                }</span>

                <span class="cov8" title="1">err = rr.Client.DeleteAllOf(ctx, r.types[i], opts...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func NewAction(opts ...ActionOpts) actions.Fn <span class="cov8" title="1">{
        action := Action{
                types:  make([]client.Object, 0),
                labels: map[string]string{},
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;action)
        }</span>

        <span class="cov8" title="1">return action.run</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package deploy

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "strings"

        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        odhTypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

type Mode string

const (
        ModePatch Mode = "patch"
        ModeSSA   Mode = "ssa"
)

// Action deploys the resources that are included in the ReconciliationRequest using
// the same create or patch machinery implemented as part of deploy.DeployManifestsFromPath.
type Action struct {
        fieldOwner  string
        deployMode  Mode
        labels      map[string]string
        annotations map[string]string
        cache       *Cache
}

type ActionOpts func(*Action)

func WithFieldOwner(value string) ActionOpts <span class="cov5" title="4">{
        return func(action *Action) </span><span class="cov5" title="4">{
                action.fieldOwner = value
        }</span>
}

func WithMode(value Mode) ActionOpts <span class="cov7" title="8">{
        return func(action *Action) </span><span class="cov7" title="8">{
                action.deployMode = value
        }</span>
}

func WithLabel(name string, value string) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                if action.labels == nil </span><span class="cov0" title="0">{
                        action.labels = map[string]string{}
                }</span>

                <span class="cov0" title="0">action.labels[name] = value</span>
        }
}

func WithLabels(values map[string]string) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                if action.labels == nil </span><span class="cov0" title="0">{
                        action.labels = map[string]string{}
                }</span>

                <span class="cov0" title="0">for k, v := range values </span><span class="cov0" title="0">{
                        action.labels[k] = v
                }</span>
        }
}

func WithAnnotation(name string, value string) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                if action.annotations == nil </span><span class="cov0" title="0">{
                        action.annotations = map[string]string{}
                }</span>

                <span class="cov0" title="0">action.annotations[name] = value</span>
        }
}

func WithAnnotations(values map[string]string) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                if action.annotations == nil </span><span class="cov0" title="0">{
                        action.annotations = map[string]string{}
                }</span>

                <span class="cov0" title="0">for k, v := range values </span><span class="cov0" title="0">{
                        action.annotations[k] = v
                }</span>
        }
}

func WithCache(opts ...CacheOpt) ActionOpts <span class="cov5" title="4">{
        return func(action *Action) </span><span class="cov5" title="4">{
                action.cache = newCache(opts...)
        }</span>
}

func (a *Action) run(ctx context.Context, rr *odhTypes.ReconciliationRequest) error <span class="cov9" title="17">{
        // cleanup old entries if needed
        if a.cache != nil </span><span class="cov7" title="8">{
                a.cache.Sync()
        }</span>

        <span class="cov9" title="17">kind, err := resources.KindForObject(rr.Client.Scheme(), rr.Instance)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="17">controllerName := strings.ToLower(kind)
        igvk := rr.Instance.GetObjectKind().GroupVersionKind()

        for i := range rr.Resources </span><span class="cov10" title="18">{
                res := rr.Resources[i]
                current := resources.GvkToUnstructured(res.GroupVersionKind())

                lookupErr := rr.Client.Get(ctx, client.ObjectKeyFromObject(&amp;res), current)
                switch </span>{
                case k8serr.IsNotFound(lookupErr):<span class="cov7" title="9">
                        // set it to nil fto pass it down to other methods and signal
                        // that there's no previous known state of the resource
                        current = nil</span>
                case lookupErr != nil:<span class="cov0" title="0">
                        return fmt.Errorf("failed to lookup object %s/%s: %w", res.GetNamespace(), res.GetName(), lookupErr)</span>
                default:<span class="cov8" title="10">
                        // Remove the previous owner reference if set, This is required during the
                        // transition from the old to the new operator.
                        if err := resources.RemoveOwnerReferences(ctx, rr.Client, current, ownedTypeIsNot(&amp;igvk)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // the user has explicitly marked the current object as not owned by the operator
                        <span class="cov8" title="10">if resources.GetAnnotation(current, annotations.ManagedByODHOperator) == "false" </span><span class="cov3" title="2">{
                                // de-own the object so the resource is not removed upon cleanup
                                if err := resources.RemoveOwnerReferences(ctx, rr.Client, current, ownedTypeIs(&amp;igvk)); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                //  skip any further processing
                                <span class="cov3" title="2">continue</span>
                        }
                }

                <span class="cov9" title="17">var ok bool
                var err error

                switch rr.Resources[i].GroupVersionKind() </span>{
                case gvk.CustomResourceDefinition:<span class="cov4" title="3">
                        ok, err = a.deployCRD(ctx, rr, res, current)</span>
                default:<span class="cov9" title="15">
                        ok, err = a.deploy(ctx, rr, res, current)</span>
                }

                <span class="cov9" title="17">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failure deploying resource %s: %w", res, err)
                }</span>

                <span class="cov9" title="17">if ok </span><span class="cov9" title="14">{
                        DeployedResourcesTotal.WithLabelValues(controllerName).Inc()
                }</span>
        }

        <span class="cov9" title="17">return nil</span>
}

func (a *Action) deployCRD(
        ctx context.Context,
        rr *odhTypes.ReconciliationRequest,
        obj unstructured.Unstructured,
        current *unstructured.Unstructured,
) (bool, error) <span class="cov4" title="3">{
        resources.SetLabels(&amp;obj, a.labels)
        resources.SetAnnotations(&amp;obj, a.annotations)
        resources.SetLabel(&amp;obj, labels.PlatformPartOf, labels.Platform)

        // backup copy for caching
        origObj := obj.DeepCopy()

        if a.cache != nil </span><span class="cov0" title="0">{
                cached, err := a.cache.Has(current, &amp;obj)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to check cache for object: %w", err)
                }</span>
                <span class="cov0" title="0">if cached </span><span class="cov0" title="0">{
                        // no changes, no need to re-deploy it
                        return false, nil
                }</span>
        }

        <span class="cov4" title="3">var deployedObj *unstructured.Unstructured
        var err error

        ops := []client.PatchOption{
                client.ForceOwnership,
                // Since CRDs are not bound to a component, set the field
                // owner to the platform itself
                client.FieldOwner(resources.PlatformFieldOwner),
        }

        switch a.deployMode </span>{
        case ModePatch:<span class="cov0" title="0">
                deployedObj, err = a.patch(ctx, rr.Client, &amp;obj, current, ops...)</span>
        case ModeSSA:<span class="cov4" title="3">
                deployedObj, err = a.apply(ctx, rr.Client, &amp;obj, current, ops...)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported deploy mode %s", a.deployMode)</span>
        }

        <span class="cov4" title="3">if err != nil </span><span class="cov0" title="0">{
                return false, client.IgnoreNotFound(err)
        }</span>

        <span class="cov4" title="3">if a.cache != nil </span><span class="cov0" title="0">{
                err := a.cache.Add(deployedObj, origObj)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to cache object: %w", err)
                }</span>
        }

        <span class="cov4" title="3">return true, nil</span>
}

func (a *Action) deploy(
        ctx context.Context,
        rr *odhTypes.ReconciliationRequest,
        obj unstructured.Unstructured,
        current *unstructured.Unstructured,
) (bool, error) <span class="cov9" title="15">{
        fo := a.fieldOwner
        if fo == "" </span><span class="cov7" title="8">{
                kind, err := resources.KindForObject(rr.Client.Scheme(), rr.Instance)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov7" title="8">fo = strings.ToLower(kind)</span>
        }

        <span class="cov9" title="15">resources.SetLabels(&amp;obj, a.labels)
        resources.SetAnnotations(&amp;obj, a.annotations)
        resources.SetAnnotation(&amp;obj, annotations.InstanceGeneration, strconv.FormatInt(rr.Instance.GetGeneration(), 10))
        resources.SetAnnotation(&amp;obj, annotations.InstanceName, rr.Instance.GetName())
        resources.SetAnnotation(&amp;obj, annotations.InstanceUID, string(rr.Instance.GetUID()))
        resources.SetAnnotation(&amp;obj, annotations.PlatformType, string(rr.Release.Name))
        resources.SetAnnotation(&amp;obj, annotations.PlatformVersion, rr.Release.Version.String())

        if resources.GetLabel(&amp;obj, labels.PlatformPartOf) == "" &amp;&amp; fo != "" </span><span class="cov8" title="11">{
                resources.SetLabel(&amp;obj, labels.PlatformPartOf, fo)
        }</span>

        // backup copy for caching
        <span class="cov9" title="15">origObj := obj.DeepCopy()

        if a.cache != nil </span><span class="cov7" title="8">{
                cached, err := a.cache.Has(current, &amp;obj)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to check cache for object: %w", err)
                }</span>
                <span class="cov7" title="8">if cached </span><span class="cov5" title="4">{
                        // no changes, no need to re-deploy it
                        return false, nil
                }</span>
        }

        <span class="cov8" title="12">var deployedObj *unstructured.Unstructured
        var err error

        switch </span>{
        // The object is explicitly marked as not owned by the operator in the manifests,
        // so it should be created if it doesn't exist, but should not be modified afterward.
        case resources.GetAnnotation(&amp;obj, annotations.ManagedByODHOperator) == "false":<span class="cov4" title="3">
                // remove the opendatahub.io/managed as it should not be set
                // to the actual object in this case
                resources.RemoveAnnotation(&amp;obj, annotations.ManagedByODHOperator)

                deployedObj, err = a.create(ctx, rr.Client, &amp;obj)
                if err != nil &amp;&amp; !k8serr.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                        return false, err
                }</span>

        default:<span class="cov8" title="10">
                owned := rr.Controller.Owns(obj.GroupVersionKind())
                if owned </span><span class="cov4" title="3">{
                        if err := ctrl.SetControllerReference(rr.Instance, &amp;obj, rr.Client.Scheme()); err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                }

                <span class="cov8" title="10">ops := []client.PatchOption{
                        client.ForceOwnership,
                        client.FieldOwner(fo),
                }

                switch a.deployMode </span>{
                case ModePatch:<span class="cov4" title="3">
                        deployedObj, err = a.patch(ctx, rr.Client, &amp;obj, current, ops...)</span>
                case ModeSSA:<span class="cov7" title="8">
                        deployedObj, err = a.apply(ctx, rr.Client, &amp;obj, current, ops...)</span>
                default:<span class="cov0" title="0">
                        err = fmt.Errorf("unsupported deploy mode %s", a.deployMode)</span>
                }

                <span class="cov8" title="10">if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov8" title="12">if a.cache != nil </span><span class="cov6" title="5">{
                err := a.cache.Add(deployedObj, origObj)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to cache object: %w", err)
                }</span>
        }

        <span class="cov8" title="12">return true, nil</span>
}

func (a *Action) create(
        ctx context.Context,
        cli client.Client,
        obj *unstructured.Unstructured,
) (*unstructured.Unstructured, error) <span class="cov4" title="3">{
        logf.FromContext(ctx).V(3).Info("create",
                "gvk", obj.GroupVersionKind(),
                "name", client.ObjectKeyFromObject(obj),
        )

        err := cli.Create(ctx, obj)
        if err != nil </span><span class="cov3" title="2">{
                return obj, err
        }</span>

        <span class="cov3" title="2">return obj, nil</span>
}

func (a *Action) patch(
        ctx context.Context,
        cli client.Client,
        obj *unstructured.Unstructured,
        old *unstructured.Unstructured,
        opts ...client.PatchOption,
) (*unstructured.Unstructured, error) <span class="cov4" title="3">{
        logf.FromContext(ctx).V(3).Info("patch",
                "gvk", obj.GroupVersionKind(),
                "name", client.ObjectKeyFromObject(obj),
        )

        switch obj.GroupVersionKind() </span>{
        case gvk.Deployment:<span class="cov3" title="2">
                // For deployments, we allow the user to change some parameters, such as
                // container resources and replicas except:
                // - If the resource does not exist (the resource must be created)
                // - If the resource is forcefully marked as managed by the operator via
                //   annotations (i.e. to bring it back to the default values)
                if old == nil || resources.GetAnnotation(old, annotations.ManagedByODHOperator) == "true" </span><span class="cov3" title="2">{
                        break</span>
                }

                // To preserve backward compatibility with the current model, fields are being
                // removed, hence not included in the final PATCH. Ideally with should leverage
                // Server-Side Apply.
                //
                // Ideally deployed resources should be configured only via the platform API
                <span class="cov0" title="0">if err := RemoveDeploymentsResources(obj); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply allow list to Deployment %s/%s: %w", obj.GetNamespace(), obj.GetName(), err)
                }</span>
        default:<span class="cov3" title="2">
                // do nothing
                break</span>
        }

        <span class="cov4" title="3">if old == nil </span><span class="cov4" title="3">{
                err := cli.Create(ctx, obj)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create object %s/%s: %w", obj.GetNamespace(), obj.GetName(), err)
                }</span>
        } else<span class="cov0" title="0"> {
                data, err := json.Marshal(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">err = cli.Patch(
                        ctx,
                        old,
                        client.RawPatch(types.ApplyPatchType, data),
                        opts...,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to patch object %s/%s: %w", obj.GetNamespace(), obj.GetName(), err)
                }</span>
        }

        <span class="cov4" title="3">return old, nil</span>
}

func (a *Action) apply(
        ctx context.Context,
        cli client.Client,
        obj *unstructured.Unstructured,
        old *unstructured.Unstructured,
        opts ...client.PatchOption,
) (*unstructured.Unstructured, error) <span class="cov8" title="10">{
        logf.FromContext(ctx).V(3).Info("apply",
                "gvk", obj.GroupVersionKind(),
                "name", client.ObjectKeyFromObject(obj),
        )

        switch obj.GroupVersionKind() </span>{
        case gvk.Deployment:<span class="cov0" title="0">
                // For deployments, we allow the user to change some parameters, such as
                // container resources and replicas except:
                // - If the resource does not exist (the resource must be created)
                // - If the resource is forcefully marked as managed by the operator via
                //   annotations (i.e. to bring it back to the default values)
                if old == nil || resources.GetAnnotation(old, annotations.ManagedByODHOperator) == "true" </span><span class="cov0" title="0">{
                        break</span>
                }

                // To preserve backward compatibility with the current model, fields are being
                // merged from an existing Deployment (if it exists) to the rendered manifest,
                // hence the current value is preserved [1].
                //
                // Ideally deployed resources should be configured only via the platform API
                //
                // [1] https://kubernetes.io/docs/reference/using-api/server-side-apply/#conflicts
                <span class="cov0" title="0">if err := MergeDeployments(old, obj); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to merge Deployment %s/%s: %w", obj.GetNamespace(), obj.GetName(), err)
                }</span>
        case gvk.ClusterRole:<span class="cov4" title="3">
                // For ClusterRole, if AggregationRule is set, then the Rules are controller managed
                // and direct changes to Rules will be stomped by the controller. This also happen if
                // the rules are set to an empty slice or nil hence we are removing the rules field
                // if the ClusterRole is set to be an aggregation role.
                _, found, err := unstructured.NestedFieldNoCopy(obj.Object, "aggregationRule")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="3">if found </span><span class="cov3" title="2">{
                        unstructured.RemoveNestedField(obj.Object, "rules")
                }</span>
        default:<span class="cov7" title="8">
                // do nothing
                break</span>
        }

        <span class="cov8" title="10">err := resources.Apply(ctx, cli, obj, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apply failed %s: %w", obj.GroupVersionKind(), err)
        }</span>

        <span class="cov8" title="10">return obj, nil</span>
}

func NewAction(opts ...ActionOpts) actions.Fn <span class="cov8" title="12">{
        action := Action{
                deployMode: ModeSSA,
        }

        for _, opt := range opts </span><span class="cov9" title="14">{
                opt(&amp;action)
        }</span>

        <span class="cov8" title="12">return action.run</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package deploy

import (
        "encoding/base64"
        "errors"
        "fmt"
        "time"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/client-go/tools/cache"
        "k8s.io/klog/v2"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

// This code is heavily inspired by https://github.com/kubernetes-sigs/cluster-api/tree/main/internal/util/ssa

const (
        DefaultCacheTTL = 10 * time.Minute
)

type Cache struct {
        s   cache.Store
        ttl time.Duration
}

type CacheOpt func(*Cache)

func WithTTL(ttl time.Duration) CacheOpt <span class="cov3" title="2">{
        return func(c *Cache) </span><span class="cov3" title="2">{
                c.ttl = ttl
        }</span>
}

func newCache(opts ...CacheOpt) *Cache <span class="cov6" title="4">{
        c := Cache{
                ttl: DefaultCacheTTL,
        }

        for _, opt := range opts </span><span class="cov3" title="2">{
                opt(&amp;c)
        }</span>

        <span class="cov6" title="4">c.s = cache.NewTTLStore(
                func(obj interface{}) (string, error) </span><span class="cov7" title="5">{
                        s, ok := obj.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return "", errors.New("failed to cast object to string")
                        }</span>

                        <span class="cov7" title="5">return s, nil</span>
                },
                c.ttl,
        )

        <span class="cov6" title="4">return &amp;c</span>
}

func (r *Cache) Add(original *unstructured.Unstructured, modified *unstructured.Unstructured) error <span class="cov7" title="5">{
        if original == nil || modified == nil </span><span class="cov0" title="0">{
                return errors.New("invalid input")
        }</span>

        <span class="cov7" title="5">key, err := r.computeCacheKey(original, modified)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compute cacheKey: %w", err)
        }</span>

        <span class="cov7" title="5">if key == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov7" title="5">_ = r.s.Add(key)

        return nil</span>
}

func (r *Cache) Has(original *unstructured.Unstructured, modified *unstructured.Unstructured) (bool, error) <span class="cov9" title="8">{
        if original == nil || modified == nil </span><span class="cov5" title="3">{
                return false, nil
        }</span>

        <span class="cov8" title="6">key, err := r.computeCacheKey(original, modified)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to compute cacheKey: %w", err)
        }</span>

        <span class="cov8" title="6">if key == "" </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="6">_, exists, _ := r.s.GetByKey(key)

        return exists, nil</span>
}

func (r *Cache) Sync() <span class="cov9" title="8">{
        r.s.List()
}</span>

func (r *Cache) computeCacheKey(
        original *unstructured.Unstructured,
        modified *unstructured.Unstructured,
) (string, error) <span class="cov10" title="10">{
        modifiedObjectHash, err := resources.Hash(modified)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov10" title="10">return fmt.Sprintf("%s.%s.%s.%s.%s",
                original.GroupVersionKind().GroupVersion(),
                original.GroupVersionKind().Kind,
                klog.KObj(original),
                original.GetResourceVersion(),
                base64.RawURLEncoding.EncodeToString(modifiedObjectHash),
        ), nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package deploy

import (
        "errors"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

func MergeDeployments(source *unstructured.Unstructured, target *unstructured.Unstructured) error <span class="cov10" title="3">{
        containersPath := []string{"spec", "template", "spec", "containers"}
        replicasPath := []string{"spec", "replicas"}

        //
        // Resources
        //

        sc, ok, err := unstructured.NestedFieldNoCopy(source.Object, containersPath...)
        if err != nil &amp;&amp; ok </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="3">tc, ok, err := unstructured.NestedFieldNoCopy(target.Object, containersPath...)
        if err != nil &amp;&amp; ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="3">resources := make(map[string]interface{})

        var sourceContainers []interface{}
        if sc != nil </span><span class="cov10" title="3">{
                sourceContainers, ok = sc.([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("field is not a slice")
                }</span>
        }

        <span class="cov10" title="3">var targetContainers []interface{}
        if tc != nil </span><span class="cov10" title="3">{
                targetContainers, ok = tc.([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("field is not a slice")
                }</span>
        }

        <span class="cov10" title="3">for i := range sourceContainers </span><span class="cov10" title="3">{
                m, ok := sourceContainers[i].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("field is not a map")
                }</span>

                <span class="cov10" title="3">name, ok := m["name"]
                if !ok </span><span class="cov0" title="0">{
                        // can't deal with unnamed containers
                        continue</span>
                }

                <span class="cov10" title="3">r, ok := m["resources"]
                if !ok </span><span class="cov0" title="0">{
                        r = make(map[string]interface{})
                }</span>

                //nolint:forcetypeassert,errcheck
                <span class="cov10" title="3">resources[name.(string)] = r</span>
        }

        <span class="cov10" title="3">for i := range targetContainers </span><span class="cov10" title="3">{
                m, ok := targetContainers[i].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("field is not a map")
                }</span>

                <span class="cov10" title="3">name, ok := m["name"]
                if !ok </span><span class="cov0" title="0">{
                        // can't deal with unnamed containers
                        continue</span>
                }

                //nolint:errcheck
                <span class="cov10" title="3">nr, ok := resources[name.(string)]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                //nolint:forcetypeassert,errcheck
                <span class="cov10" title="3">if len(nr.(map[string]interface{})) == 0 </span><span class="cov6" title="2">{
                        delete(m, "resources")
                }</span> else<span class="cov6" title="2"> {
                        m["resources"] = nr
                }</span>
        }

        //
        // Replicas
        //

        <span class="cov10" title="3">sourceReplica, ok, err := unstructured.NestedFieldNoCopy(source.Object, replicasPath...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov10" title="3">if !ok </span><span class="cov6" title="2">{
                unstructured.RemoveNestedField(target.Object, replicasPath...)
        }</span> else<span class="cov6" title="2"> {
                if err := unstructured.SetNestedField(target.Object, sourceReplica, replicasPath...); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov10" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package deploy

import (
        "github.com/prometheus/client_golang/prometheus"
        "sigs.k8s.io/controller-runtime/pkg/metrics"
)

var (
        // DeployedResourcesTotal is a prometheus counter metrics which holds the total
        // number of resource deployed by the action per controller. It has one label.
        // controller label refers  to the controller name.
        DeployedResourcesTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "action_deploy_resources_total",
                        Help: "Number of deployed resources",
                },
                []string{
                        "controller",
                },
        )
)

// init register metrics to the global registry from controller-runtime/pkg/metrics.
// see https://book.kubebuilder.io/reference/metrics#publishing-additional-metrics
//
//nolint:gochecknoinits
func init() <span class="cov10" title="2">{
        metrics.Registry.MustRegister(DeployedResourcesTotal)
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">package deploy

import (
        "errors"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

func RemoveDeploymentsResources(obj *unstructured.Unstructured) error <span class="cov10" title="2">{
        containersPath := []string{"spec", "template", "spec", "containers"}
        replicasPath := []string{"spec", "replicas"}

        //
        // Resources
        //

        sc, ok, err := unstructured.NestedFieldNoCopy(obj.Object, containersPath...)
        if err != nil &amp;&amp; ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="2">var sourceContainers []interface{}
        if sc != nil </span><span class="cov10" title="2">{
                sourceContainers, ok = sc.([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("field is not a slice")
                }</span>
        }

        <span class="cov10" title="2">for i := range sourceContainers </span><span class="cov10" title="2">{
                m, ok := sourceContainers[i].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("field is not a map")
                }</span>

                <span class="cov10" title="2">delete(m, "resources")</span>
        }

        //
        // Replicas
        //

        <span class="cov10" title="2">unstructured.RemoveNestedField(obj.Object, replicasPath...)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package deploy

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
)

func isLegacyOwnerRef(or metav1.OwnerReference) bool <span class="cov8" title="7">{
        switch </span>{
        case or.APIVersion == gvk.DataScienceCluster.GroupVersion().String() &amp;&amp; or.Kind == gvk.DataScienceCluster.Kind:<span class="cov3" title="2">
                return true</span>
        case or.APIVersion == gvk.DSCInitialization.GroupVersion().String() &amp;&amp; or.Kind == gvk.DSCInitialization.Kind:<span class="cov3" title="2">
                return true</span>
        case or.APIVersion == gvk.FeatureTracker.GroupVersion().String() &amp;&amp; or.Kind == gvk.FeatureTracker.Kind:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov7" title="5">
                return false</span>
        }
}

func ownedTypeIsNot(ownerType *schema.GroupVersionKind) func(or metav1.OwnerReference) bool <span class="cov10" title="10">{
        if ownerType == nil </span><span class="cov0" title="0">{
                return func(or metav1.OwnerReference) bool </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov10" title="10">gv := ownerType.GroupVersion().String()
        return func(or metav1.OwnerReference) bool </span><span class="cov5" title="3">{
                return ownerType.Kind != or.Kind &amp;&amp; gv != or.APIVersion
        }</span>
}

func ownedTypeIs(ownerType *schema.GroupVersionKind) func(or metav1.OwnerReference) bool <span class="cov3" title="2">{
        if ownerType == nil </span><span class="cov0" title="0">{
                return func(or metav1.OwnerReference) bool </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov3" title="2">gv := ownerType.GroupVersion().String()

        return func(or metav1.OwnerReference) bool </span><span class="cov0" title="0">{
                return ownerType.Kind == or.Kind &amp;&amp; gv == or.APIVersion
        }</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package gc

import (
        "context"
        "fmt"
        "strings"

        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/dynamic"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        odhTypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
        odhLabels "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/rules"
)

type ObjectPredicateFn func(*odhTypes.ReconciliationRequest, unstructured.Unstructured) (bool, error)
type TypePredicateFn func(*odhTypes.ReconciliationRequest, schema.GroupVersionKind) (bool, error)
type ActionOpts func(*Action)

type Action struct {
        labels            map[string]string
        selector          labels.Selector
        propagationPolicy client.PropagationPolicy
        unremovables      map[schema.GroupVersionKind]struct{}
        objectPredicateFn ObjectPredicateFn
        typePredicateFn   TypePredicateFn
        onlyOwned         bool
        namespaceFn       actions.StringGetter
}

func WithLabel(name string, value string) ActionOpts <span class="cov8" title="1">{
        return func(action *Action) </span><span class="cov8" title="1">{
                if action.labels == nil </span><span class="cov8" title="1">{
                        action.labels = map[string]string{}
                }</span>

                <span class="cov8" title="1">action.labels[name] = value</span>
        }
}

func WithLabels(values map[string]string) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                if action.labels == nil </span><span class="cov0" title="0">{
                        action.labels = map[string]string{}
                }</span>

                <span class="cov0" title="0">for k, v := range values </span><span class="cov0" title="0">{
                        action.labels[k] = v
                }</span>
        }
}

func WithUnremovables(items ...schema.GroupVersionKind) ActionOpts <span class="cov8" title="1">{
        return func(action *Action) </span><span class="cov8" title="1">{
                for _, item := range items </span><span class="cov8" title="1">{
                        action.unremovables[item] = struct{}{}
                }</span>
        }
}

func WithObjectPredicate(value ObjectPredicateFn) ActionOpts <span class="cov8" title="1">{
        return func(action *Action) </span><span class="cov8" title="1">{
                if value == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">action.objectPredicateFn = value</span>
        }
}

func WithTypePredicate(value TypePredicateFn) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">action.typePredicateFn = value</span>
        }
}

func WithOnlyCollectOwned(value bool) ActionOpts <span class="cov8" title="1">{
        return func(action *Action) </span><span class="cov8" title="1">{
                action.onlyOwned = value
        }</span>
}

func InNamespace(ns string) ActionOpts <span class="cov8" title="1">{
        return func(action *Action) </span><span class="cov8" title="1">{
                action.namespaceFn = func(_ context.Context, _ *odhTypes.ReconciliationRequest) (string, error) </span><span class="cov8" title="1">{
                        return ns, nil
                }</span>
        }
}

func InNamespaceFn(fn actions.StringGetter) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                if fn == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">action.namespaceFn = fn</span>
        }
}
func WithDeletePropagationPolicy(policy metav1.DeletionPropagation) ActionOpts <span class="cov8" title="1">{
        return func(action *Action) </span><span class="cov8" title="1">{
                action.propagationPolicy = client.PropagationPolicy(policy)
        }</span>
}

func (a *Action) run(ctx context.Context, rr *odhTypes.ReconciliationRequest) error <span class="cov8" title="1">{
        // To avoid the expensive GC, run it only when resources have
        // been generated
        if !rr.Generated </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">l := logf.FromContext(ctx)

        // TODO: use cacher to avoid computing deletable types
        //       on each run
        items, err := a.computeDeletableTypes(ctx, rr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to refresh collectable resources: %w", err)
        }</span>

        <span class="cov8" title="1">igvk, err := resources.GetGroupVersionKindForObject(rr.Client.Scheme(), rr.Instance)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">controllerName := strings.ToLower(igvk.Kind)

        CyclesTotal.WithLabelValues(controllerName).Inc()

        lo := metav1.ListOptions{
                LabelSelector: a.getOrComputeSelector(controllerName).String(),
        }

        l.V(3).Info("run", "selector", lo.LabelSelector)

        for _, res := range items </span><span class="cov8" title="1">{
                canBeDeleted, err := a.isTypeDeletable(rr, res.GroupVersionKind())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot determine if resource %s can be deleted: %w", res.String(), err)
                }</span>

                <span class="cov8" title="1">if !canBeDeleted </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">items, err := a.listResources(ctx, rr.Controller.GetDynamicClient(), res, lo)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot list child resources %s: %w", res.String(), err)
                }</span>

                <span class="cov8" title="1">deleted, err := a.deleteResources(ctx, rr, igvk, items)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error processing items to delete: %w", err)
                }</span>

                <span class="cov8" title="1">if deleted &gt; 0 </span><span class="cov8" title="1">{
                        DeletedTotal.WithLabelValues(controllerName).Add(float64(deleted))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (a *Action) computeDeletableTypes(ctx context.Context, rr *odhTypes.ReconciliationRequest) ([]resources.Resource, error) <span class="cov8" title="1">{
        res, err := resources.ListAvailableAPIResources(rr.Controller.GetDiscoveryClient())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failure discovering resources: %w", err)
        }</span>

        <span class="cov8" title="1">ns, err := a.namespaceFn(ctx, rr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to compute namespace: %w", err)
        }</span>

        <span class="cov8" title="1">items, err := rules.ListAuthorizedDeletableResources(ctx, rr.Client, res, ns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failure listing authorized deletable resources: %w", err)
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}

func (a *Action) listResources(
        ctx context.Context,
        dc dynamic.Interface,
        res resources.Resource,
        opts metav1.ListOptions,
) ([]unstructured.Unstructured, error) <span class="cov8" title="1">{
        items, err := dc.Resource(res.GroupVersionResource()).Namespace("").List(ctx, opts)
        switch </span>{
        case k8serr.IsForbidden(err) || k8serr.IsMethodNotSupported(err) || k8serr.IsNotFound(err):<span class="cov0" title="0">
                logf.FromContext(ctx).V(3).Info(
                        "cannot list resource",
                        "reason", err.Error(),
                        "gvk", res.GroupVersionKind(),
                )

                return nil, nil</span>
        case err != nil:<span class="cov0" title="0">
                return nil, err</span>
        default:<span class="cov8" title="1">
                return items.Items, nil</span>
        }
}

func (a *Action) isTypeDeletable(
        rr *odhTypes.ReconciliationRequest,
        gvk schema.GroupVersionKind,
) (bool, error) <span class="cov8" title="1">{
        if a.isUnremovable(gvk) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return a.typePredicateFn(rr, gvk)</span>
}

func (a *Action) isObjectDeletable(
        rr *odhTypes.ReconciliationRequest,
        igvk schema.GroupVersionKind,
        obj unstructured.Unstructured,
) (bool, error) <span class="cov8" title="1">{
        if a.isUnremovable(obj.GroupVersionKind()) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov8" title="1">if resources.HasAnnotation(&amp;obj, annotations.ManagedByODHOperator, "false") </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if a.onlyOwned </span><span class="cov8" title="1">{
                o, err := resources.IsOwnedByType(&amp;obj, igvk)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if !o </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        <span class="cov8" title="1">return a.objectPredicateFn(rr, obj)</span>
}

func (a *Action) deleteResources(
        ctx context.Context,
        rr *odhTypes.ReconciliationRequest,
        igvk schema.GroupVersionKind,
        items []unstructured.Unstructured,
) (int, error) <span class="cov8" title="1">{
        deleted := 0

        for i := range items </span><span class="cov8" title="1">{
                canBeDeleted, err := a.isObjectDeletable(rr, igvk, items[i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("cannot determine if object %s in namespace %q can be deleted: %w",
                                items[i].GetName(),
                                items[i].GetNamespace(),
                                err,
                        )
                }</span>

                <span class="cov8" title="1">if !canBeDeleted </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !items[i].GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if err := a.delete(ctx, rr.Client, items[i]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov8" title="1">deleted++</span>
        }

        <span class="cov8" title="1">return deleted, nil</span>
}

func (a *Action) delete(
        ctx context.Context,
        cli client.Client,
        resource unstructured.Unstructured,
) error <span class="cov8" title="1">{
        logf.FromContext(ctx).Info(
                "delete",
                "gvk", resource.GroupVersionKind(),
                "ns", resource.GetNamespace(),
                "name", resource.GetName(),
        )

        err := cli.Delete(ctx, &amp;resource, a.propagationPolicy)
        if err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "cannot delete resources gvk: %s, namespace: %s, name: %s, reason: %w",
                        resource.GroupVersionKind().String(),
                        resource.GetNamespace(),
                        resource.GetName(),
                        err,
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getOrComputeSelector returns the existing label selector if provided, or, it generates
// a new selector using the provided value and 'platform.opendatahub.io/part-of' as a key.
//
// Parameters:
//   - controllerName: the name of the controller to associate with the selector.
//
// Returns:
//   - labels.Selector: either the cached selector or a newly constructed one.
func (a *Action) getOrComputeSelector(partOf string) labels.Selector <span class="cov8" title="1">{
        if a.selector != nil </span><span class="cov8" title="1">{
                return a.selector
        }</span>

        <span class="cov8" title="1">return labels.SelectorFromSet(map[string]string{
                odhLabels.PlatformPartOf: partOf,
        })</span>
}

func (a *Action) isUnremovable(gvk schema.GroupVersionKind) bool <span class="cov8" title="1">{
        _, ok := a.unremovables[gvk]
        return ok
}</span>

func NewAction(opts ...ActionOpts) actions.Fn <span class="cov8" title="1">{
        action := Action{}
        action.objectPredicateFn = DefaultObjectPredicate
        action.typePredicateFn = DefaultTypePredicate
        action.onlyOwned = true
        action.namespaceFn = actions.OperatorNamespace
        action.propagationPolicy = client.PropagationPolicy(metav1.DeletePropagationForeground)

        // default unremovables
        action.unremovables = make(map[schema.GroupVersionKind]struct{})
        action.unremovables[gvk.CustomResourceDefinition] = struct{}{}
        action.unremovables[gvk.Lease] = struct{}{}

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;action)
        }</span>

        <span class="cov8" title="1">if len(action.labels) &gt; 0 </span><span class="cov8" title="1">{
                action.selector = labels.SelectorFromSet(action.labels)
        }</span>

        <span class="cov8" title="1">return action.run</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package gc

import (
        "github.com/prometheus/client_golang/prometheus"
        "sigs.k8s.io/controller-runtime/pkg/metrics"
)

var (
        // DeletedTotal is a prometheus counter metrics which holds the total number
        // of resource deleted by the action per controller. It has one label.
        // controller label refers  to the controller name.
        DeletedTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "action_gc_deleted_total",
                        Help: "Number of GCed resources",
                },
                []string{
                        "controller",
                },
        )

        // CyclesTotal is a prometheus counter metrics which holds the total number
        // gc cycles per controller. It has one label.
        // controller label refers  to the controller name.
        CyclesTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "action_gc_cycles_total",
                        Help: "Number of GC cycles",
                },
                []string{
                        "controller",
                },
        )
)

// init register metrics to the global registry from controller-runtime/pkg/metrics.
// see https://book.kubebuilder.io/reference/metrics#publishing-additional-metrics
//
//nolint:gochecknoinits
func init() <span class="cov8" title="1">{
        metrics.Registry.MustRegister(DeletedTotal)
        metrics.Registry.MustRegister(CyclesTotal)
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package gc

import (
        "fmt"
        "strconv"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"

        odhTypes "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhAnnotations "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

func DefaultObjectPredicate(rr *odhTypes.ReconciliationRequest, obj unstructured.Unstructured) (bool, error) <span class="cov8" title="1">{
        if obj.GetAnnotations() == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">pv := resources.GetAnnotation(&amp;obj, odhAnnotations.PlatformVersion)
        pt := resources.GetAnnotation(&amp;obj, odhAnnotations.PlatformType)
        ig := resources.GetAnnotation(&amp;obj, odhAnnotations.InstanceGeneration)
        iu := resources.GetAnnotation(&amp;obj, odhAnnotations.InstanceUID)

        if pv == "" || pt == "" || ig == "" || iu == "" </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if pv != rr.Release.Version.String() </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if pt != string(rr.Release.Name) </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if iu != string(rr.Instance.GetUID()) </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">g, err := strconv.Atoi(ig)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("cannot determine generation: %w", err)
        }</span>

        <span class="cov8" title="1">return rr.Instance.GetGeneration() != int64(g), nil</span>
}

func DefaultTypePredicate(_ *odhTypes.ReconciliationRequest, _ schema.GroupVersionKind) (bool, error) <span class="cov8" title="1">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package kustomize

import (
        "context"

        "sigs.k8s.io/kustomize/kyaml/filesys"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/resourcecacher"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/manifests/kustomize"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

const rendererEngine = "kustomize"

// Action takes a set of manifest locations and render them as Unstructured resources for
// further processing. The Action can eventually cache the results in memory to avoid doing
// a full manifest rendering when not needed.
type Action struct {
        cacher resourcecacher.ResourceCacher
        cache  bool

        keOpts []kustomize.EngineOptsFn
        ke     *kustomize.Engine
}

type ActionOpts func(*Action)

func WithEngineFS(value filesys.FileSystem) ActionOpts <span class="cov0" title="0">{
        return func(a *Action) </span><span class="cov0" title="0">{
                a.keOpts = append(a.keOpts, kustomize.WithEngineFS(value))
        }</span>
}

func WithLabel(name string, value string) ActionOpts <span class="cov6" title="5">{
        return func(a *Action) </span><span class="cov6" title="5">{
                a.keOpts = append(a.keOpts, kustomize.WithEngineRenderOpts(kustomize.WithLabel(name, value)))
        }</span>
}

func WithLabels(values map[string]string) ActionOpts <span class="cov0" title="0">{
        return func(a *Action) </span><span class="cov0" title="0">{
                a.keOpts = append(a.keOpts, kustomize.WithEngineRenderOpts(kustomize.WithLabels(values)))
        }</span>
}

func WithAnnotation(name string, value string) ActionOpts <span class="cov6" title="5">{
        return func(a *Action) </span><span class="cov6" title="5">{
                a.keOpts = append(a.keOpts, kustomize.WithEngineRenderOpts(kustomize.WithAnnotation(name, value)))
        }</span>
}

func WithAnnotations(values map[string]string) ActionOpts <span class="cov0" title="0">{
        return func(a *Action) </span><span class="cov0" title="0">{
                a.keOpts = append(a.keOpts, kustomize.WithEngineRenderOpts(kustomize.WithAnnotations(values)))
        }</span>
}

func WithManifestsOptions(values ...kustomize.EngineOptsFn) ActionOpts <span class="cov4" title="3">{
        return func(action *Action) </span><span class="cov4" title="3">{
                action.keOpts = append(action.keOpts, values...)
        }</span>
}

func WithCache(enabled bool) ActionOpts <span class="cov3" title="2">{
        return func(action *Action) </span><span class="cov3" title="2">{
                action.cache = enabled
        }</span>
}

func (a *Action) run(ctx context.Context, rr *types.ReconciliationRequest) error <span class="cov7" title="6">{
        return a.cacher.Render(ctx, rr, a.render)
}</span>

func (a *Action) render(_ context.Context, rr *types.ReconciliationRequest) (resources.UnstructuredList, error) <span class="cov6" title="5">{
        result := make(resources.UnstructuredList, 0)

        for i := range rr.Manifests </span><span class="cov6" title="5">{
                renderedResources, err := a.ke.Render(
                        rr.Manifests[i].String(),
                        kustomize.WithNamespace(rr.DSCI.Spec.ApplicationsNamespace),
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov6" title="5">result = append(result, renderedResources...)</span>
        }

        <span class="cov6" title="5">return result, nil</span>
}

func NewAction(opts ...ActionOpts) actions.Fn <span class="cov4" title="3">{
        action := Action{
                cacher: resourcecacher.NewResourceCacher(rendererEngine),
                cache:  true,
        }

        for _, opt := range opts </span><span class="cov10" title="12">{
                opt(&amp;action)
        }</span>

        <span class="cov4" title="3">if action.cache </span><span class="cov3" title="2">{
                action.cacher.SetKeyFn(types.Hash)
        }</span>

        <span class="cov4" title="3">action.ke = kustomize.NewEngine(action.keOpts...)

        return action.run</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package template

import (
        "bytes"
        "context"
        "fmt"
        "maps"
        gt "text/template"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/serializer"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/resourcecacher"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

const (
        rendererEngine = "template"
        ComponentKey   = "Component"
        DSCIKey        = "DSCI"
)

// Action takes a set of template locations and render them as Unstructured resources for
// further processing. The Action can eventually cache the results in memory to avoid doing
// a full manifest rendering when not needed.
type Action struct {
        cacher resourcecacher.ResourceCacher
        cache  bool

        data   map[string]any
        dataFn []func(context.Context, *types.ReconciliationRequest) (map[string]any, error)

        labels      map[string]string
        annotations map[string]string
}

type ActionOpts func(*Action)

func WithCache(enabled bool) ActionOpts <span class="cov6" title="6">{
        return func(action *Action) </span><span class="cov6" title="6">{
                action.cache = enabled
        }</span>
}

func WithData(data map[string]any) ActionOpts <span class="cov3" title="2">{
        return func(action *Action) </span><span class="cov3" title="2">{
                for k, v := range data </span><span class="cov5" title="4">{
                        action.data[k] = v
                }</span>
        }
}

func WithDataFn(fns ...func(context.Context, *types.ReconciliationRequest) (map[string]any, error)) ActionOpts <span class="cov4" title="3">{
        return func(action *Action) </span><span class="cov4" title="3">{
                action.dataFn = append(action.dataFn, fns...)
        }</span>
}

func WithLabel(name string, value string) ActionOpts <span class="cov4" title="3">{
        return func(a *Action) </span><span class="cov4" title="3">{
                a.labels[name] = value
        }</span>
}

func WithLabels(values map[string]string) ActionOpts <span class="cov3" title="2">{
        return func(a *Action) </span><span class="cov3" title="2">{
                maps.Copy(a.labels, values)
        }</span>
}

func WithAnnotation(name string, value string) ActionOpts <span class="cov4" title="3">{
        return func(a *Action) </span><span class="cov4" title="3">{
                a.annotations[name] = value
        }</span>
}

func WithAnnotations(values map[string]string) ActionOpts <span class="cov3" title="2">{
        return func(a *Action) </span><span class="cov3" title="2">{
                maps.Copy(a.annotations, values)
        }</span>
}

func (a *Action) run(ctx context.Context, rr *types.ReconciliationRequest) error <span class="cov8" title="11">{
        return a.cacher.Render(ctx, rr, a.render)
}</span>

func (a *Action) decode(decoder runtime.Decoder, data []byte, info types.TemplateInfo) ([]unstructured.Unstructured, error) <span class="cov8" title="11">{
        u, err := resources.Decode(decoder, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode template: %w", err)
        }</span>

        <span class="cov8" title="11">for i := range u </span><span class="cov8" title="11">{
                resources.SetLabels(&amp;u[i], a.labels)
                resources.SetAnnotations(&amp;u[i], a.annotations)

                resources.SetLabels(&amp;u[i], info.Labels)
                resources.SetAnnotations(&amp;u[i], info.Annotations)
        }</span>

        <span class="cov8" title="11">return u, err</span>
}

func (a *Action) render(ctx context.Context, rr *types.ReconciliationRequest) (resources.UnstructuredList, error) <span class="cov8" title="10">{
        decoder := serializer.NewCodecFactory(rr.Client.Scheme()).UniversalDeserializer()

        data := maps.Clone(a.data)

        for _, fn := range a.dataFn </span><span class="cov4" title="3">{
                values, err := fn(ctx, rr)
                if err != nil </span><span class="cov3" title="2">{
                        return nil, fmt.Errorf("unable to compute template data: %w", err)
                }</span>

                <span class="cov3" title="2">maps.Copy(data, values)</span>
        }

        <span class="cov8" title="9">data[ComponentKey] = rr.Instance
        data[DSCIKey] = rr.DSCI

        result := make(resources.UnstructuredList, 0)

        var buffer bytes.Buffer

        for i := range rr.Templates </span><span class="cov8" title="10">{
                tmpl, err := gt.ParseFS(rr.Templates[i].FS, rr.Templates[i].Path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse template from: %w", err)
                }</span>

                <span class="cov8" title="10">tmpl = tmpl.Option("missingkey=error")

                for _, t := range tmpl.Templates() </span><span class="cov8" title="11">{
                        buffer.Reset()
                        err = t.Execute(&amp;buffer, data)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to execute template: %w", err)
                        }</span>

                        <span class="cov8" title="11">u, err := a.decode(decoder, buffer.Bytes(), rr.Templates[i])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to decode template: %w", err)
                        }</span>

                        <span class="cov8" title="11">result = append(result, u...)</span>
                }
        }

        <span class="cov8" title="9">return result, nil</span>
}

func NewAction(opts ...ActionOpts) actions.Fn <span class="cov7" title="7">{
        action := Action{
                data:        make(map[string]any),
                cacher:      resourcecacher.NewResourceCacher(rendererEngine),
                cache:       true,
                labels:      make(map[string]string),
                annotations: make(map[string]string),
        }

        for _, opt := range opts </span><span class="cov10" title="15">{
                opt(&amp;action)
        }</span>

        <span class="cov7" title="7">if action.cache </span><span class="cov3" title="2">{
                action.cacher.SetKeyFn(types.Hash)
        }</span>

        <span class="cov7" title="7">return action.run</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package resourcecacher

import (
        "context"
        "strings"

        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/cacher"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/render"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

// Renderer is the actual function received from upper layers
// which generates resources based on the ReconciliationRequest.
type Renderer func(ctx context.Context, rr *types.ReconciliationRequest) (resources.UnstructuredList, error)
type ResourceCacher struct {
        cacher.Cacher[resources.UnstructuredList]
        name string
}

func (s *ResourceCacher) SetKeyFn(key cacher.CachingKeyFn) <span class="cov8" title="1">{
        s.Cacher.SetKeyFn(key)
}</span>

func (s *ResourceCacher) Render(ctx context.Context, rr *types.ReconciliationRequest, r Renderer) error <span class="cov8" title="1">{
        log := logf.FromContext(ctx)
        inst, ok := rr.Instance.(common.WithDevFlags)
        if ok &amp;&amp; inst.GetDevFlags() != nil </span><span class="cov8" title="1">{
                // if dev flags are enabled, caching is disabled as dev flags are meant for
                // development time only where caching is not relevant
                log.V(4).Info("devFlags enabled, invalidating resource cache")
                s.InvalidateCache()
        }</span>

        <span class="cov8" title="1">res, acted, err := s.Cacher.Render(ctx, rr, r)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">resLen := len(res)

        if acted </span><span class="cov8" title="1">{
                log.V(4).Info("accounted rendered resources", "count", resLen)

                controllerName := strings.ToLower(rr.Instance.GetObjectKind().GroupVersionKind().Kind)
                render.RenderedResourcesTotal.WithLabelValues(controllerName, s.name).Add(float64(resLen))

                // flag new resources, used by GC to avoid useless run
                rr.Generated = true
        }</span>

        // deep copy object so changes done in the pipelines won't
        // alter them
        <span class="cov8" title="1">rr.Resources = append(rr.Resources, res.Clone()...)
        log.V(4).Info("added resources to the request", "count", resLen)

        return nil</span>
}

func NewResourceCacher(name string) ResourceCacher <span class="cov0" title="0">{
        return ResourceCacher{name: name}
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package deployments

import (
        "context"
        "fmt"
        "strings"

        appsv1 "k8s.io/api/apps/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

type Action struct {
        labels      map[string]string
        namespaceFn actions.StringGetter
}

type ActionOpts func(*Action)

func WithSelectorLabel(k string, v string) ActionOpts <span class="cov6" title="3">{
        return func(action *Action) </span><span class="cov6" title="3">{
                action.labels[k] = v
        }</span>
}

func WithSelectorLabels(values map[string]string) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                for k, v := range values </span><span class="cov0" title="0">{
                        action.labels[k] = v
                }</span>
        }
}

func InNamespace(ns string) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                action.namespaceFn = func(_ context.Context, _ *types.ReconciliationRequest) (string, error) </span><span class="cov0" title="0">{
                        return ns, nil
                }</span>
        }
}

func InNamespaceFn(fn actions.StringGetter) ActionOpts <span class="cov0" title="0">{
        return func(action *Action) </span><span class="cov0" title="0">{
                if fn == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">action.namespaceFn = fn</span>
        }
}

func (a *Action) run(ctx context.Context, rr *types.ReconciliationRequest) error <span class="cov8" title="5">{
        l := make(map[string]string, len(a.labels))
        for k, v := range a.labels </span><span class="cov6" title="3">{
                l[k] = v
        }</span>

        <span class="cov8" title="5">if l[labels.PlatformPartOf] == "" </span><span class="cov6" title="3">{
                kind, err := resources.KindForObject(rr.Client.Scheme(), rr.Instance)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov6" title="3">l[labels.PlatformPartOf] = strings.ToLower(kind)</span>
        }

        <span class="cov8" title="5">obj, ok := rr.Instance.(types.ResourceObject)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a ResourceObject", rr.Instance)
        }</span>

        <span class="cov8" title="5">deployments := &amp;appsv1.DeploymentList{}

        ns, err := a.namespaceFn(ctx, rr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to compute namespace: %w", err)
        }</span>

        <span class="cov8" title="5">err = rr.Client.List(
                ctx,
                deployments,
                client.InNamespace(ns),
                client.MatchingLabels(l),
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error fetching list of deployments: %w", err)
        }</span>

        <span class="cov8" title="5">ready := 0
        for _, deployment := range deployments.Items </span><span class="cov10" title="7">{
                if deployment.Status.ReadyReplicas == deployment.Status.Replicas &amp;&amp; deployment.Status.Replicas != 0 </span><span class="cov9" title="6">{
                        ready++
                }</span>
        }

        <span class="cov8" title="5">s := obj.GetStatus()

        rr.Conditions.MarkTrue(status.ConditionDeploymentsAvailable, conditions.WithObservedGeneration(s.ObservedGeneration))

        if len(deployments.Items) == 0 || (len(deployments.Items) &gt; 0 &amp;&amp; ready != len(deployments.Items)) </span><span class="cov6" title="3">{
                rr.Conditions.MarkFalse(
                        status.ConditionDeploymentsAvailable,
                        conditions.WithObservedGeneration(s.ObservedGeneration),
                        conditions.WithReason(status.ConditionDeploymentsNotAvailableReason),
                        conditions.WithMessage("%d/%d deployments ready", ready, len(deployments.Items)),
                )
        }</span>

        <span class="cov8" title="5">return nil</span>
}

func NewAction(opts ...ActionOpts) actions.Fn <span class="cov8" title="5">{
        action := Action{
                labels:      map[string]string{},
                namespaceFn: actions.ApplicationNamespace,
        }

        for _, opt := range opts </span><span class="cov6" title="3">{
                opt(&amp;action)
        }</span>

        <span class="cov8" title="5">return action.run</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package releases

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/yaml.v3"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        odhdeploy "github.com/opendatahub-io/opendatahub-operator/v2/pkg/deploy"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

const (
        ComponentMetadataFilename = "component_metadata.yaml"
)

type Action struct {
        metadataFilePath       string
        componentReleaseStatus []common.ComponentRelease
}

// WithMetadataFilePath is an ActionOpts function that sets a custom metadata file path.
func WithMetadataFilePath(filePath string) ActionOpts <span class="cov8" title="1">{
        return func(a *Action) </span><span class="cov8" title="1">{
                a.metadataFilePath = filePath
        }</span>
}

// WithComponentReleaseStatus allows setting a custom ComponentRelease for the action.
// This is mostly for testing purposes to simulate cached or pre-existing release statuses.
// In production scenarios, the action should fetch the current release status from the source rather than being manually set.
func WithComponentReleaseStatus(status []common.ComponentRelease) ActionOpts <span class="cov8" title="1">{
        return func(a *Action) </span><span class="cov8" title="1">{
                a.componentReleaseStatus = status
        }</span>
}

type ActionOpts func(*Action)

// run is responsible for executing the logic of reconciling and processing component releases.
//
// This function performs the following:
// 1. Verifies that the resource instance implements the `WithReleases` interface.
// 2. If the release status is not already cached, it calls the `render` method to fetch the releases from the metadata file.
// 3. Updates the release status on the resource instance with the processed release information.
//
// Parameters:
// - ctx: The context for managing deadlines and cancellations during the reconciliation process.
// - rr: The `ReconciliationRequest` containing the resource instance that needs to be reconciled.
//
// Returns:
//   - An error if the reconciliation fails at any step. This could occur if the resource doesn't implement the required interface
//     or if the metadata file cannot be read or processed.
func (a *Action) run(ctx context.Context, rr *types.ReconciliationRequest) error <span class="cov8" title="1">{
        // Ensure the resource implements the WithReleases interface
        obj, ok := rr.Instance.(common.WithReleases)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("resource instance %v is not a WithReleases", rr.Instance)
        }</span>

        // If the release status is empty, or if the DevFlags.Manifests is set, render the release information.
        // This ensures that releases are either reprocessed or fetched from the manifests specified in DevFlags.
        <span class="cov8" title="1">if len(a.componentReleaseStatus) == 0 || resources.InstanceHasDevFlags(rr.Instance) </span><span class="cov8" title="1">{
                releases, err := a.render(ctx, rr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">a.componentReleaseStatus = releases</span>
        }

        // Update the release status in the resource
        <span class="cov8" title="1">obj.SetReleaseStatus(a.componentReleaseStatus)

        return nil</span>
}

// render reads and processes the component releases from the metadata file.
//
// This function performs the following:
// 1. Reads the component metadata YAML file (either from a custom or default path).
// 2. Parses the YAML file and extracts the release metadata (name, version, repo URL).
// 3. Returns a slice of `ComponentRelease` containing the processed release information.
//
// Parameters:
// - rr: The `ReconciliationRequest` containing the resource instance. This is used to determine the metadata file path.
//
// Returns:
// - A slice of `common.ComponentRelease`, representing the parsed release information from the metadata file.
// - An error if there is an issue with reading the file, unmarshalling the YAML, or processing the release data.
func (a *Action) render(ctx context.Context, rr *types.ReconciliationRequest) ([]common.ComponentRelease, error) <span class="cov8" title="1">{
        log := logf.FromContext(ctx)

        // Determine the metadata file path
        var metadataPath string
        if a.metadataFilePath != "" </span><span class="cov8" title="1">{
                metadataPath = a.metadataFilePath
        }</span> else<span class="cov8" title="1"> {
                // Build the path to the component metadata file
                controllerName := strings.ToLower(rr.Instance.GetObjectKind().GroupVersionKind().Kind)
                metadataPath = filepath.Join(odhdeploy.DefaultManifestPath, controllerName, ComponentMetadataFilename)
        }</span>

        // Read the YAML file
        <span class="cov8" title="1">yamlData, err := os.ReadFile(metadataPath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        // Log a message indicating the file doesn't exist but do not return an error
                        // Log this as a warning, as it's not necessarily a failure if the file is absent
                        log.V(3).Info("Metadata file not found, proceeding with empty releases", "metadataFilePath", metadataPath)
                        // Return an empty slice of releases instead of an error
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error reading metadata file: %w", err)</span>
        }

        // Unmarshal YAML into defined struct
        <span class="cov8" title="1">var componentMeta common.ComponentReleaseStatus
        if err := yaml.Unmarshal(yamlData, &amp;componentMeta); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling YAML: %w", err)
        }</span>

        // Parse and populate releases
        <span class="cov8" title="1">componentReleasesStatus := make([]common.ComponentRelease, 0, len(componentMeta.Releases))
        for _, release := range componentMeta.Releases </span><span class="cov8" title="1">{
                componentVersion := strings.TrimSpace(release.Version)

                // Appending the component version only if it's not empty
                if componentVersion != "" </span><span class="cov8" title="1">{
                        componentReleasesStatus = append(componentReleasesStatus, common.ComponentRelease{
                                Name:    release.Name,
                                Version: componentVersion,
                                RepoURL: release.RepoURL,
                        })
                }</span>
        }

        <span class="cov8" title="1">return componentReleasesStatus, nil</span>
}

func NewAction(opts ...ActionOpts) actions.Fn <span class="cov8" title="1">{
        action := Action{}

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;action)
        }</span>

        <span class="cov8" title="1">return action.run</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">// inspired by https://github.com/knative/pkg/blob/main/apis/condition_set.go

package conditions

import (
        "cmp"
        "fmt"
        "slices"
        "sort"
        "strings"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
)

type Option func(*common.Condition)

func WithReason(value string) Option <span class="cov0" title="0">{
        return func(c *common.Condition) </span><span class="cov0" title="0">{
                c.Reason = value
        }</span>
}

func WithMessage(msg string, opts ...any) Option <span class="cov0" title="0">{
        value := msg
        if len(opts) != 0 </span><span class="cov0" title="0">{
                value = fmt.Sprintf(msg, opts...)
        }</span>

        <span class="cov0" title="0">return func(c *common.Condition) </span><span class="cov0" title="0">{
                c.Message = value
        }</span>
}

func WithObservedGeneration(value int64) Option <span class="cov0" title="0">{
        return func(c *common.Condition) </span><span class="cov0" title="0">{
                c.ObservedGeneration = value
        }</span>
}

func WithSeverity(value common.ConditionSeverity) Option <span class="cov2" title="2">{
        return func(c *common.Condition) </span><span class="cov2" title="2">{
                c.Severity = value
        }</span>
}

func WithError(err error) Option <span class="cov0" title="0">{
        return func(c *common.Condition) </span><span class="cov0" title="0">{
                c.Severity = common.ConditionSeverityError
                c.Reason = common.ConditionReasonError
                c.Message = err.Error()
        }</span>
}

type Manager struct {
        happy      string
        dependents []string
        accessor   common.ConditionsAccessor
}

func NewManager(accessor common.ConditionsAccessor, happy string, dependents ...string) *Manager <span class="cov4" title="7">{
        deps := make([]string, 0, len(dependents))
        for _, d := range dependents </span><span class="cov5" title="10">{
                if d == happy || slices.Contains(deps, d) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="10">deps = append(deps, d)</span>
        }

        <span class="cov4" title="7">m := Manager{
                accessor:   accessor,
                happy:      happy,
                dependents: deps,
        }

        m.initializeConditions()

        return &amp;m</span>
}

// initializeConditions ensures that the conditions for the manager and its dependents are properly
// initialized. Specifically, it initializes the "happy" condition and sets the initial status for
// each dependent condition.
//
// The method performs the following:
//  1. Retrieves the "happy" condition. If it does not exist, it creates a new one with
//     `ConditionUnknown` status and sets it.
//  2. Sets the status of each dependent condition based on the "happy" condition's status. If the
//     "happy" condition's status is `True`, all dependent conditions are set to `True`, otherwise
//     to `Unknown`.
func (r *Manager) initializeConditions() <span class="cov4" title="7">{
        happy := r.GetCondition(r.happy)
        if happy == nil </span><span class="cov4" title="7">{
                happy = &amp;common.Condition{
                        Type:   r.happy,
                        Status: metav1.ConditionUnknown,
                }
                r.SetCondition(*happy)
        }</span>

        <span class="cov4" title="7">status := metav1.ConditionUnknown
        if happy.Status == metav1.ConditionTrue </span><span class="cov0" title="0">{
                status = metav1.ConditionTrue
        }</span>

        <span class="cov4" title="7">for _, t := range r.dependents </span><span class="cov5" title="10">{
                if c := r.GetCondition(t); c != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="10">r.SetCondition(common.Condition{
                        Type:   t,
                        Status: status,
                })</span>
        }
}

func (r *Manager) IsHappy() bool <span class="cov5" title="12">{
        if r.accessor == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="12">return IsStatusConditionTrue(r.accessor, r.happy)</span>
}

func (r *Manager) GetTopLevelCondition() *common.Condition <span class="cov2" title="2">{
        return r.GetCondition(r.happy)
}</span>

func (r *Manager) GetCondition(t string) *common.Condition <span class="cov7" title="24">{
        return FindStatusCondition(r.accessor, t)
}</span>

// SetCondition sets the given condition on the manager. It updates the list of conditions and
// sorts them alphabetically. After updating, it recomputes the happiness state based on the
// provided condition type.
//
// Parameters:
//   - `cond`: The condition to set. The condition will be added or updated based on its type.
func (r *Manager) SetCondition(cond common.Condition) <span class="cov8" title="62">{
        if r.accessor == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="62">if !SetStatusCondition(r.accessor, cond) </span><span class="cov7" title="23">{
                return
        }</span>

        <span class="cov8" title="40">r.RecomputeHappiness(cond.Type)</span>
}

// ClearCondition removes the specified condition type from the manager's list of conditions
// and recomputes happiness.
//
// Parameters:
//   - `t`: The type of the condition to remove.
//
// Returns:
//   - `nil` if the condition was removed successfully or was not found.
func (r *Manager) ClearCondition(t string) error <span class="cov2" title="2">{
        if r.accessor == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov2" title="2">if !RemoveStatusCondition(r.accessor, t) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov2" title="2">r.RecomputeHappiness(t)

        return nil</span>
}

// Mark updates the status of a specified condition type and applies optional modifications.
//
// This method allows setting a condition to any of the possible statuses (`True`, `False`, or
// `Unknown`) while also allowing additional options to modify the condition before it is stored.
//
// Parameters:
//   - `t`: The type of the condition to update.
//   - `status`: The new status of the condition (one of `metav1.ConditionTrue`,
//     `metav1.ConditionFalse`, or `metav1.ConditionUnknown`).
//   - `opts`: Variadic options that can modify attributes of the condition (e.g., reason,
//     message, timestamp).
//
// Behavior:
//  1. Creates a `common.Condition` with the specified type and status.
//  2. Applies any provided options using `applyOpts(&amp;c, opts...)`.
//  3. Sets the condition using `r.SetCondition(c)`, which updates the condition list and
//     recomputes happiness.
func (r *Manager) Mark(t string, status metav1.ConditionStatus, opts ...Option) <span class="cov6" title="16">{
        c := common.Condition{
                Type:   t,
                Status: status,
        }

        applyOpts(&amp;c, opts...)

        r.SetCondition(c)
}</span>

func (r *Manager) MarkTrue(t string, opts ...Option) <span class="cov5" title="11">{
        r.Mark(t, metav1.ConditionTrue, opts...)
}</span>

func (r *Manager) MarkFalse(t string, opts ...Option) <span class="cov4" title="6">{
        r.Mark(t, metav1.ConditionFalse, opts...)
}</span>

func (r *Manager) MarkUnknown(t string, opts ...Option) <span class="cov0" title="0">{
        r.Mark(t, metav1.ConditionUnknown, opts...)
}</span>

func (r *Manager) MarkFrom(t string, in common.Condition) <span class="cov0" title="0">{
        c := common.Condition{
                Type:     t,
                Status:   in.Status,
                Reason:   in.Reason,
                Message:  in.Message,
                Severity: in.Severity,
        }

        r.SetCondition(c)
}</span>

// RecomputeHappiness re-evaluates the happiness state of the manager based on the current set
// of conditions.
//
// It checks if any dependent condition is unhappy (either `False` or `Unknown`). If found, the
// "happy" condition is updated to reflect the first unhappy condition's status. If no unhappy
// dependent conditions exist, it sets the "happy" condition to `True`.
//
// Parameters:
//   - `t`: The type of the condition that may have triggered a recomputation of happiness.
func (r *Manager) RecomputeHappiness(t string) <span class="cov8" title="41">{
        if c := r.findUnhappyDependent(); c != nil </span><span class="cov7" title="27">{
                r.SetCondition(common.Condition{
                        Type:    r.happy,
                        Status:  c.Status,
                        Reason:  c.Reason,
                        Message: c.Message,
                })
        }</span> else<span class="cov6" title="15"> if t != r.happy </span><span class="cov4" title="6">{
                r.SetCondition(common.Condition{
                        Type:   r.happy,
                        Status: metav1.ConditionTrue,
                })
        }</span>
}

// findUnhappyDependent identifies and returns the first dependent condition that is unhappy (i.e.,
// False or Unknown).
//
// The method operates by filtering and sorting the current conditions, checking if they meet
// the criteria for being unhappy:
// - The condition must have a Severity level of "Error".
// - The dependent condition is either `ConditionFalse` or `ConditionUnknown`.
//
// The function performs the following steps:
//  1. It determines the number of dependents and retrieves the current conditions.
//  2. It iterates through each condition, filtering out conditions that do not meet the criteria
//     (e.g., those not related to the dependents or those without "Error" severity).
//  3. It sorts the remaining conditions by the `LastTransitionTime` in descending order.
//  4. It returns the first `ConditionFalse` or `ConditionUnknown` condition found, prioritizing
//     the former.
//
// If no unhappy condition is found, the function returns nil.
//
// Returns:
//   - A pointer to the first unhappy condition if found, otherwise nil.
func (r *Manager) findUnhappyDependent() *common.Condition <span class="cov8" title="41">{
        dn := len(r.dependents)

        conditions := slices.Clone(r.accessor.GetConditions())
        n := 0

        for _, c := range conditions </span><span class="cov10" title="108">{
                switch </span>{
                case dn == 0 &amp;&amp; c.Type == r.happy:<span class="cov5" title="10">
                        break</span>
                case dn != 0 &amp;&amp; !slices.Contains(r.dependents, c.Type):<span class="cov7" title="38">
                        break</span>
                case c.Severity != common.ConditionSeverityError:<span class="cov0" title="0">
                        break</span>
                default:<span class="cov8" title="62">
                        conditions[n] = c
                        n++</span>
                }
        }

        <span class="cov8" title="41">conditions = conditions[:n]

        sort.Slice(conditions, func(i, j int) bool </span><span class="cov7" title="28">{
                return conditions[i].LastTransitionTime.After(conditions[j].LastTransitionTime.Time)
        }</span>)

        <span class="cov8" title="41">for _, c := range conditions </span><span class="cov8" title="53">{
                if c.Status == metav1.ConditionFalse </span><span class="cov5" title="11">{
                        ret := c
                        return &amp;ret
                }</span>
        }

        <span class="cov7" title="31">for _, c := range conditions </span><span class="cov7" title="34">{
                if c.Status == metav1.ConditionUnknown </span><span class="cov6" title="17">{
                        ret := c
                        return &amp;ret
                }</span>
        }

        <span class="cov6" title="15">return nil</span>
}

// Reset clears all conditions managed by the Manager.
//
// It achieves this by setting an empty slice of common.Condition
// in the underlying accessor.
func (r *Manager) Reset() <span class="cov0" title="0">{
        r.accessor.SetConditions([]common.Condition{})
}</span>

// Sort arranges the conditions retrieved from the accessor based on the following rules:
// 1. `happy` condition is assigned the highest priority.
// 2. `dependents` are prioritized in the order they are defined.
// 3. Conditions with priority `0` (not explicitly listed) are sorted alphabetically.
//
// The sorting is stable, ensuring consistent ordering when conditions have the same
// priority.
func (r *Manager) Sort() <span class="cov2" title="2">{
        conditions := r.accessor.GetConditions()
        if len(conditions) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="2">priorities := make(map[string]int)
        dl := len(r.dependents)

        for i, d := range r.dependents </span><span class="cov3" title="3">{
                priorities[d] = dl - i
        }</span>

        <span class="cov2" title="2">priorities[r.happy] = len(r.dependents) + 1

        slices.SortStableFunc(conditions, func(a, b common.Condition) int </span><span class="cov4" title="6">{
                ret := cmp.Compare(priorities[b.Type], priorities[a.Type])
                if ret == 0 </span><span class="cov3" title="3">{
                        ret = strings.Compare(a.Type, b.Type)
                }</span>

                <span class="cov4" title="6">return ret</span>
        })
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package conditions

import (
        "slices"
        "time"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
)

func SetStatusCondition(a common.ConditionsAccessor, newCondition common.Condition) bool <span class="cov9" title="67">{
        conditions := a.GetConditions()

        // reset LastHeartbeatTime to ensure is not set in any condition that is
        // eventually carrying it from an old implementation
        newCondition.LastHeartbeatTime = nil

        if newCondition.LastTransitionTime.IsZero() </span><span class="cov9" title="67">{
                newCondition.LastTransitionTime = metav1.NewTime(time.Now())
        }</span>

        <span class="cov9" title="67">idx := slices.IndexFunc(conditions, func(condition common.Condition) bool </span><span class="cov10" title="104">{
                return condition.Type == newCondition.Type
        }</span>)

        <span class="cov9" title="67">if idx == -1 </span><span class="cov6" title="21">{
                if newCondition.LastTransitionTime.IsZero() </span><span class="cov0" title="0">{
                        newCondition.LastTransitionTime = metav1.NewTime(time.Now())
                }</span>
                <span class="cov6" title="21">conditions = append(conditions, newCondition)
                a.SetConditions(conditions)
                return true</span>
        }

        <span class="cov8" title="47">if equals(conditions[idx], newCondition) </span><span class="cov7" title="24">{
                return false
        }</span>

        <span class="cov7" title="24">updateTransitionTime := conditions[idx].Status != newCondition.Status

        conditions[idx] = newCondition
        conditions[idx].LastHeartbeatTime = nil

        if updateTransitionTime </span><span class="cov7" title="24">{
                conditions[idx].LastTransitionTime = newCondition.LastTransitionTime

                if conditions[idx].LastTransitionTime.IsZero() </span><span class="cov0" title="0">{
                        conditions[idx].LastTransitionTime = metav1.NewTime(time.Now())
                }</span>
        }

        <span class="cov7" title="24">a.SetConditions(conditions)

        return true</span>
}

func RemoveStatusCondition(a common.ConditionsAccessor, conditionType string) bool <span class="cov2" title="2">{
        conditions := a.GetConditions()
        l := len(conditions)

        if l == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov2" title="2">conditions = slices.DeleteFunc(conditions, func(condition common.Condition) bool </span><span class="cov3" title="3">{
                return condition.Type == conditionType
        }</span>)

        <span class="cov2" title="2">removed := l != len(conditions)
        if removed </span><span class="cov2" title="2">{
                a.SetConditions(conditions)
        }</span>

        <span class="cov2" title="2">return removed</span>
}

func FindStatusCondition(a common.ConditionsAccessor, conditionType string) *common.Condition <span class="cov7" title="32">{
        for _, c := range a.GetConditions() </span><span class="cov7" title="36">{
                if c.Type == conditionType </span><span class="cov6" title="15">{
                        return c.DeepCopy()
                }</span>
        }

        <span class="cov6" title="18">return nil</span>
}

func IsStatusConditionTrue(a common.ConditionsAccessor, conditionType string) bool <span class="cov5" title="12">{
        return IsStatusConditionPresentAndEqual(a, conditionType, metav1.ConditionTrue)
}</span>

func IsStatusConditionFalse(a common.ConditionsAccessor, conditionType string) bool <span class="cov0" title="0">{
        return IsStatusConditionPresentAndEqual(a, conditionType, metav1.ConditionFalse)
}</span>

func IsStatusConditionPresentAndEqual(a common.ConditionsAccessor, conditionType string, status metav1.ConditionStatus) bool <span class="cov5" title="12">{
        return slices.ContainsFunc(a.GetConditions(), func(condition common.Condition) bool </span><span class="cov7" title="30">{
                return condition.Type == conditionType &amp;&amp; condition.Status == status
        }</span>)
}

func applyOpts(c *common.Condition, opts ...Option) <span class="cov6" title="16">{
        for _, o := range opts </span><span class="cov2" title="2">{
                o(c)
        }</span>
}

func equals(c1 common.Condition, c2 common.Condition) bool <span class="cov8" title="47">{
        return c1.Status == c2.Status &amp;&amp;
                c1.Reason == c2.Reason &amp;&amp;
                c1.Message == c2.Message &amp;&amp;
                c1.ObservedGeneration == c2.ObservedGeneration &amp;&amp;
                c1.Severity == c2.Severity
}</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">package resources

import (
        "reflect"
        "strings"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

var _ predicate.Predicate = DeploymentPredicate{}

type DeploymentPredicate struct {
        predicate.Funcs
}

// Update implements default UpdateEvent filter for validating generation change.
func (DeploymentPredicate) Update(e event.UpdateEvent) bool <span class="cov0" title="0">{
        if e.ObjectOld == nil || e.ObjectNew == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">oldDeployment, ok := e.ObjectOld.(*appsv1.Deployment)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">newDeployment, ok := e.ObjectNew.(*appsv1.Deployment)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return oldDeployment.Generation != newDeployment.Generation ||
                oldDeployment.Status.Replicas != newDeployment.Status.Replicas ||
                oldDeployment.Status.ReadyReplicas != newDeployment.Status.ReadyReplicas</span>
}

func NewDeploymentPredicate() *DeploymentPredicate <span class="cov0" title="0">{
        return &amp;DeploymentPredicate{}
}</span>

func Deleted() predicate.Funcs <span class="cov0" title="0">{
        return predicate.Funcs{
                CreateFunc: func(e event.CreateEvent) bool </span><span class="cov0" title="0">{
                        return false
                }</span>,
                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
                DeleteFunc: func(e event.DeleteEvent) bool <span class="cov0" title="0">{
                        return true
                }</span>,
                GenericFunc: func(e event.GenericEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
        }
}

// Content predicates moved from original controller.
var CMContentChangedPredicate = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                oldCM, _ := e.ObjectOld.(*corev1.ConfigMap)
                newCM, _ := e.ObjectNew.(*corev1.ConfigMap)
                return !reflect.DeepEqual(oldCM.Data, newCM.Data)
        }</span>,
}

var SecretContentChangedPredicate = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                oldSecret, _ := e.ObjectOld.(*corev1.Secret)
                newSecret, _ := e.ObjectNew.(*corev1.Secret)
                return !reflect.DeepEqual(oldSecret.Data, newSecret.Data)
        }</span>,
}

var DSCDeletionPredicate = predicate.Funcs{
        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov0" title="0">{
                return true
        }</span>,
}

var DSCComponentUpdatePredicate = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                oldDSC, ok := e.ObjectOld.(*dscv1.DataScienceCluster)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">newDSC, ok := e.ObjectNew.(*dscv1.DataScienceCluster)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                // if .spec.components is changed, return true.
                <span class="cov0" title="0">if !reflect.DeepEqual(oldDSC.Spec.Components, newDSC.Spec.Components) </span><span class="cov0" title="0">{
                        return true
                }</span>

                // if new condition from component is added or removed, return true
                <span class="cov0" title="0">oldConditions := oldDSC.Status.Conditions
                newConditions := newDSC.Status.Conditions
                if len(oldConditions) != len(newConditions) </span><span class="cov0" title="0">{
                        return true
                }</span>

                // compare type one by one with their status if not equal return true
                <span class="cov0" title="0">for _, nc := range newConditions </span><span class="cov0" title="0">{
                        for _, oc := range oldConditions </span><span class="cov0" title="0">{
                                if nc.Type == oc.Type </span><span class="cov0" title="0">{
                                        if !reflect.DeepEqual(nc.Status, oc.Status) </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">return false</span>
        },
}

var DSCIReadiness = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                oldObj, ok := e.ObjectOld.(*dsciv1.DSCInitialization)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">newObj, ok := e.ObjectNew.(*dsciv1.DSCInitialization)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return oldObj.Status.Phase != newObj.Status.Phase</span>
        },
        CreateFunc: func(e event.CreateEvent) bool <span class="cov0" title="0">{
                return false
        }</span>,
        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov0" title="0">{
                return false
        }</span>,
        GenericFunc: func(e event.GenericEvent) bool <span class="cov0" title="0">{
                return false
        }</span>,
}

func AnnotationChanged(name string) predicate.Funcs <span class="cov10" title="7">{
        return predicate.Funcs{
                CreateFunc: func(e event.CreateEvent) bool </span><span class="cov0" title="0">{
                        return true
                }</span>,
                DeleteFunc: func(e event.DeleteEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov10" title="7">{
                        return resources.GetAnnotation(e.ObjectNew, name) != resources.GetAnnotation(e.ObjectOld, name)
                }</span>,
        }
}

func CreatedOrUpdatedName(name string) predicate.Predicate <span class="cov0" title="0">{
        return predicate.Funcs{
                CreateFunc: func(e event.TypedCreateEvent[client.Object]) bool </span><span class="cov0" title="0">{
                        return e.Object.GetName() == name
                }</span>,
                UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool <span class="cov0" title="0">{
                        return e.ObjectNew.GetName() == name
                }</span>,
        }
}

func CreatedOrUpdatedOrDeletedNamed(name string) predicate.Predicate <span class="cov0" title="0">{
        return predicate.Funcs{
                CreateFunc: func(e event.TypedCreateEvent[client.Object]) bool </span><span class="cov0" title="0">{
                        return e.Object.GetName() == name
                }</span>,
                UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool <span class="cov0" title="0">{ return e.ObjectNew.GetName() == name }</span>,
                DeleteFunc: func(e event.TypedDeleteEvent[client.Object]) bool <span class="cov0" title="0">{ return e.Object.GetName() == name }</span>,
        }
}

func CreatedOrUpdatedOrDeletedNamePrefixed(namePrefix string) predicate.Predicate <span class="cov0" title="0">{
        return predicate.Funcs{
                CreateFunc: func(e event.TypedCreateEvent[client.Object]) bool </span><span class="cov0" title="0">{
                        return strings.HasPrefix(e.Object.GetName(), namePrefix)
                }</span>,
                UpdateFunc: func(e event.TypedUpdateEvent[client.Object]) bool <span class="cov0" title="0">{
                        return strings.HasPrefix(e.ObjectNew.GetName(), namePrefix)
                }</span>,
                DeleteFunc: func(e event.TypedDeleteEvent[client.Object]) bool <span class="cov0" title="0">{
                        return strings.HasPrefix(e.Object.GetName(), namePrefix)
                }</span>,
        }
}

var DSCIServiceMeshCondition = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov9" title="6">{
                oldObj, ok := e.ObjectOld.(*dsciv1.DSCInitialization)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov9" title="6">newObj, ok := e.ObjectNew.(*dsciv1.DSCInitialization)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov9" title="6">oldMeshCondition := conditions.FindStatusCondition(&amp;oldObj.Status, status.CapabilityServiceMesh)
                newMeshCondition := conditions.FindStatusCondition(&amp;newObj.Status, status.CapabilityServiceMesh)

                if oldMeshCondition == nil || newMeshCondition == nil </span><span class="cov7" title="4">{
                        return oldMeshCondition != newMeshCondition
                }</span>

                <span class="cov6" title="3">return oldMeshCondition.Status != newMeshCondition.Status</span>
        },
        CreateFunc: func(e event.CreateEvent) bool <span class="cov4" title="2">{
                return false
        }</span>,
        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov4" title="2">{
                return false
        }</span>,
        GenericFunc: func(e event.GenericEvent) bool <span class="cov4" title="2">{
                return false
        }</span>,
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package reconciler

import (
        "context"
        "errors"
        "fmt"
        "reflect"

        "github.com/go-logr/logr"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/tools/record"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/manager"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        odherrors "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions/errors"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

type gvkInfo struct {
        owned bool
}

type ReconcilerOpt func(*Reconciler)

func WithConditionsManagerFactory(happy string, dependants ...string) ReconcilerOpt <span class="cov8" title="1">{
        return func(reconciler *Reconciler) </span><span class="cov8" title="1">{
                reconciler.conditionsManagerFactory = func(accessor common.ConditionsAccessor) *conditions.Manager </span><span class="cov8" title="1">{
                        return conditions.NewManager(accessor, happy, dependants...)
                }</span>
        }
}

const platformFinalizer = "platform.opendatahub.io/finalizer"

// Reconciler provides generic reconciliation functionality for ODH objects.
type Reconciler struct {
        Client          client.Client
        discoveryClient discovery.DiscoveryInterface
        dynamicClient   dynamic.Interface

        Scheme     *runtime.Scheme
        Actions    []actions.Fn
        Finalizer  []actions.Fn
        Log        logr.Logger
        Controller controller.Controller
        Recorder   record.EventRecorder
        Release    common.Release

        name                     string
        instanceFactory          func() (common.PlatformObject, error)
        conditionsManagerFactory func(common.ConditionsAccessor) *conditions.Manager
        gvks                     map[schema.GroupVersionKind]gvkInfo
}

// NewReconciler creates a new reconciler for the given type.
func NewReconciler[T common.PlatformObject](mgr manager.Manager, name string, object T, opts ...ReconcilerOpt) (*Reconciler, error) <span class="cov0" title="0">{
        discoveryCli, err := discovery.NewDiscoveryClientForConfig(mgr.GetConfig())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to construct a Discovery client: %w", err)
        }</span>
        <span class="cov0" title="0">dynamicCli, err := dynamic.NewForConfig(mgr.GetConfig())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to construct a Dynamic client: %w", err)
        }</span>

        <span class="cov0" title="0">return newReconcilerWithClients(mgr, name, object, discoveryCli, dynamicCli, opts...)</span>
}

// newReconcilerWithClients creates a new reconciler with pre-initialized clients.
// This is used internally to avoid recreating clients that were already validated.
// discoveryClient and dynamicClient must be non-nil when injected.
func newReconcilerWithClients[T common.PlatformObject](
        mgr manager.Manager,
        name string,
        object T,
        discoveryClient discovery.DiscoveryInterface,
        dynamicClient dynamic.Interface,
        opts ...ReconcilerOpt,
) (*Reconciler, error) <span class="cov8" title="1">{
        // Precondition checks: ensure required clients are non-nil
        if discoveryClient == nil </span><span class="cov0" title="0">{
                return nil, errors.New("discoveryClient cannot be nil")
        }</span>
        <span class="cov8" title="1">if dynamicClient == nil </span><span class="cov0" title="0">{
                return nil, errors.New("dynamicClient cannot be nil")
        }</span>

        <span class="cov8" title="1">cc := Reconciler{
                Client:   mgr.GetClient(),
                Scheme:   mgr.GetScheme(),
                Log:      ctrl.Log.WithName("controllers").WithName(name),
                Recorder: mgr.GetEventRecorderFor(name),
                Release:  cluster.GetRelease(),
                name:     name,
                instanceFactory: func() (common.PlatformObject, error) </span><span class="cov8" title="1">{
                        t := reflect.TypeOf(object)
                        if t.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("expected pointer to type %v", t)
                        }</span>
                        <span class="cov8" title="1">t = t.Elem()
                        res, ok := reflect.New(t).Interface().(T)
                        if !ok </span><span class="cov0" title="0">{
                                return res, fmt.Errorf("unable to construct instance of %v", t)
                        }</span>

                        <span class="cov8" title="1">return res, nil</span>
                },
                conditionsManagerFactory: func(accessor common.ConditionsAccessor) *conditions.Manager <span class="cov0" title="0">{
                        return conditions.NewManager(accessor, status.ConditionTypeReady)
                }</span>,
                gvks:            make(map[schema.GroupVersionKind]gvkInfo),
                dynamicClient:   dynamicClient,
                discoveryClient: discoveryClient,
        }

        <span class="cov8" title="1">for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;cc)
        }</span>

        <span class="cov8" title="1">return &amp;cc, nil</span>
}

func (r *Reconciler) GetRelease() common.Release <span class="cov0" title="0">{
        return r.Release
}</span>

func (r *Reconciler) GetLogger() logr.Logger <span class="cov0" title="0">{
        return r.Log
}</span>

func (r *Reconciler) GetClient() client.Client <span class="cov0" title="0">{
        return r.Client
}</span>

func (r *Reconciler) GetDiscoveryClient() discovery.DiscoveryInterface <span class="cov0" title="0">{
        return r.discoveryClient
}</span>

func (r *Reconciler) GetDynamicClient() dynamic.Interface <span class="cov0" title="0">{
        return r.dynamicClient
}</span>

func (r *Reconciler) AddOwnedType(gvk schema.GroupVersionKind) <span class="cov0" title="0">{
        r.gvks[gvk] = gvkInfo{
                owned: true,
        }
}</span>

func (r *Reconciler) Owns(gvk schema.GroupVersionKind) bool <span class="cov0" title="0">{
        i, ok := r.gvks[gvk]
        return ok &amp;&amp; i.owned
}</span>

func (r *Reconciler) AddAction(action actions.Fn) <span class="cov8" title="1">{
        r.Actions = append(r.Actions, action)
}</span>

func (r *Reconciler) AddFinalizer(action actions.Fn) <span class="cov8" title="1">{
        r.Finalizer = append(r.Finalizer, action)
}</span>

func (r *Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        l := log.FromContext(ctx)
        l.Info("reconcile")

        res, err := r.instanceFactory()
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">if err := r.Client.Get(ctx, req.NamespacedName, res); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, client.IgnoreNotFound(err)
        }</span>

        <span class="cov8" title="1">if err := resources.EnsureGroupVersionKind(r.Client.Scheme(), res); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, fmt.Errorf("unable to set GVK to instance: %w", err)
        }</span>

        <span class="cov8" title="1">if !res.GetDeletionTimestamp().IsZero() </span><span class="cov8" title="1">{
                // resource is being deleted, attempt to perform clean-up logic and remove finalizer
                if !controllerutil.ContainsFinalizer(res, platformFinalizer) </span><span class="cov0" title="0">{
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov8" title="1">if err := r.delete(ctx, res); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.removeFinalizer(ctx, res); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        } else<span class="cov8" title="1"> {
                // resource is not being deleted, attempt to add finalizer
                if err := r.addFinalizer(ctx, res); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.apply(ctx, res); err != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

func (r *Reconciler) addFinalizer(ctx context.Context, res common.PlatformObject) error <span class="cov8" title="1">{
        // no finalizer action present =&gt; no finalizer to be added/checked for
        if len(r.Finalizer) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if !controllerutil.AddFinalizer(res, platformFinalizer) </span><span class="cov0" title="0">{
                // finalizer already present
                return nil
        }</span>

        <span class="cov8" title="1">l := log.FromContext(ctx)
        l.Info("adding finalizer")
        if err := r.Client.Update(ctx, res); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add finalizer %s to %s: %w", platformFinalizer, res.GetName(), err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) removeFinalizer(ctx context.Context, res common.PlatformObject) error <span class="cov8" title="1">{
        if !controllerutil.RemoveFinalizer(res, platformFinalizer) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">l := log.FromContext(ctx)
        l.Info("removing finalizer")
        if err := r.Client.Update(ctx, res); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove finalizer %s from %s: %w", platformFinalizer, res.GetName(), err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) delete(ctx context.Context, res common.PlatformObject) error <span class="cov8" title="1">{
        l := log.FromContext(ctx)
        l.Info("delete")

        rr := types.ReconciliationRequest{
                Client:     r.Client,
                Controller: r,
                Instance:   res,
                Conditions: r.conditionsManagerFactory(res),
                Release:    r.Release,
                Manifests:  make([]types.ManifestInfo, 0),

                // The DSCI should not be required when deleting a component, if the
                // component requires some additional info, then such info should be
                // stored as part of the spec/status
                DSCI: nil,
        }

        // Execute finalizers
        for _, action := range r.Finalizer </span><span class="cov8" title="1">{
                l.V(3).Info("Executing finalizer", "action", action)

                actx := log.IntoContext(
                        ctx,
                        l.WithName(actions.ActionGroup).WithName(action.String()),
                )

                if err := action(actx, &amp;rr); err != nil </span><span class="cov0" title="0">{
                        se := odherrors.StopError{}
                        if !errors.As(err, &amp;se) </span><span class="cov0" title="0">{
                                l.Error(err, "Failed to execute finalizer", "action", action)
                                return err
                        }</span>

                        <span class="cov0" title="0">l.V(3).Info("detected stop marker", "action", action)
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) apply(ctx context.Context, res common.PlatformObject) error <span class="cov8" title="1">{
        l := log.FromContext(ctx)
        l.Info("apply")

        rr := types.ReconciliationRequest{
                Client:     r.Client,
                Controller: r,
                Instance:   res,
                Conditions: r.conditionsManagerFactory(res),
                Release:    r.Release,
                Manifests:  make([]types.ManifestInfo, 0),
        }

        // reset conditions so any unknown condition eventually set on
        // the owned resource get cleaned up. This is the case when a
        // condition is replaced/removed.

        rr.Conditions.Reset()

        var provisionErr error

        dsci, dscilErr := cluster.GetDSCI(ctx, r.Client)
        switch </span>{
        case dscilErr != nil:<span class="cov0" title="0">
                provisionErr = fmt.Errorf("failed to get DSCInitialization: %w", dscilErr)</span>
        default:<span class="cov8" title="1">
                provisionErr = nil
                rr.DSCI = dsci.DeepCopy()

                // Execute actions
                for _, action := range r.Actions </span><span class="cov8" title="1">{
                        l.Info("Executing action", "action", action)

                        actx := log.IntoContext(
                                ctx,
                                l.WithName(actions.ActionGroup).WithName(action.String()),
                        )

                        provisionErr = action(actx, &amp;rr)
                        if provisionErr != nil </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if provisionErr != nil </span><span class="cov8" title="1">{
                rr.Conditions.MarkFalse(
                        status.ConditionTypeProvisioningSucceeded,
                        conditions.WithError(provisionErr),
                        conditions.WithObservedGeneration(rr.Instance.GetGeneration()),
                )
        }</span> else<span class="cov8" title="1"> {
                rr.Conditions.MarkTrue(
                        status.ConditionTypeProvisioningSucceeded,
                        conditions.WithObservedGeneration(rr.Instance.GetGeneration()),
                )
        }</span>

        <span class="cov8" title="1">is := rr.Instance.GetStatus()
        is.Phase = status.PhaseNotReady

        // Update happiness to cover the case where conditions were
        // not set using the provided helper functions
        rr.Conditions.RecomputeHappiness("")

        // keep conditions sorted, keeping general conditions on the
        // top, other conditions after
        rr.Conditions.Sort()

        if rr.Conditions.IsHappy() </span><span class="cov8" title="1">{
                is.Phase = status.PhaseReady
                is.ObservedGeneration = rr.Instance.GetGeneration()
        }</span>

        <span class="cov8" title="1">err := resources.ApplyStatus(
                ctx,
                r.Client,
                rr.Instance,
                client.FieldOwner(r.name),
                client.ForceOwnership,
        )

        if err != nil &amp;&amp; !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                r.Recorder.Event(
                        res,
                        corev1.EventTypeNormal,
                        "ReconcileError",
                        err.Error(),
                )

                return fmt.Errorf("reconcile failed: %w", err)
        }</span>

        <span class="cov8" title="1">if provisionErr != nil </span><span class="cov8" title="1">{
                r.Recorder.Event(
                        res,
                        corev1.EventTypeWarning,
                        "ProvisioningError",
                        provisionErr.Error(),
                )

                return fmt.Errorf("provisioning failed: %w", provisionErr)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package reconciler

import (
        "context"
        "fmt"
        "strings"

        "k8s.io/apimachinery/pkg/runtime/schema"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
)

type dynamicWatchFn func(client.Object, handler.EventHandler, ...predicate.Predicate) error

type dynamicWatchAction struct {
        fn      dynamicWatchFn
        watches []watchInput
        watched map[schema.GroupVersionKind]struct{}
}

func (a *dynamicWatchAction) run(ctx context.Context, rr *types.ReconciliationRequest) error <span class="cov8" title="1">{
        controllerName := strings.ToLower(rr.Instance.GetObjectKind().GroupVersionKind().Kind)

        for i := range a.watches </span><span class="cov8" title="1">{
                w := a.watches[i]
                gvk := w.object.GetObjectKind().GroupVersionKind()

                if _, ok := a.watched[gvk]; ok </span><span class="cov8" title="1">{
                        // already registered
                        continue</span>
                }

                <span class="cov8" title="1">ok := a.shouldWatch(ctx, w, rr)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">err := a.fn(w.object, w.eventHandler, w.predicates...)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create watcher for %s: %w", w.object.GetObjectKind().GroupVersionKind(), err)
                }</span>

                <span class="cov8" title="1">a.watched[gvk] = struct{}{}
                DynamicWatchResourcesTotal.WithLabelValues(controllerName).Inc()</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (a *dynamicWatchAction) shouldWatch(ctx context.Context, in watchInput, rr *types.ReconciliationRequest) bool <span class="cov8" title="1">{
        // Evaluate all dynamic predicates for this watch
        for _, predicate := range in.dynamicPredicates </span><span class="cov0" title="0">{
                if !predicate(ctx, rr) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func newDynamicWatch(fn dynamicWatchFn, watches []watchInput) *dynamicWatchAction <span class="cov8" title="1">{
        action := dynamicWatchAction{
                fn:      fn,
                watched: map[schema.GroupVersionKind]struct{}{},
        }

        for i := range watches </span><span class="cov8" title="1">{
                if !watches[i].dynamic </span><span class="cov0" title="0">{
                        // not dynamic
                        continue</span>
                }

                <span class="cov8" title="1">action.watches = append(action.watches, watches[i])</span>
        }

        <span class="cov8" title="1">return &amp;action</span>
}

func newDynamicWatchAction(fn dynamicWatchFn, watches []watchInput) actions.Fn <span class="cov0" title="0">{
        action := newDynamicWatch(fn, watches)
        return action.run
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package reconciler

import (
        "github.com/prometheus/client_golang/prometheus"
        "sigs.k8s.io/controller-runtime/pkg/metrics"
)

var (
        // DynamicWatchResourcesTotal is a prometheus counter metrics which holds the total
        // number of dynamically watched resource per controller.
        // It has one labels.
        // controller label refers to the controller name.
        DynamicWatchResourcesTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "action_dynamic_watch_total",
                        Help: "Number of dynamically watched resources",
                },
                []string{
                        "controller",
                },
        )
)

// init register metrics to the global registry from controller-runtime/pkg/metrics.
// see https://book.kubebuilder.io/reference/metrics#publishing-additional-metrics
//
//nolint:gochecknoinits
func init() <span class="cov8" title="1">{
        metrics.Registry.MustRegister(DynamicWatchResourcesTotal)
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">// Package reconciler provides a fluent API for building Kubernetes controllers with support
// for both static and dynamic predicates. Dynamic predicates enable conditional watching
// based on runtime state rather than static configuration.
//
// Key Features:
// - Dynamic predicates that are evaluated at runtime during reconciliation
// - Thread-safe predicate storage with read-write locks
// - Fluent API for building reconcilers with watches, predicates, actions, and finalizers
// - Support for conditional watching based on CRD existence and other runtime conditions
// - Configurable predicate behavior with restrictive default (generation changes only)
// - Opt-in broader predicate behavior for label and annotation changes
//
// Example Usage:
//
//        // Default behavior - only generation changes trigger reconciliation
//        builder := ReconcilerFor(mgr, &amp;MyObject{})
//        builder.Watches(
//            &amp;SomeResource{},
//            Dynamic(CrdExists(schema.GroupVersionKind{Group: "example.com", Version: "v1", Kind: "MyCRD"})),
//        )
//        reconciler, err := builder.Build(ctx)
//
//        // Opt-in broader behavior - generation, label, and annotation changes trigger reconciliation
//        builder := ReconcilerFor(mgr, &amp;MyObject{}).WithBroadPredicate()
//        reconciler, err := builder.Build(ctx)
package reconciler

import (
        "context"
        "errors"
        "fmt"
        "slices"
        "strings"
        "sync"

        "github.com/hashicorp/go-multierror"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/actions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/handlers"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/predicates/component"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/types"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

// errDynamicWatchesNotImplemented is a sentinel error returned when dynamic watches are not yet supported.
var errDynamicWatchesNotImplemented = errors.New("dynamic watches are not yet implemented (pending controller-runtime support)")

type forInput struct {
        object  client.Object
        options []builder.ForOption
        gvk     schema.GroupVersionKind
}

// DynamicPredicate is a function type that evaluates whether a watch should be active
// based on the current reconciliation context. It receives the context and reconciliation
// request, and returns true if the watch should be active, false otherwise.
// Dynamic predicates are evaluated at runtime during each reconciliation cycle.
type DynamicPredicate func(context.Context, *types.ReconciliationRequest) bool

// watchInput contains the configuration for a single watch operation.
// It includes both static predicates (evaluated at watch creation time) and
// dynamic predicates (evaluated at runtime during reconciliation).
type watchInput struct {
        object            client.Object
        eventHandler      handler.EventHandler
        predicates        []predicate.Predicate
        dynamicPredicates []DynamicPredicate
        owned             bool
        dynamic           bool
}

type WatchOpts func(*watchInput)

func WithPredicates(values ...predicate.Predicate) WatchOpts <span class="cov0" title="0">{
        return func(a *watchInput) </span><span class="cov0" title="0">{
                a.predicates = append(a.predicates, values...)
        }</span>
}

func WithEventHandler(value handler.EventHandler) WatchOpts <span class="cov0" title="0">{
        return func(a *watchInput) </span><span class="cov0" title="0">{
                a.eventHandler = value
        }</span>
}

func WithEventMapper(value handler.MapFunc) WatchOpts <span class="cov0" title="0">{
        return func(a *watchInput) </span><span class="cov0" title="0">{
                a.eventHandler = handler.EnqueueRequestsFromMapFunc(value)
        }</span>
}

// Dynamic creates a WatchOpts function that marks a watch as dynamic and stores
// the provided dynamic predicates for runtime evaluation. Dynamic predicates are
// evaluated during reconciliation to determine if a watch should be active.
// This enables conditional watching based on runtime state rather than static configuration.
func Dynamic(predicates ...DynamicPredicate) WatchOpts <span class="cov0" title="0">{
        return func(a *watchInput) </span><span class="cov0" title="0">{
                a.dynamic = true
                a.dynamicPredicates = append(a.dynamicPredicates, predicates...)
        }</span>
}

// CrdExists is a DynamicPredicate that checks if a given CRD identified by its GVK exists.
// This is useful for conditionally watching resources that depend on CRDs being installed.
// Example usage:
//
//        builder.Watches(object, Dynamic(CrdExists(schema.GroupVersionKind{Group: "example.com", Version: "v1", Kind: "MyCRD"})))
func CrdExists(crdGvk schema.GroupVersionKind) DynamicPredicate <span class="cov0" title="0">{
        return func(ctx context.Context, request *types.ReconciliationRequest) bool </span><span class="cov0" title="0">{
                if hasCrd, err := cluster.HasCRD(ctx, request.Client, crdGvk); err != nil </span><span class="cov0" title="0">{
                        return false
                }</span> else<span class="cov0" title="0"> {
                        return hasCrd
                }</span>
        }
}

// ReconcilerBuilder provides a fluent API for building reconcilers with watches,
// predicates, actions, and finalizers. It supports both static and dynamic predicates
// for flexible watch configuration.
type ReconcilerBuilder[T common.PlatformObject] struct {
        mgr                 ctrl.Manager
        input               forInput
        watches             []watchInput
        predicates          []predicate.Predicate
        instanceName        string
        actions             []actions.Fn
        finalizers          []actions.Fn
        errors              error
        happyCondition      string
        dependantConditions []string
        // Cached clients to avoid recreation
        discoveryClient   discovery.DiscoveryInterface
        dynamicClient     dynamic.Interface
        dynamicPredicates []DynamicPredicate
        mu                sync.RWMutex
        // Control predicate behavior - when true, uses broader predicate including label/annotation changes
        useBroadPredicate bool
}

func ReconcilerFor[T common.PlatformObject](mgr ctrl.Manager, object T, opts ...builder.ForOption) *ReconcilerBuilder[T] <span class="cov8" title="1">{
        crb := ReconcilerBuilder[T]{
                mgr:                 mgr,
                happyCondition:      status.ConditionTypeReady,
                dependantConditions: []string{status.ConditionTypeProvisioningSucceeded},
        }

        gvk, err := mgr.GetClient().GroupVersionKindFor(object)
        if err != nil </span><span class="cov8" title="1">{
                crb.errors = multierror.Append(crb.errors, fmt.Errorf("unable to determine GVK: %w", err))
        }</span>

        <span class="cov8" title="1">iops := slices.Clone(opts)
        if len(iops) == 0 </span><span class="cov8" title="1">{
                iops = append(iops, builder.WithPredicates(
                        predicates.DefaultPredicate),
                )
        }</span>

        <span class="cov8" title="1">crb.input = forInput{
                object:  object,
                options: iops,
                gvk:     gvk,
        }

        return &amp;crb</span>
}

func (b *ReconcilerBuilder[T]) WithConditions(dependants ...string) *ReconcilerBuilder[T] <span class="cov0" title="0">{
        b.dependantConditions = append(b.dependantConditions, dependants...)
        return b
}</span>

func (b *ReconcilerBuilder[T]) WithInstanceName(instanceName string) *ReconcilerBuilder[T] <span class="cov0" title="0">{
        b.instanceName = instanceName
        return b
}</span>

// WithBroadPredicate enables the broader predicate behavior that includes
// label and annotation changes in addition to generation changes.
// By default, only generation changes trigger reconciliation to reduce
// reconciliation frequency. Use this method to opt into the broader behavior
// when label or annotation changes should trigger reconciliation.
func (b *ReconcilerBuilder[T]) WithBroadPredicate() *ReconcilerBuilder[T] <span class="cov8" title="1">{
        b.useBroadPredicate = true
        return b
}</span>

func (b *ReconcilerBuilder[T]) WithAction(value actions.Fn) *ReconcilerBuilder[T] <span class="cov0" title="0">{
        b.actions = append(b.actions, value)
        return b
}</span>

func (b *ReconcilerBuilder[T]) WithFinalizer(value actions.Fn) *ReconcilerBuilder[T] <span class="cov8" title="1">{
        b.finalizers = append(b.finalizers, value)
        return b
}</span>

func (b *ReconcilerBuilder[T]) Watches(object client.Object, opts ...WatchOpts) *ReconcilerBuilder[T] <span class="cov0" title="0">{
        in := watchInput{}
        in.object = object
        in.owned = false

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;in)
        }</span>

        <span class="cov0" title="0">if in.eventHandler == nil </span><span class="cov0" title="0">{
                // use the platform.opendatahub.io/instance.name label to find out
                // the owner
                in.eventHandler = handlers.AnnotationToName(annotations.InstanceName)
        }</span>

        <span class="cov0" title="0">if len(in.predicates) == 0 </span><span class="cov0" title="0">{
                in.predicates = append(in.predicates, predicate.And(
                        predicates.DefaultPredicate,
                        // use the platform.opendatahub.io/part-of label to filter
                        // events not related to the owner type
                        component.ForLabel(labels.PlatformPartOf, strings.ToLower(b.input.gvk.Kind)),
                ))
        }</span>

        <span class="cov0" title="0">b.watches = append(b.watches, in)

        return b</span>
}

func (b *ReconcilerBuilder[T]) WatchesGVK(gvk schema.GroupVersionKind, opts ...WatchOpts) *ReconcilerBuilder[T] <span class="cov0" title="0">{
        return b.Watches(resources.GvkToUnstructured(gvk), opts...)
}</span>

func (b *ReconcilerBuilder[T]) Owns(object client.Object, opts ...WatchOpts) *ReconcilerBuilder[T] <span class="cov0" title="0">{
        in := watchInput{}
        in.object = object
        in.owned = true

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;in)
        }</span>

        <span class="cov0" title="0">if in.eventHandler == nil </span><span class="cov0" title="0">{
                in.eventHandler = handler.EnqueueRequestForOwner(
                        b.mgr.GetScheme(),
                        b.mgr.GetRESTMapper(),
                        b.input.object,
                        handler.OnlyControllerOwner(),
                )
        }</span>

        <span class="cov0" title="0">if len(in.predicates) == 0 </span><span class="cov0" title="0">{
                in.predicates = append(in.predicates, predicates.DefaultPredicate)
        }</span>

        <span class="cov0" title="0">b.watches = append(b.watches, in)

        return b</span>
}

func (b *ReconcilerBuilder[T]) WithEventFilter(p predicate.Predicate) *ReconcilerBuilder[T] <span class="cov0" title="0">{
        b.predicates = append(b.predicates, p)
        return b
}</span>

// AddDynamicPredicate adds a dynamic predicate to the reconciler builder.
// Dynamic predicates are evaluated at runtime during reconciliation and can be used
// to conditionally enable or disable watches based on the current state.
// This method is thread-safe and can be called concurrently.
func (b *ReconcilerBuilder[T]) AddDynamicPredicate(predicate DynamicPredicate) *ReconcilerBuilder[T] <span class="cov0" title="0">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.dynamicPredicates = append(b.dynamicPredicates, predicate)
        return b
}</span>

// GetDynamicPredicates returns a copy of all registered dynamic predicates.
// This method is thread-safe and can be called concurrently.
func (b *ReconcilerBuilder[T]) GetDynamicPredicates() []DynamicPredicate <span class="cov0" title="0">{
        b.mu.RLock()
        defer b.mu.RUnlock()
        return slices.Clone(b.dynamicPredicates)
}</span>

// ClearDynamicPredicates removes all registered dynamic predicates.
// This method is thread-safe and can be called concurrently.
func (b *ReconcilerBuilder[T]) ClearDynamicPredicates() *ReconcilerBuilder[T] <span class="cov0" title="0">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.dynamicPredicates = nil
        return b
}</span>

func (b *ReconcilerBuilder[T]) OwnsGVK(gvk schema.GroupVersionKind, opts ...WatchOpts) *ReconcilerBuilder[T] <span class="cov0" title="0">{
        return b.Owns(resources.GvkToUnstructured(gvk), opts...)
}</span>

func (b *ReconcilerBuilder[T]) Build(_ context.Context) (*Reconciler, error) <span class="cov8" title="1">{
        if b.errors != nil </span><span class="cov0" title="0">{
                return nil, b.errors
        }</span>

        // Validate manager configuration and initialize cached clients early
        // This ensures clients are available for all subsequent operations
        // Note: This initialization is single-threaded and should be called before any consumers run
        <span class="cov8" title="1">if err := b.validateManager(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid manager configuration: %w", err)
        }</span>

        <span class="cov8" title="1">name := b.getInstanceName()
        obj, err := b.validateObject()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r, err := b.createReconciler(name, obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c, err := b.buildController(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := b.setupWatches(c, r); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">b.addEventFilters(c)
        b.addActionsAndFinalizers(r)

        _, err = c.Build(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">b.addDynamicWatchAction(r)

        return r, nil</span>
}

func (b *ReconcilerBuilder[T]) validateManager() error <span class="cov8" title="1">{
        // Return early if clients are already initialized
        if b.discoveryClient != nil &amp;&amp; b.dynamicClient != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get config once and reuse for both clients
        <span class="cov8" title="1">config := b.mgr.GetConfig()

        // Create discovery client first
        discoveryClient, err := discovery.NewDiscoveryClientForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create discovery client: %w", err)
        }</span>

        // Create dynamic client
        <span class="cov8" title="1">dynamicClient, err := dynamic.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create dynamic client: %w", err)
        }</span>

        // Only assign clients to builder if both creations succeed
        <span class="cov8" title="1">b.discoveryClient = discoveryClient
        b.dynamicClient = dynamicClient

        return nil</span>
}

func (b *ReconcilerBuilder[T]) getInstanceName() string <span class="cov8" title="1">{
        if b.instanceName != "" </span><span class="cov0" title="0">{
                return b.instanceName
        }</span>
        <span class="cov8" title="1">return strings.ToLower(b.input.gvk.Kind)</span>
}

func (b *ReconcilerBuilder[T]) validateObject() (T, error) <span class="cov8" title="1">{
        obj, ok := b.input.object.(T)
        if !ok </span><span class="cov0" title="0">{
                return obj, errors.New("invalid type for object")
        }</span>
        <span class="cov8" title="1">return obj, nil</span>
}

func (b *ReconcilerBuilder[T]) createReconciler(name string, obj T) (*Reconciler, error) <span class="cov8" title="1">{
        // Use cached clients that were initialized during validateManager
        r, err := newReconcilerWithClients(b.mgr, name, obj, b.discoveryClient, b.dynamicClient, WithConditionsManagerFactory(b.happyCondition, b.dependantConditions...))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create reconciler for component %s: %w", name, err)
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (b *ReconcilerBuilder[T]) buildController(name string) (*builder.Builder, error) <span class="cov8" title="1">{
        c := ctrl.NewControllerManagedBy(b.mgr).Named(name)

        forOpts := b.getForOptions()
        c = c.For(b.input.object, forOpts...)

        return c, nil
}</span>

// getForOptions provides default watch options when none are specified.
// By default, only GenerationChangedPredicate is used to reduce reconciliation frequency.
// Use WithBroadPredicate() to opt into broader behavior that includes label and annotation changes.
func (b *ReconcilerBuilder[T]) getForOptions() []builder.ForOption <span class="cov8" title="1">{
        forOpts := slices.Clone(b.input.options)
        if len(forOpts) == 0 </span><span class="cov0" title="0">{
                if b.useBroadPredicate </span><span class="cov0" title="0">{
                        // Opt-in broader predicate that includes label and annotation changes
                        forOpts = append(forOpts, builder.WithPredicates(predicate.Or(
                                predicate.GenerationChangedPredicate{},
                                predicate.LabelChangedPredicate{},
                                predicate.AnnotationChangedPredicate{},
                        )))
                }</span> else<span class="cov0" title="0"> {
                        // Default restrictive predicate - only generation changes
                        forOpts = append(forOpts, builder.WithPredicates(predicate.GenerationChangedPredicate{}))
                }</span>
        }
        <span class="cov8" title="1">return forOpts</span>
}

func (b *ReconcilerBuilder[T]) setupWatches(c *builder.Builder, r *Reconciler) error <span class="cov8" title="1">{
        for i := range b.watches </span><span class="cov0" title="0">{
                if err := b.processWatch(&amp;b.watches[i], c, r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (b *ReconcilerBuilder[T]) processWatch(watch *watchInput, c *builder.Builder, r *Reconciler) error <span class="cov0" title="0">{
        if watch.owned </span><span class="cov0" title="0">{
                if err := b.addOwnedTypes(watch, r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if watch.dynamic </span><span class="cov0" title="0">{
                // Extract identifying information for debug logging
                var watchName, resourceKind, namespace string

                // Get GVK information
                if kinds, _, err := b.mgr.GetScheme().ObjectKinds(watch.object); err == nil &amp;&amp; len(kinds) &gt; 0 </span><span class="cov0" title="0">{
                        resourceKind = kinds[0].String()
                }</span> else<span class="cov0" title="0"> {
                        resourceKind = "unknown"
                }</span>

                // Get namespace information
                <span class="cov0" title="0">if watch.object != nil </span><span class="cov0" title="0">{
                        namespace = watch.object.GetNamespace()
                        if namespace == "" </span><span class="cov0" title="0">{
                                namespace = "cluster-scoped"
                        }</span>
                } else<span class="cov0" title="0"> {
                        namespace = "unknown"
                }</span>

                // Generate a watch identifier
                <span class="cov0" title="0">if watch.object != nil </span><span class="cov0" title="0">{
                        watchName = fmt.Sprintf("%s/%s", resourceKind, watch.object.GetName())
                }</span> else<span class="cov0" title="0"> {
                        watchName = resourceKind
                }</span>

                <span class="cov0" title="0">r.Log.V(1).Info("Dynamic watch configured but being skipped",
                        "watchName", watchName,
                        "resourceKind", resourceKind,
                        "namespace", namespace,
                        "reason", "dynamic watches not yet implemented")

                return nil</span> // Skip dynamic watches for now
        }

        <span class="cov0" title="0">c.Watches(
                watch.object,
                watch.eventHandler,
                builder.WithPredicates(watch.predicates...),
        )
        return nil</span>
}

func (b *ReconcilerBuilder[T]) addOwnedTypes(watch *watchInput, r *Reconciler) error <span class="cov0" title="0">{
        kinds, _, err := b.mgr.GetScheme().ObjectKinds(watch.object)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, kind := range kinds </span><span class="cov0" title="0">{
                r.AddOwnedType(kind)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *ReconcilerBuilder[T]) addEventFilters(c *builder.Builder) <span class="cov8" title="1">{
        for _, p := range b.predicates </span><span class="cov0" title="0">{
                c.WithEventFilter(p)
        }</span>
}

func (b *ReconcilerBuilder[T]) addActionsAndFinalizers(r *Reconciler) <span class="cov8" title="1">{
        for _, action := range b.actions </span><span class="cov0" title="0">{
                r.AddAction(action)
        }</span>
        <span class="cov8" title="1">for _, finalizer := range b.finalizers </span><span class="cov8" title="1">{
                r.AddFinalizer(finalizer)
        }</span>
}

func (b *ReconcilerBuilder[T]) addDynamicWatchAction(r *Reconciler) <span class="cov8" title="1">{
        // Only add dynamic watch action if there are dynamic watches configured
        hasDynamicWatches := false
        for _, watch := range b.watches </span><span class="cov0" title="0">{
                if watch.dynamic </span><span class="cov0" title="0">{
                        hasDynamicWatches = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !hasDynamicWatches </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">r.AddAction(
                newDynamicWatchAction(
                        func(obj client.Object, eventHandler handler.EventHandler, predicates ...predicate.Predicate) error </span><span class="cov0" title="0">{
                                // For now, return an error indicating dynamic watches are not supported
                                // This can be implemented later when the correct controller interface is available
                                return errDynamicWatchesNotImplemented
                        }</span>,
                        b.watches,
                ),
        )
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package types

import (
        "crypto/sha256"
        "encoding/binary"
        "fmt"
        "io/fs"
        "path"

        "github.com/go-logr/logr"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/controller/conditions"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

// Controller defines the core interface for a controller in the OpenDataHub Operator.
type Controller interface {
        // Owns returns true if the controller manages resources of the specified GroupVersionKind.
        Owns(gvk schema.GroupVersionKind) bool

        // GetClient returns a controller-runtime client used to interact with the Kubernetes API.
        GetClient() client.Client

        // GetDiscoveryClient returns a client-go discovery client used to discover API resources on the cluster.
        GetDiscoveryClient() discovery.DiscoveryInterface

        // GetDynamicClient returns a client-go dynamic client for working with unstructured resources.
        GetDynamicClient() dynamic.Interface
}

type ResourceObject interface {
        client.Object
        common.WithStatus
}

type WithLogger interface {
        GetLogger() logr.Logger
}

type ManifestInfo struct {
        Path       string
        ContextDir string
        SourcePath string
}

func (mi ManifestInfo) String() string <span class="cov0" title="0">{
        result := mi.Path

        if mi.ContextDir != "" </span><span class="cov0" title="0">{
                result = path.Join(result, mi.ContextDir)
        }</span>

        <span class="cov0" title="0">if mi.SourcePath != "" </span><span class="cov0" title="0">{
                result = path.Join(result, mi.SourcePath)
        }</span>

        <span class="cov0" title="0">return result</span>
}

type TemplateInfo struct {
        FS   fs.FS
        Path string

        Labels      map[string]string
        Annotations map[string]string
}

type ReconciliationRequest struct {
        Client     client.Client
        Controller Controller
        Conditions *conditions.Manager
        Instance   common.PlatformObject
        DSCI       *dsciv1.DSCInitialization
        Release    common.Release
        Manifests  []ManifestInfo

        //
        // TODO: unify templates and resources.
        //
        // Unfortunately, the kustomize APIs do not yet support a FileSystem that is
        // backed by golang's fs.Fs so it is not simple to have a single abstraction
        // for both the manifests types.
        //
        // it would be nice to have a structure like:
        //
        // struct {
        //   FS  fs.FS
        //   URI net.URL
        // }
        //
        // where the URI could be something like:
        // - kustomize:///path/to/overlay
        // - template:///path/to/resource.tmpl.yaml
        //
        // and use the scheme as discriminator for the rendering engine
        //
        Templates []TemplateInfo
        Resources []unstructured.Unstructured

        // TODO: this has been added to reduce GC work and only run when
        //       resources have been generated. It should be removed and
        //       replaced with a better way of describing resources and
        //       their origin
        Generated bool
}

// AddResources adds one or more resources to the ReconciliationRequest's Resources slice.
// Each provided client.Object is normalized by ensuring it has the appropriate GVK and is
// converted into an unstructured.Unstructured format before being appended to the list.
func (rr *ReconciliationRequest) AddResources(values ...client.Object) error <span class="cov8" title="1">{
        for i := range values </span><span class="cov8" title="1">{
                if values[i] == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">err := resources.EnsureGroupVersionKind(rr.Client.Scheme(), values[i])
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("cannot normalize object: %w", err)
                }</span>

                <span class="cov8" title="1">u, err := resources.ToUnstructured(values[i])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot convert object to Unstructured: %w", err)
                }</span>

                <span class="cov8" title="1">rr.Resources = append(rr.Resources, *u)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ForEachResource iterates over each resource in the ReconciliationRequest's Resources slice,
// invoking the provided function `fn` for each resource. The function `fn` takes a pointer to
// an unstructured.Unstructured object and returns a boolean and an error.
//
// The iteration stops early if:
//   - `fn` returns an error.
//   - `fn` returns `true` as the first return value (`stop`).
func (rr *ReconciliationRequest) ForEachResource(fn func(*unstructured.Unstructured) (bool, error)) error <span class="cov8" title="1">{
        for i := range rr.Resources </span><span class="cov8" title="1">{
                stop, err := fn(&amp;rr.Resources[i])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot process resource %s: %w", rr.Resources[i].GroupVersionKind(), err)
                }</span>
                <span class="cov8" title="1">if stop </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// RemoveResources removes resources from the ReconciliationRequest's Resources slice
// based on a provided predicate function. The predicate determines whether a resource
// should be removed.
//
// Parameters:
//   - predicate: A function that takes a pointer to an unstructured.Unstructured object
//     and returns a boolean indicating whether the resource should be removed.
func (rr *ReconciliationRequest) RemoveResources(predicate func(*unstructured.Unstructured) bool) error <span class="cov8" title="1">{
        // Use in-place filtering to avoid allocations
        writeIndex := 0
        for readIndex := range rr.Resources </span><span class="cov8" title="1">{
                if !predicate(&amp;rr.Resources[readIndex]) </span><span class="cov8" title="1">{
                        if writeIndex != readIndex </span><span class="cov8" title="1">{
                                rr.Resources[writeIndex] = rr.Resources[readIndex]
                        }</span>
                        <span class="cov8" title="1">writeIndex++</span>
                }
        }

        // Clear references to help GC
        <span class="cov8" title="1">for i := writeIndex; i &lt; len(rr.Resources); i++ </span><span class="cov8" title="1">{
                rr.Resources[i] = unstructured.Unstructured{}
        }</span>

        <span class="cov8" title="1">rr.Resources = rr.Resources[:writeIndex]
        return nil</span>
}

func Hash(rr *ReconciliationRequest) ([]byte, error) <span class="cov0" title="0">{
        hash := sha256.New()

        dsciGeneration := make([]byte, binary.MaxVarintLen64)
        binary.PutVarint(dsciGeneration, rr.DSCI.GetGeneration())

        instanceGeneration := make([]byte, binary.MaxVarintLen64)
        binary.PutVarint(instanceGeneration, rr.Instance.GetGeneration())

        if _, err := hash.Write([]byte(rr.Instance.GetUID())); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash instance: %w", err)
        }</span>
        <span class="cov0" title="0">if _, err := hash.Write(dsciGeneration); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash dsci generation: %w", err)
        }</span>
        <span class="cov0" title="0">if _, err := hash.Write(instanceGeneration); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash instance generation: %w", err)
        }</span>
        <span class="cov0" title="0">if _, err := hash.Write([]byte(rr.Release.Name)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash release: %w", err)
        }</span>
        <span class="cov0" title="0">if _, err := hash.Write([]byte(rr.Release.Version.String())); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash release: %w", err)
        }</span>

        <span class="cov0" title="0">for i := range rr.Manifests </span><span class="cov0" title="0">{
                if _, err := hash.Write([]byte(rr.Manifests[i].String())); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to hash manifest: %w", err)
                }</span>
        }
        <span class="cov0" title="0">for i := range rr.Templates </span><span class="cov0" title="0">{
                if _, err := hash.Write([]byte(rr.Templates[i].Path)); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to hash template: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return hash.Sum(nil), nil</span>
}

func HashStr(rr *ReconciliationRequest) (string, error) <span class="cov0" title="0">{
        h, err := Hash(rr)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return resources.EncodeToString(h), nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package feature

import (
        "context"
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/log"

        featurev1 "github.com/opendatahub-io/opendatahub-operator/v2/api/features/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/resource"
)

type partialBuilder func(f *Feature) error

type featureBuilder struct {
        featureName string
        managed     bool
        source      featurev1.Source
        owner       metav1.Object
        controller  bool
        targetNs    string

        builders []partialBuilder
}

// Define creates a new feature builder with the given name.
func Define(featureName string) *featureBuilder <span class="cov0" title="0">{
        fb := &amp;featureBuilder{
                featureName: featureName,
                source: featurev1.Source{
                        Type: featurev1.UnknownType,
                        Name: featureName,
                },
        }

        initializeContext := func(f *Feature) error </span><span class="cov0" title="0">{
                if len(fb.targetNs) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("target namespace for '%s' feature is not defined", fb.featureName)
                }</span>

                <span class="cov0" title="0">f.TargetNamespace = fb.targetNs
                if setTargetNSErr := f.Set("TargetNamespace", fb.targetNs); setTargetNSErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set target namespace for '%s' feature: %w", fb.featureName, setTargetNSErr)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        // Ensures creation of shared data is always invoked first
        <span class="cov0" title="0">fb.builders = append([]partialBuilder{initializeContext}, fb.builders...)

        return fb</span>
}

func (fb *featureBuilder) Source(source featurev1.Source) *featureBuilder <span class="cov0" title="0">{
        fb.source = source

        return fb
}</span>

// TargetNamespace sets the namespace in which the feature should be applied.
// Calling it multiple times in the builder chain will have no effect, as the first value is used.
func (fb *featureBuilder) TargetNamespace(targetNs string) *featureBuilder <span class="cov0" title="0">{
        if fb.targetNs == "" </span><span class="cov0" title="0">{
                fb.targetNs = targetNs
        }</span>

        <span class="cov0" title="0">return fb</span>
}

// Manifests allow to compose manifests using different implementation of builders such as those defined in manifest and kustomize packages.
func (fb *featureBuilder) Manifests(creators ...resource.Creator) *featureBuilder <span class="cov0" title="0">{
        for _, creator := range creators </span><span class="cov0" title="0">{
                fb.builders = append(fb.builders, func(f *Feature) error </span><span class="cov0" title="0">{
                        appliers, errCreate := creator.Create()
                        if errCreate != nil </span><span class="cov0" title="0">{
                                return errCreate
                        }</span>

                        <span class="cov0" title="0">f.appliers = append(f.appliers, appliers...)

                        return nil</span>
                })
        }

        <span class="cov0" title="0">return fb</span>
}

// OwnedBy is optionally used to pass down the owning object in order to set the ownerReference
// in the corresponding feature tracker.
func (fb *featureBuilder) OwnedBy(object metav1.Object) *featureBuilder <span class="cov0" title="0">{
        fb.owner = object

        return fb
}</span>

func (fb *featureBuilder) Controller(controller bool) *featureBuilder <span class="cov0" title="0">{
        fb.controller = controller

        return fb
}</span>

// Managed marks the feature as managed by the operator.  This effectively marks all resources which are part of this feature
// as those that should be updated on operator reconcile.
// Managed marks the feature as managed by the operator.
//
// This effectively makes all resources which are part of this feature as reconciled to the desired state
// defined by provided manifests.
//
// NOTE: Although the actual instance of the resource in the cluster might have this configuration altered,
// we intentionally do not read the management configuration from there due to the lack of clear requirements.
// This means that management state is defined by the Feature resources provided by the operator
// and not by the actual state of the resource.
func (fb *featureBuilder) Managed() *featureBuilder <span class="cov0" title="0">{
        fb.managed = true

        return fb
}</span>

// WithData adds data providers to the feature (implemented as Actions).
// This way you can define what data should be loaded before the feature is applied.
// This can be later used in templates and when creating resources programmatically.
func (fb *featureBuilder) WithData(dataProviders ...Action) *featureBuilder <span class="cov0" title="0">{
        fb.builders = append(fb.builders, func(f *Feature) error </span><span class="cov0" title="0">{
                f.dataProviders = append(f.dataProviders, dataProviders...)

                return nil
        }</span>)

        <span class="cov0" title="0">return fb</span>
}

// EnabledWhen determines if a Feature should be loaded and applied based on specified criteria.
// The criteria are supplied as a function.
//
// Note: The function passed should consistently return true while the feature is needed.
// If the function returns false at any point, the feature's contents might be removed during the reconciliation process.
func (fb *featureBuilder) EnabledWhen(enabled EnabledFunc) *featureBuilder <span class="cov0" title="0">{
        fb.builders = append(fb.builders, func(f *Feature) error </span><span class="cov0" title="0">{
                f.Enabled = enabled

                return nil
        }</span>)
        <span class="cov0" title="0">return fb</span>
}

// WithResources allows to define programmatically which resources should be created when applying defined Feature.
func (fb *featureBuilder) WithResources(resources ...Action) *featureBuilder <span class="cov0" title="0">{
        fb.builders = append(fb.builders, func(f *Feature) error </span><span class="cov0" title="0">{
                f.clusterOperations = resources

                return nil
        }</span>)

        <span class="cov0" title="0">return fb</span>
}

// PreConditions adds preconditions to the feature. Preconditions are actions that are executed before the feature is applied.
// They can be used to check if the feature can be applied by inspecting the cluster state or by executing some arbitrary checks.
// If any of the precondition fails, the feature will not be applied.
func (fb *featureBuilder) PreConditions(preconditions ...Action) *featureBuilder <span class="cov0" title="0">{
        fb.builders = append(fb.builders, func(f *Feature) error </span><span class="cov0" title="0">{
                f.preconditions = append(f.preconditions, preconditions...)

                return nil
        }</span>)

        <span class="cov0" title="0">return fb</span>
}

// PostConditions adds postconditions to the feature. Postconditions are actions that are executed after the feature is applied.
func (fb *featureBuilder) PostConditions(postconditions ...Action) *featureBuilder <span class="cov0" title="0">{
        fb.builders = append(fb.builders, func(f *Feature) error </span><span class="cov0" title="0">{
                f.postconditions = append(f.postconditions, postconditions...)

                return nil
        }</span>)

        <span class="cov0" title="0">return fb</span>
}

// OnDelete allow to add cleanup hooks that are executed when the feature is going to be deleted.
func (fb *featureBuilder) OnDelete(cleanups ...CleanupFunc) *featureBuilder <span class="cov0" title="0">{
        fb.builders = append(fb.builders, func(f *Feature) error </span><span class="cov0" title="0">{
                f.addCleanup(cleanups...)

                return nil
        }</span>)

        <span class="cov0" title="0">return fb</span>
}

// Create creates a new Feature instance and add it to corresponding FeaturesHandler.
// The actual feature creation in the cluster is not performed here.
func (fb *featureBuilder) Create() (*Feature, error) <span class="cov0" title="0">{
        alwaysEnabled := func(_ context.Context, _ client.Client, _ *Feature) (bool, error) </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov0" title="0">f := &amp;Feature{
                Name:       fb.featureName,
                Managed:    fb.managed,
                Enabled:    alwaysEnabled,
                Log:        log.Log.WithName("features").WithValues("feature", fb.featureName),
                source:     &amp;fb.source,
                owner:      fb.owner,
                controller: fb.controller,
        }

        for i := range fb.builders </span><span class="cov0" title="0">{
                if err := fb.builders[i](f); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return f, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package feature

import (
        "context"
        "fmt"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/wait"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
)

const (
        interval = 10 * time.Second
        duration = 5 * time.Minute
)

type MissingOperatorError struct {
        operatorName string
        err          error
}

func NewMissingOperatorError(operatorName string, err error) *MissingOperatorError <span class="cov0" title="0">{
        return &amp;MissingOperatorError{
                operatorName: operatorName,
                err:          err,
        }
}</span>

func (e *MissingOperatorError) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

func (e *MissingOperatorError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("missing operator %q", e.operatorName)
}</span>

func EnsureOperatorIsInstalled(operatorName string) Action <span class="cov0" title="0">{
        return func(ctx context.Context, cli client.Client, f *Feature) error </span><span class="cov0" title="0">{
                if found, err := cluster.SubscriptionExists(ctx, cli, operatorName); !found || err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "failed to find the pre-requisite operator subscription %q, please ensure operator is installed. %w",
                                operatorName,
                                NewMissingOperatorError(operatorName, err),
                        )
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func WaitForPodsToBeReady(namespace string) Action <span class="cov0" title="0">{
        return func(ctx context.Context, cli client.Client, f *Feature) error </span><span class="cov0" title="0">{
                f.Log.Info("waiting for pods to become ready", "namespace", namespace, "duration (s)", duration.Seconds())
                backoff := wait.Backoff{
                        Duration: interval,
                        Factor:   2.0,
                        Steps:    5,
                }
                // 5 minute timeout
                return wait.ExponentialBackoffWithContext(ctx, backoff, func(ctx context.Context) (bool, error) </span><span class="cov0" title="0">{
                        var podList corev1.PodList

                        err := cli.List(ctx, &amp;podList, client.InNamespace(namespace))
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>

                        <span class="cov0" title="0">podList.Items = filterEvictedPods(podList.Items)
                        readyPods := 0
                        totalPods := len(podList.Items)

                        if totalPods == 0 </span><span class="cov0" title="0">{ // We want to wait for "something", so make sure we have "something" before we claim success.
                                return false, nil
                        }</span>

                        <span class="cov0" title="0">for _, pod := range podList.Items </span><span class="cov0" title="0">{
                                podReady := true
                                // Consider a "PodSucceeded" as ready, since these will never will
                                // be in Ready condition (i.e. Jobs that already completed).
                                if pod.Status.Phase != corev1.PodSucceeded </span><span class="cov0" title="0">{
                                        for _, condition := range pod.Status.Conditions </span><span class="cov0" title="0">{
                                                if condition.Type == corev1.PodReady </span><span class="cov0" title="0">{
                                                        if condition.Status != corev1.ConditionTrue </span><span class="cov0" title="0">{
                                                                podReady = false

                                                                break</span>
                                                        }
                                                }
                                        }
                                }
                                <span class="cov0" title="0">if podReady </span><span class="cov0" title="0">{
                                        readyPods++
                                }</span>
                        }

                        <span class="cov0" title="0">done := readyPods == totalPods

                        if done </span><span class="cov0" title="0">{
                                f.Log.Info("done waiting for pods to become ready", "namespace", namespace)
                        }</span>

                        <span class="cov0" title="0">return done, nil</span>
                })
        }
}

func filterEvictedPods(pods []corev1.Pod) []corev1.Pod <span class="cov0" title="0">{
        var filteredPods []corev1.Pod

        for _, pod := range pods </span><span class="cov0" title="0">{
                if pod.Status.Phase != corev1.PodFailed || pod.Status.Reason != "Evicted" </span><span class="cov0" title="0">{
                        filteredPods = append(filteredPods, pod)
                }</span>
        }

        <span class="cov0" title="0">return filteredPods</span>
}

func WaitForResourceToBeCreated(namespace string, gvk schema.GroupVersionKind) Action <span class="cov0" title="0">{
        return func(ctx context.Context, cli client.Client, f *Feature) error </span><span class="cov0" title="0">{
                f.Log.Info("waiting for resource to be created", "namespace", namespace, "resource", gvk)
                backoff := wait.Backoff{
                        Duration: interval,
                        Factor:   2.0,
                        Steps:    5,
                }
                // 5 minute timeout
                return wait.ExponentialBackoffWithContext(ctx, backoff, func(ctx context.Context) (bool, error) </span><span class="cov0" title="0">{
                        list := &amp;unstructured.UnstructuredList{}
                        list.SetGroupVersionKind(gvk)

                        err := cli.List(ctx, list, client.InNamespace(namespace), client.Limit(1))
                        if err != nil </span><span class="cov0" title="0">{
                                f.Log.Error(err, "failed waiting for resource", "namespace", namespace, "resource", gvk)

                                return false, err
                        }</span>

                        <span class="cov0" title="0">if len(list.Items) &gt; 0 </span><span class="cov0" title="0">{
                                f.Log.Info("resource created", "namespace", namespace, "resource", gvk)

                                return true, nil
                        }</span>

                        <span class="cov0" title="0">return false, nil</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package feature

import (
        "context"
        "fmt"

        "github.com/go-logr/logr"
        "github.com/hashicorp/go-multierror"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/utils/ptr"
        "sigs.k8s.io/controller-runtime/pkg/client"

        featurev1 "github.com/opendatahub-io/opendatahub-operator/v2/api/features/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/resource"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/annotations"
)

// Feature is a high-level abstraction that represents a collection of resources and actions
// that are applied to the cluster to enable a specific feature.
//
// Features can be either managed or unmanaged. Managed features are reconciled to their
// desired state based on defined manifests.
//
// In addition to creating resources using manifest files or through Golang functions, a Feature
// allows defining preconditions and postconditions. These conditions are checked to ensure
// the cluster is in the desired state for the feature to be applied successfully.
//
// When a Feature is applied, an associated resource called FeatureTracker is created. This
// resource establishes ownership for related resources, allowing for easy cleanup of all resources
// associated with the feature when it is about to be removed during reconciliation.
//
// Each Feature can have a list of cleanup functions. These functions can be particularly useful
// when the cleanup involves actions other than the removal of resources, such as reverting a patch operation.
//
// To create a Feature, use the provided FeatureBuilder. This builder guides through the process
// using a fluent API.
type Feature struct {
        Name            string
        TargetNamespace string
        Enabled         EnabledFunc
        Managed         bool

        Log logr.Logger

        tracker    *featurev1.FeatureTracker
        source     *featurev1.Source
        owner      metav1.Object
        controller bool

        data map[string]any

        appliers []resource.Applier

        cleanups          []CleanupFunc
        clusterOperations []Action
        preconditions     []Action
        postconditions    []Action
        dataProviders     []Action
}

// Action is a func type which can be used for different purposes during Feature's lifecycle
// while having access to Feature struct.
type Action func(ctx context.Context, cli client.Client, f *Feature) error

// CleanupFunc defines how to clean up resources associated with a feature.
// By default, all resources created by the feature are deleted when the feature is,
// so there is no need to explicitly add cleanup hooks for them.
// This is useful when you need to perform some additional cleanup actions such as removing effects of a patch operation.
type CleanupFunc func(ctx context.Context, cli client.Client) error

// EnabledFunc is a func type used to determine if a feature should be enabled.
type EnabledFunc func(ctx context.Context, cli client.Client, feature *Feature) (bool, error)

// Apply applies the feature to the cluster.
// It creates a FeatureTracker resource to establish ownership and reports the result of the operation as a condition.
func (f *Feature) Apply(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        // If the feature is disabled, but the FeatureTracker exists in the cluster, ensure clean-up is triggered.
        // This means that the feature was previously enabled, but now it is not anymore.
        if enabled, err := f.Enabled(ctx, cli, f); !enabled || err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return f.Cleanup(ctx, cli)</span>
        }

        <span class="cov0" title="0">if trackerErr := createFeatureTracker(ctx, cli, f); trackerErr != nil </span><span class="cov0" title="0">{
                return trackerErr
        }</span>

        <span class="cov0" title="0">if _, updateErr := status.UpdateWithRetry(ctx, cli, f.tracker, func(saved *featurev1.FeatureTracker) </span><span class="cov0" title="0">{
                status.SetProgressingCondition(&amp;saved.Status.Conditions, string(featurev1.ConditionReason.FeatureCreated), fmt.Sprintf("Applying feature [%s]", f.Name))
                saved.Status.Phase = status.PhaseProgressing
        }</span>); updateErr != nil <span class="cov0" title="0">{
                return updateErr
        }</span>

        <span class="cov0" title="0">applyErr := f.applyFeature(ctx, cli)
        _, reportErr := createFeatureTrackerStatusReporter(cli, f).ReportCondition(ctx, applyErr)

        return multierror.Append(applyErr, reportErr).ErrorOrNil()</span>
}

func (f *Feature) applyFeature(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        var multiErr *multierror.Error

        for _, dataProvider := range f.dataProviders </span><span class="cov0" title="0">{
                multiErr = multierror.Append(multiErr, dataProvider(ctx, cli, f))
        }</span>
        <span class="cov0" title="0">if errDataLoad := multiErr.ErrorOrNil(); errDataLoad != nil </span><span class="cov0" title="0">{
                return &amp;withConditionReasonError{reason: featurev1.ConditionReason.LoadTemplateData, err: errDataLoad}
        }</span>

        <span class="cov0" title="0">for _, precondition := range f.preconditions </span><span class="cov0" title="0">{
                multiErr = multierror.Append(multiErr, precondition(ctx, cli, f))
        }</span>
        <span class="cov0" title="0">if preconditionsErr := multiErr.ErrorOrNil(); preconditionsErr != nil </span><span class="cov0" title="0">{
                return &amp;withConditionReasonError{reason: featurev1.ConditionReason.PreConditions, err: preconditionsErr}
        }</span>

        <span class="cov0" title="0">for _, clusterOperation := range f.clusterOperations </span><span class="cov0" title="0">{
                if errClusterOperation := clusterOperation(ctx, cli, f); errClusterOperation != nil </span><span class="cov0" title="0">{
                        return &amp;withConditionReasonError{reason: featurev1.ConditionReason.ResourceCreation, err: errClusterOperation}
                }</span>
        }

        <span class="cov0" title="0">for i := range f.appliers </span><span class="cov0" title="0">{
                r := f.appliers[i]
                if processErr := r.Apply(ctx, cli, f.data, DefaultMetaOptions(f)...); processErr != nil </span><span class="cov0" title="0">{
                        return &amp;withConditionReasonError{reason: featurev1.ConditionReason.ApplyManifests, err: processErr}
                }</span>
        }

        <span class="cov0" title="0">for _, postcondition := range f.postconditions </span><span class="cov0" title="0">{
                multiErr = multierror.Append(multiErr, postcondition(ctx, cli, f))
        }</span>
        <span class="cov0" title="0">if postConditionErr := multiErr.ErrorOrNil(); postConditionErr != nil </span><span class="cov0" title="0">{
                return &amp;withConditionReasonError{reason: featurev1.ConditionReason.PostConditions, err: postConditionErr}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (f *Feature) Cleanup(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        // Ensure associated FeatureTracker instance has been removed as last one
        // in the chain of cleanups.
        f.addCleanup(removeFeatureTracker(f))

        var cleanupErrors *multierror.Error
        for _, cleanupFunc := range f.cleanups </span><span class="cov0" title="0">{
                cleanupErrors = multierror.Append(cleanupErrors, cleanupFunc(ctx, cli))
        }</span>

        <span class="cov0" title="0">return cleanupErrors.ErrorOrNil()</span>
}

func (f *Feature) addCleanup(cleanupFuncs ...CleanupFunc) <span class="cov0" title="0">{
        f.cleanups = append(f.cleanups, cleanupFuncs...)
}</span>

// AsOwnerReference returns an OwnerReference for the FeatureTracker resource.
func (f *Feature) AsOwnerReference() metav1.OwnerReference <span class="cov0" title="0">{
        return f.tracker.ToOwnerReference()
}</span>

// OwnedBy returns a cluster.MetaOptions that sets the owner reference to the FeatureTracker resource.
func OwnedBy(f *Feature) cluster.MetaOptions <span class="cov0" title="0">{
        return cluster.WithOwnerReference(f.AsOwnerReference())
}</span>

func ControlledBy(f *Feature) cluster.MetaOptions <span class="cov0" title="0">{
        or := f.AsOwnerReference()
        or.Controller = ptr.To[bool](true)
        or.BlockOwnerDeletion = ptr.To[bool](true)
        return cluster.WithOwnerReference(or)
}</span>

func DefaultMetaOptions(f *Feature) []cluster.MetaOptions <span class="cov0" title="0">{
        resourceMeta := make([]cluster.MetaOptions, 0, 1)

        if f.controller </span><span class="cov0" title="0">{
                resourceMeta = append(resourceMeta, ControlledBy(f))
        }</span> else<span class="cov0" title="0"> {
                resourceMeta = append(resourceMeta, OwnedBy(f))
        }</span>

        <span class="cov0" title="0">if f.Managed </span><span class="cov0" title="0">{
                resourceMeta = append(resourceMeta, func(obj metav1.Object) error </span><span class="cov0" title="0">{
                        objAnnotations := obj.GetAnnotations()
                        if objAnnotations == nil </span><span class="cov0" title="0">{
                                objAnnotations = make(map[string]string)
                        }</span>

                        // If resource already has an annotation, it takes precedence
                        <span class="cov0" title="0">if _, exists := objAnnotations[annotations.ManagedByODHOperator]; !exists </span><span class="cov0" title="0">{
                                objAnnotations[annotations.ManagedByODHOperator] = "true"
                                obj.SetAnnotations(objAnnotations)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                })
        }
        <span class="cov0" title="0">return resourceMeta</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package feature

import (
        "context"
        "fmt"

        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/provider"
)

// Entry allows to define association between a name under which the data is stored in the Feature and a data provider
// defining the logic for fetching. Provider is a function allowing to fetch a value for a given key dynamically by
// interacting with Kubernetes client.
//
// If the value is static, consider using provider.ValueOf(variable).Get as passed provider function.
func Entry[T any](key string, providerFunc provider.DataProviderFunc[T]) Action <span class="cov0" title="0">{
        return func(ctx context.Context, cli client.Client, f *Feature) error </span><span class="cov0" title="0">{
                data, err := providerFunc(ctx, cli)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return f.Set(key, data)</span>
        }
}

// DataEntry associates data provider with a key under which the data is stored in the Feature.
type DataEntry[T any] struct {
        Key   string
        Value provider.DataProviderFunc[T]
}

// DataDefinition defines how the data is created and fetched from the Feature's data context.
// S is a source type from which the data is created.
// T is a type of the data stored in the Feature.
type DataDefinition[S, T any] struct {
        // Define is a factory function to create a Feature's DataEntry from the given source.
        Define func(source *S) DataEntry[T]
        // Extract allows to fetch data from the Feature.
        Extract func(f *Feature) (T, error)
}

// ExtractEntry is a convenient way to define how to extract a value from the given Feature's data using defined key.
func ExtractEntry[T any](key string) func(f *Feature) (T, error) <span class="cov0" title="0">{
        return func(f *Feature) (T, error) </span><span class="cov0" title="0">{
                return Get[T](f, key)
        }</span>
}

// AsAction converts DataEntry to an Action which is the used to populate defined key-value in the feature itself.
func (d DataEntry[T]) AsAction() Action <span class="cov0" title="0">{
        return Entry[T](d.Key, d.Value)
}</span>

// Get allows to retrieve arbitrary value from the Feature's data container.
func Get[T any](f *Feature, key string) (T, error) <span class="cov0" title="0">{
        var data T
        var ok bool

        input, found := f.data[key]
        if !found </span><span class="cov0" title="0">{
                return data, fmt.Errorf("key %s not found in feature %s", key, f.Name)
        }</span>

        <span class="cov0" title="0">data, ok = input.(T)
        if !ok </span><span class="cov0" title="0">{
                return data, fmt.Errorf("invalid type %T for key %s in feature %s", f.data[key], key, f.Name)
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// Set allows to store a value under given key in the Feature's data container.
func (f *Feature) Set(key string, data any) error <span class="cov0" title="0">{
        if f.data == nil </span><span class="cov0" title="0">{
                f.data = map[string]any{}
        }</span>

        <span class="cov0" title="0">f.data[key] = data

        return nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package feature

import (
        "context"
        "errors"
        "fmt"

        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"

        featurev1 "github.com/opendatahub-io/opendatahub-operator/v2/api/features/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
)

// withConditionReasonError is a wrapper around an error which provides a reason for a feature condition.
type withConditionReasonError struct {
        reason featurev1.FeatureConditionReason
        err    error
}

func (e *withConditionReasonError) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

func (e *withConditionReasonError) Error() string <span class="cov0" title="0">{
        return e.err.Error()
}</span>

// createFeatureTracker creates a FeatureTracker, persists it in the cluster,
// and attaches it to the provided Feature instance.
func createFeatureTracker(ctx context.Context, cli client.Client, f *Feature) error <span class="cov0" title="0">{
        tracker, errGet := getFeatureTracker(ctx, cli, f.Name, f.TargetNamespace)
        if client.IgnoreNotFound(errGet) != nil </span><span class="cov0" title="0">{
                return errGet
        }</span>

        <span class="cov0" title="0">if k8serr.IsNotFound(errGet) </span><span class="cov0" title="0">{
                tracker = featurev1.NewFeatureTracker(f.Name, f.TargetNamespace)
        }</span>

        <span class="cov0" title="0">tracker.Spec = featurev1.FeatureTrackerSpec{
                Source:       *f.source,
                AppNamespace: f.TargetNamespace,
        }

        if f.owner != nil </span><span class="cov0" title="0">{
                var ownerRef cluster.MetaOptions
                if f.controller </span><span class="cov0" title="0">{
                        ownerRef = cluster.ControlledBy(f.owner, cli.Scheme())
                }</span> else<span class="cov0" title="0"> {
                        ownerRef = cluster.OwnedBy(f.owner, cli.Scheme())
                }</span>

                <span class="cov0" title="0">if errMetaOpts := cluster.ApplyMetaOptions(tracker, ownerRef); errMetaOpts != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed adding owner to FeatureTracker %s: %w", tracker.Name, errMetaOpts)
                }</span>
        }

        <span class="cov0" title="0">if k8serr.IsNotFound(errGet) </span><span class="cov0" title="0">{
                if errCreate := cli.Create(ctx, tracker); errCreate != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed creating FeatureTracker %s: %w", tracker.Name, errCreate)
                }</span>
        } else<span class="cov0" title="0"> {
                if errUpdate := cli.Update(ctx, tracker); errUpdate != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed updating FeatureTracker %s: %w", tracker.Name, errUpdate)
                }</span>
        }

        <span class="cov0" title="0">if errGVK := ensureGVKSet(tracker, cli.Scheme()); errGVK != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed ensuring GVK is set for %s: %w", tracker.Name, errGVK)
        }</span>

        <span class="cov0" title="0">f.tracker = tracker

        return nil</span>
}

// removeFeatureTracker removes the FeatureTracker associated with the provided Feature instance if one exists in the cluster.
func removeFeatureTracker(f *Feature) CleanupFunc <span class="cov0" title="0">{
        return func(ctx context.Context, cli client.Client) error </span><span class="cov0" title="0">{
                associatedTracker := f.tracker
                if associatedTracker == nil </span><span class="cov0" title="0">{
                        // Check if it is persisted in the cluster, but Feature do not have it attached
                        if tracker, errGet := getFeatureTracker(ctx, cli, f.Name, f.TargetNamespace); client.IgnoreNotFound(errGet) != nil </span><span class="cov0" title="0">{
                                return errGet
                        }</span> else<span class="cov0" title="0"> {
                                associatedTracker = tracker
                        }</span>
                }

                <span class="cov0" title="0">if associatedTracker != nil </span><span class="cov0" title="0">{
                        return client.IgnoreNotFound(cli.Delete(ctx, associatedTracker))
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

func getFeatureTracker(ctx context.Context, cli client.Client, featureName, namespace string) (*featurev1.FeatureTracker, error) <span class="cov0" title="0">{
        tracker := featurev1.NewFeatureTracker(featureName, namespace)

        if errGet := cli.Get(ctx, client.ObjectKeyFromObject(tracker), tracker); errGet != nil </span><span class="cov0" title="0">{
                return nil, errGet
        }</span>

        <span class="cov0" title="0">return tracker, nil</span>
}

func ensureGVKSet(obj runtime.Object, scheme *runtime.Scheme) error <span class="cov0" title="0">{
        // See https://github.com/kubernetes/client-go/issues/308
        gvks, unversioned, err := scheme.ObjectKinds(obj)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get group, version, &amp; kinds for object: %w", err)
        }</span>
        <span class="cov0" title="0">if unversioned </span><span class="cov0" title="0">{
                return errors.New("object is unversioned")
        }</span>
        // Update the target object back with one of the discovered GVKs.
        <span class="cov0" title="0">obj.GetObjectKind().SetGroupVersionKind(gvks[0])

        return nil</span>
}

func createFeatureTrackerStatusReporter(cli client.Client, f *Feature) *status.Reporter[*featurev1.FeatureTracker] <span class="cov0" title="0">{
        return status.NewStatusReporter(cli, f.tracker, func(err error) status.SaveStatusFunc[*featurev1.FeatureTracker] </span><span class="cov0" title="0">{
                updatedCondition := func(saved *featurev1.FeatureTracker) </span><span class="cov0" title="0">{
                        status.SetCompleteCondition(&amp;saved.Status.Conditions, string(featurev1.ConditionReason.FeatureCreated), fmt.Sprintf("Applied feature [%s] successfully", f.Name))
                        saved.Status.Phase = status.PhaseReady
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        reason := featurev1.ConditionReason.FailedApplying // generic reason when error is not related to any specific step of the feature apply
                        var conditionErr *withConditionReasonError
                        if errors.As(err, &amp;conditionErr) </span><span class="cov0" title="0">{
                                reason = conditionErr.reason
                        }</span>
                        <span class="cov0" title="0">updatedCondition = func(saved *featurev1.FeatureTracker) </span><span class="cov0" title="0">{
                                status.SetErrorCondition(&amp;saved.Status.Conditions, string(reason), fmt.Sprintf("Failed applying [%s]: %+v", f.Name, err))
                                saved.Status.Phase = status.PhaseError
                        }</span>
                }

                <span class="cov0" title="0">return updatedCondition</span>
        })
}
</pre>
		
		<pre class="file" id="file119" style="display: none">//nolint:structcheck // Reason: false positive, complains about unused fields in HandlerWithReporter
package feature

import (
        "context"
        "fmt"

        "github.com/hashicorp/go-multierror"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"

        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        featurev1 "github.com/opendatahub-io/opendatahub-operator/v2/api/features/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/internal/controller/status"
)

type featuresHandler interface {
        Apply(ctx context.Context, cli client.Client) error
        Delete(ctx context.Context, cli client.Client) error
}

type FeaturesRegistry interface {
        Add(builders ...*featureBuilder) error
}

var _ featuresHandler = (*FeaturesHandler)(nil)

// FeaturesHandler provides a structured way to manage and coordinate the creation, application,
// and deletion of features needed in particular Data Science Cluster configuration.
type FeaturesHandler struct {
        source            featurev1.Source
        owner             metav1.Object
        controller        bool
        targetNamespace   string
        features          []*Feature
        featuresProviders []FeaturesProvider
}

var _ FeaturesRegistry = (*FeaturesHandler)(nil)

// Add loads features defined by passed builders and adds to internal list which is then used to Apply on the cluster.
// It also makes sure that both TargetNamespace and Source are added to the feature before it's `Create()`ed.
func (fh *FeaturesHandler) Add(builders ...*featureBuilder) error <span class="cov0" title="0">{
        var multiErr *multierror.Error

        for i := range builders </span><span class="cov0" title="0">{
                fb := builders[i]
                feature, err := fb.
                        TargetNamespace(fh.targetNamespace).
                        OwnedBy(fh.owner).
                        Controller(fh.controller).
                        Source(fh.source).
                        Create()
                multiErr = multierror.Append(multiErr, err)
                fh.features = append(fh.features, feature)
        }</span>

        <span class="cov0" title="0">return multiErr.ErrorOrNil()</span>
}

func (fh *FeaturesHandler) Apply(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        fh.features = make([]*Feature, 0)

        for _, featuresProvider := range fh.featuresProviders </span><span class="cov0" title="0">{
                if err := featuresProvider(fh); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed adding features to the handler. cause: %w", err)
                }</span>
        }

        <span class="cov0" title="0">var multiErr *multierror.Error
        for _, f := range fh.features </span><span class="cov0" title="0">{
                if applyErr := f.Apply(ctx, cli); applyErr != nil </span><span class="cov0" title="0">{
                        multiErr = multierror.Append(multiErr, fmt.Errorf("failed applying FeatureHandler features. cause: %w", applyErr))
                }</span>
        }

        <span class="cov0" title="0">return multiErr.ErrorOrNil()</span>
}

// Delete executes registered clean-up tasks for handled Features in the opposite order they were initiated.
// This approach assumes that Features are either instantiated in the correct sequence or are self-contained.
func (fh *FeaturesHandler) Delete(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        fh.features = make([]*Feature, 0)

        for _, featuresProvider := range fh.featuresProviders </span><span class="cov0" title="0">{
                if err := featuresProvider(fh); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete phase failed when wiring Feature instances in FeatureHandler.Delete. cause: %w", err)
                }</span>
        }

        <span class="cov0" title="0">var multiErr *multierror.Error
        for i := len(fh.features) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if cleanupErr := fh.features[i].Cleanup(ctx, cli); cleanupErr != nil </span><span class="cov0" title="0">{
                        multiErr = multierror.Append(multiErr, fmt.Errorf("failed executing cleanup in FeatureHandler. cause: %w", cleanupErr))
                }</span>
        }

        <span class="cov0" title="0">return multiErr.ErrorOrNil()</span>
}

// FeaturesProvider is a function which allow to define list of features
// and add them to the handler's registry.
type FeaturesProvider func(registry FeaturesRegistry) error

func ClusterFeaturesHandler(dsci *dsciv1.DSCInitialization, def ...FeaturesProvider) *FeaturesHandler <span class="cov0" title="0">{
        return &amp;FeaturesHandler{
                targetNamespace:   dsci.Spec.ApplicationsNamespace,
                owner:             dsci,
                source:            featurev1.Source{Type: featurev1.DSCIType, Name: dsci.Name},
                featuresProviders: def,
        }
}</span>

func ComponentFeaturesHandler(owner metav1.Object, componentName, targetNamespace string, def ...FeaturesProvider) *FeaturesHandler <span class="cov0" title="0">{
        return &amp;FeaturesHandler{
                owner:             owner,
                controller:        true,
                targetNamespace:   targetNamespace,
                source:            featurev1.Source{Type: featurev1.ComponentType, Name: componentName},
                featuresProviders: def,
        }
}</span>

// EmptyFeaturesHandler is noop handler so that we can avoid nil checks in the code and safely call Apply/Delete methods.
var EmptyFeaturesHandler = &amp;FeaturesHandler{
        features:          []*Feature{},
        featuresProviders: []FeaturesProvider{},
}

// HandlerWithReporter is a wrapper around FeaturesHandler and status.Reporter
// It is intended apply features related to a given resource capabilities and report its status using custom reporter.
type HandlerWithReporter[T client.Object] struct {
        handler  *FeaturesHandler
        reporter *status.Reporter[T]
}

var _ featuresHandler = (*HandlerWithReporter[client.Object])(nil)

func NewHandlerWithReporter[T client.Object](handler *FeaturesHandler, reporter *status.Reporter[T]) *HandlerWithReporter[T] <span class="cov0" title="0">{
        return &amp;HandlerWithReporter[T]{
                handler:  handler,
                reporter: reporter,
        }
}</span>

func (h HandlerWithReporter[T]) Apply(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        applyErr := h.handler.Apply(ctx, cli)
        _, reportErr := h.reporter.ReportCondition(ctx, applyErr)
        // We could have failed during Apply phase as well as during reporting.
        // We should return both errors to the caller.
        return multierror.Append(applyErr, reportErr).ErrorOrNil()
}</span>

func (h HandlerWithReporter[T]) Delete(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        deleteErr := h.handler.Delete(ctx, cli)
        _, reportErr := h.reporter.ReportCondition(ctx, deleteErr)
        // We could have failed during Delete phase as well as during reporting.
        // We should return both errors to the caller.
        return multierror.Append(deleteErr, reportErr).ErrorOrNil()
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">package manifest

import (
        "io/fs"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/resource"
)

type Builder struct {
        manifestLocation fs.FS
        paths            []string
}

// Location sets the root file system from which manifest paths are loaded.
func Location(fsys fs.FS) *Builder <span class="cov0" title="0">{
        return &amp;Builder{manifestLocation: fsys}
}</span>

// Include loads manifests from the provided paths.
func (b *Builder) Include(paths ...string) *Builder <span class="cov0" title="0">{
        b.paths = append(b.paths, paths...)
        return b
}</span>

func (b *Builder) Create() ([]resource.Applier, error) <span class="cov0" title="0">{
        var manifests []*Manifest
        for _, path := range b.paths </span><span class="cov0" title="0">{
                currManifests, err := LoadManifests(b.manifestLocation, path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err // TODO wrap
                }</span>

                <span class="cov0" title="0">manifests = append(manifests, currManifests...)</span>
        }

        <span class="cov0" title="0">resources := make([]resource.Applier, 0, len(manifests))
        for _, m := range manifests </span><span class="cov0" title="0">{
                resources = append(resources, createApplier(m))
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package manifest

import (
        "bytes"
        "context"
        "fmt"
        "html/template"
        "io"
        "io/fs"
        "path/filepath"
        "strings"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/conversion"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/feature/resource"
)

func Create(fsys fs.FS, path string) *Manifest <span class="cov8" title="1">{
        basePath := filepath.Base(path)
        return &amp;Manifest{
                name:  basePath,
                path:  path,
                patch: isPatch(basePath),
                fsys:  fsys,
        }
}</span>

func LoadManifests(fsys fs.FS, path string) ([]*Manifest, error) <span class="cov0" title="0">{
        var manifests []*Manifest

        err := fs.WalkDir(fsys, path, func(path string, dirEntry fs.DirEntry, errWalk error) error </span><span class="cov0" title="0">{
                if errWalk != nil </span><span class="cov0" title="0">{
                        return errWalk
                }</span>

                <span class="cov0" title="0">if _, err := dirEntry.Info(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if dirEntry.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">manifests = append(manifests, Create(fsys, path))

                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return manifests, nil</span>
}

type Manifest struct {
        name,
        path string
        patch bool
        fsys  fs.FS
}

// Applier wraps an instance of Manifest and provides a way to apply it to the cluster.
type Applier struct {
        manifest *Manifest
}

func createApplier(manifest *Manifest) *Applier <span class="cov0" title="0">{
        return &amp;Applier{
                manifest: manifest,
        }
}</span>

// Apply processes owned manifest and apply it to a cluster.
func (a Applier) Apply(ctx context.Context, cli client.Client, data map[string]any, options ...cluster.MetaOptions) error <span class="cov0" title="0">{
        objects, errProcess := a.manifest.Process(data)
        if errProcess != nil </span><span class="cov0" title="0">{
                return errProcess
        }</span>

        <span class="cov0" title="0">applierFunc := resource.Apply
        if a.manifest.patch </span><span class="cov0" title="0">{
                applierFunc = func(ctx context.Context, cli client.Client, objects []*unstructured.Unstructured, _ ...cluster.MetaOptions) error </span><span class="cov0" title="0">{
                        return resource.Patch(ctx, cli, objects)
                }</span>
        }

        <span class="cov0" title="0">return applierFunc(ctx, cli, objects, options...)</span>
}

// Process allows any arbitrary struct to be passed and used while processing the content of the manifest.
func (m *Manifest) Process(data any) ([]*unstructured.Unstructured, error) <span class="cov8" title="1">{
        manifestFile, err := m.fsys.Open(m.path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer manifestFile.Close()

        content, err := io.ReadAll(manifestFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file: %w", err)
        }</span>

        <span class="cov8" title="1">resources := string(content)

        if isTemplate(m.path) </span><span class="cov8" title="1">{
                tmpl, err := template.New(m.name).
                        Option("missingkey=error").
                        Parse(resources)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse template: %w", err)
                }</span>

                <span class="cov8" title="1">var buffer bytes.Buffer
                if err := tmpl.Execute(&amp;buffer, data); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to execute template: %w", err)
                }</span>

                <span class="cov8" title="1">resources = buffer.String()</span>
        }

        <span class="cov8" title="1">return conversion.StrToUnstructured(resources)</span>
}

func isPatch(path string) bool <span class="cov8" title="1">{
        return strings.Contains(filepath.Base(path), ".patch.")
}</span>

func isTemplate(path string) bool <span class="cov8" title="1">{
        return strings.Contains(filepath.Base(path), ".tmpl.")
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">package provider

import (
        "context"
        "reflect"

        "sigs.k8s.io/controller-runtime/pkg/client"
)

// DataProvider is a contract on how the data for the Feature container can be fetched.
// It is expected that either found instance is returned or error occurred during invocation.
type DataProvider[T any] interface {
        Get(ctx context.Context, c client.Client) (T, error)
}

// DataProviderFunc defines function signature which is used for fetching data.
// This allows to pass simple closures while construction data providers.
type DataProviderFunc[T any] func(ctx context.Context, c client.Client) (T, error)

// ValueOf is a constructor which allows to define a value with optional provider.
func ValueOf[T any](value T) DataProviderWithDefault[T] <span class="cov7" title="4">{
        return DataProviderWithDefault[T]{value: value}
}</span>

// Defaulter defines how a default value can be supplied when original one is zero-value.
type Defaulter[T any] interface {
        Value() T
        OrElse(other T) DataProviderFunc[T]
        OrGet(getFunc DataProviderFunc[T]) DataProviderFunc[T]
}

// DataProviderWithDefault allows to define a value and optional means of supplying it if original value is empty.
// When the original value is zero the alternative can be provided using:
// - `OrElse` to define a static value
// - `OrGet` to perform dynamic lookup by providing DataProviderFunc.
type DataProviderWithDefault[T any] struct {
        value T //nolint:structcheck //reason used in e.g. Get
}

var _ DataProvider[any] = (*DataProviderWithDefault[any])(nil)
var _ Defaulter[any] = (*DataProviderWithDefault[any])(nil)

// Get returns Value() of Defaulter and ensures DataProviderWithDefault can be used as DataProviderFunc.
func (d DataProviderWithDefault[T]) Get(_ context.Context, _ client.Client) (T, error) <span class="cov6" title="3">{
        return d.Value(), nil
}</span>

// Value returns actual value stored by the provider.
func (d DataProviderWithDefault[T]) Value() T <span class="cov10" title="6">{
        return d.value
}</span>

// OrElse allows to define static default value when the stored one is a zero-value.
func (d DataProviderWithDefault[T]) OrElse(other T) DataProviderFunc[T] <span class="cov6" title="3">{
        if reflect.ValueOf(d.Value()).IsZero() </span><span class="cov6" title="3">{
                d.value = other
        }</span>

        <span class="cov6" title="3">return d.Get</span>
}

// OrGet allows to define dynamic value provider when the stored one is a zero-value.
func (d DataProviderWithDefault[T]) OrGet(getFunc DataProviderFunc[T]) DataProviderFunc[T] <span class="cov4" title="2">{
        if reflect.ValueOf(d.Value()).IsZero() </span><span class="cov4" title="2">{
                return getFunc
        }</span>

        <span class="cov0" title="0">return d.Get</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package feature

import (
        "context"

        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
)

// CreateNamespaceIfNotExists will create a namespace with the given name if it does not exist yet.
// It does not set ownership nor apply extra metadata to the existing namespace.
func CreateNamespaceIfNotExists(namespace string) Action <span class="cov0" title="0">{
        return func(ctx context.Context, cli client.Client, _ *Feature) error </span><span class="cov0" title="0">{
                _, err := cluster.CreateNamespace(ctx, cli, namespace)

                return err
        }</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package kustomize

import (
        "sigs.k8s.io/kustomize/api/krusty"
        "sigs.k8s.io/kustomize/kyaml/filesys"
)

const (
        DefaultKustomizationFileName = "kustomization.yaml"
        DefaultKustomizationFilePath = "default"
)

func NewEngine(opts ...EngineOptsFn) *Engine <span class="cov8" title="1">{
        e := Engine{
                k:  krusty.MakeKustomizer(krusty.MakeDefaultOptions()),
                fs: filesys.MakeFsOnDisk(),
                renderOpts: renderOpts{
                        kustomizationFileName:    DefaultKustomizationFileName,
                        kustomizationFileOverlay: DefaultKustomizationFilePath,
                },
        }

        for _, fn := range opts </span><span class="cov8" title="1">{
                fn(&amp;e)
        }</span>

        <span class="cov8" title="1">return &amp;e</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package kustomize

import (
        "fmt"
        "maps"
        "path/filepath"
        "slices"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "sigs.k8s.io/kustomize/api/krusty"
        "sigs.k8s.io/kustomize/kyaml/filesys"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/plugins"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

type Engine struct {
        k          *krusty.Kustomizer
        fs         filesys.FileSystem
        renderOpts renderOpts
}

func (e *Engine) Render(path string, opts ...RenderOptsFn) ([]unstructured.Unstructured, error) <span class="cov8" title="1">{
        // poor man clone
        ro := e.renderOpts
        ro.labels = maps.Clone(e.renderOpts.labels)
        ro.annotations = maps.Clone(e.renderOpts.annotations)
        ro.plugins = slices.Clone(e.renderOpts.plugins)

        for _, fn := range opts </span><span class="cov8" title="1">{
                fn(&amp;ro)
        }</span>

        <span class="cov8" title="1">if !e.fs.Exists(filepath.Join(path, ro.kustomizationFileName)) </span><span class="cov0" title="0">{
                path = filepath.Join(path, ro.kustomizationFileOverlay)
        }</span>

        <span class="cov8" title="1">resMap, err := e.k.Run(e.fs, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if ro.ns != "" </span><span class="cov8" title="1">{
                plugin := plugins.CreateNamespaceApplierPlugin(ro.ns)
                if err := plugin.Transform(resMap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed applying namespace plugin when preparing Kustomize resources. %w", err)
                }</span>
        }

        <span class="cov8" title="1">if len(ro.labels) != 0 </span><span class="cov8" title="1">{
                plugin := plugins.CreateSetLabelsPlugin(ro.labels)
                if err := plugin.Transform(resMap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed applying labels plugin when preparing Kustomize resources. %w", err)
                }</span>
        }

        <span class="cov8" title="1">if len(ro.annotations) != 0 </span><span class="cov8" title="1">{
                plugin := plugins.CreateAddAnnotationsPlugin(ro.annotations)
                if err := plugin.Transform(resMap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed applying annotations plugin when preparing Kustomize resources. %w", err)
                }</span>
        }

        <span class="cov8" title="1">for i := range ro.plugins </span><span class="cov0" title="0">{
                if err := ro.plugins[i].Transform(resMap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed applying %v plugin when preparing Kustomize resources. %w", ro.plugins[i], err)
                }</span>
        }

        <span class="cov8" title="1">renderedRes := resMap.Resources()
        resp := make([]unstructured.Unstructured, len(renderedRes))

        for i := range renderedRes </span><span class="cov8" title="1">{
                m, err := renderedRes[i].Map()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to transform Resources to Unstructured. %w", err)
                }</span>

                <span class="cov8" title="1">u, err := resources.ToUnstructured(&amp;m)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to transform Resources to Unstructured. %w", err)
                }</span>

                <span class="cov8" title="1">resp[i] = *u</span>
        }

        <span class="cov8" title="1">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package kustomize

import (
        "sigs.k8s.io/kustomize/api/resmap"
        "sigs.k8s.io/kustomize/kyaml/kio"
        kyaml "sigs.k8s.io/kustomize/kyaml/yaml"
)

var _ resmap.Transformer = &amp;filterPlugin{}
var _ kio.Filter = &amp;filterProxy{}

type filterPlugin struct {
        f FilterFn
}

func (p *filterPlugin) Transform(m resmap.ResMap) error <span class="cov0" title="0">{
        return m.ApplyFilter(&amp;filterProxy{
                f: p.f,
        })
}</span>

type filterProxy struct {
        f FilterFn
}

func (f *filterProxy) Filter(nodes []*kyaml.RNode) ([]*kyaml.RNode, error) <span class="cov0" title="0">{
        return f.f(nodes)
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">package kustomize

import (
        "sigs.k8s.io/kustomize/kyaml/filesys"
)

type EngineOptsFn func(engine *Engine)

func WithEngineFS(value filesys.FileSystem) EngineOptsFn <span class="cov8" title="1">{
        return func(engine *Engine) </span><span class="cov8" title="1">{
                engine.fs = value
        }</span>
}

func WithEngineRenderOpts(values ...RenderOptsFn) EngineOptsFn <span class="cov0" title="0">{
        return func(engine *Engine) </span><span class="cov0" title="0">{
                for _, fn := range values </span><span class="cov0" title="0">{
                        fn(&amp;engine.renderOpts)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package kustomize

import (
        "sigs.k8s.io/kustomize/api/resmap"
        kyaml "sigs.k8s.io/kustomize/kyaml/yaml"
)

type FilterFn func(nodes []*kyaml.RNode) ([]*kyaml.RNode, error)

type renderOpts struct {
        kustomizationFileName    string
        kustomizationFileOverlay string
        ns                       string
        labels                   map[string]string
        annotations              map[string]string
        plugins                  []resmap.Transformer
}

type RenderOptsFn func(*renderOpts)

func WithKustomizationFileName(value string) RenderOptsFn <span class="cov0" title="0">{
        return func(opts *renderOpts) </span><span class="cov0" title="0">{
                opts.kustomizationFileName = value
        }</span>
}

func WithKustomizationOverlayPath(value string) RenderOptsFn <span class="cov0" title="0">{
        return func(opts *renderOpts) </span><span class="cov0" title="0">{
                opts.kustomizationFileOverlay = value
        }</span>
}

func WithNamespace(value string) RenderOptsFn <span class="cov8" title="1">{
        return func(opts *renderOpts) </span><span class="cov8" title="1">{
                opts.ns = value
        }</span>
}

func WithLabel(name string, value string) RenderOptsFn <span class="cov8" title="1">{
        return func(opts *renderOpts) </span><span class="cov8" title="1">{
                if opts.labels == nil </span><span class="cov8" title="1">{
                        opts.labels = map[string]string{}
                }</span>

                <span class="cov8" title="1">opts.labels[name] = value</span>
        }
}

func WithLabels(values map[string]string) RenderOptsFn <span class="cov0" title="0">{
        return func(opts *renderOpts) </span><span class="cov0" title="0">{
                if opts.labels == nil </span><span class="cov0" title="0">{
                        opts.labels = map[string]string{}
                }</span>

                <span class="cov0" title="0">for k, v := range values </span><span class="cov0" title="0">{
                        opts.labels[k] = v
                }</span>
        }
}

func WithAnnotation(name string, value string) RenderOptsFn <span class="cov0" title="0">{
        return func(opts *renderOpts) </span><span class="cov0" title="0">{
                if opts.annotations == nil </span><span class="cov0" title="0">{
                        opts.annotations = map[string]string{}
                }</span>

                <span class="cov0" title="0">opts.annotations[name] = value</span>
        }
}

func WithAnnotations(values map[string]string) RenderOptsFn <span class="cov8" title="1">{
        return func(opts *renderOpts) </span><span class="cov8" title="1">{
                if opts.annotations == nil </span><span class="cov8" title="1">{
                        opts.annotations = map[string]string{}
                }</span>

                <span class="cov8" title="1">for k, v := range values </span><span class="cov8" title="1">{
                        opts.annotations[k] = v
                }</span>
        }
}

func WithPlugin(value resmap.Transformer) RenderOptsFn <span class="cov0" title="0">{
        return func(opts *renderOpts) </span><span class="cov0" title="0">{
                opts.plugins = append(opts.plugins, value)
        }</span>
}

func WithFilter(value FilterFn) RenderOptsFn <span class="cov0" title="0">{
        return func(opts *renderOpts) </span><span class="cov0" title="0">{
                opts.plugins = append(opts.plugins, &amp;filterPlugin{f: value})
        }</span>
}

func WithFilters(values ...FilterFn) RenderOptsFn <span class="cov0" title="0">{
        return func(opts *renderOpts) </span><span class="cov0" title="0">{
                for i := range values </span><span class="cov0" title="0">{
                        opts.plugins = append(opts.plugins, &amp;filterPlugin{f: values[i]})
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package kustomize

import (
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        kyaml "sigs.k8s.io/kustomize/kyaml/yaml"
)

func NodeToUnstructured(n *kyaml.RNode) unstructured.Unstructured <span class="cov0" title="0">{
        u := unstructured.Unstructured{}
        u.SetAPIVersion(n.GetApiVersion())
        u.SetKind(n.GetKind())
        u.SetNamespace(n.GetNamespace())
        u.SetName(n.GetName())

        return u
}</span>
</pre>
		
		<pre class="file" id="file130" style="display: none">package plugins

import (
        "sigs.k8s.io/kustomize/api/builtins" //nolint:staticcheck // Remove after package update
        "sigs.k8s.io/kustomize/api/types"
        "sigs.k8s.io/kustomize/kyaml/resid"
)

func CreateAddAnnotationsPlugin(annotations map[string]string) *builtins.AnnotationsTransformerPlugin <span class="cov0" title="0">{
        return &amp;builtins.AnnotationsTransformerPlugin{
                Annotations: annotations,
                FieldSpecs: []types.FieldSpec{
                        {
                                Gvk:                resid.Gvk{},
                                Path:               "metadata/annotations",
                                CreateIfNotPresent: true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file131" style="display: none">package plugins

import (
        "sigs.k8s.io/kustomize/api/builtins" //nolint:staticcheck // Remove after package update
        "sigs.k8s.io/kustomize/api/types"
        "sigs.k8s.io/kustomize/kyaml/resid"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

// CreateAddLabelsPlugin creates a label transformer plugin that ensures resources
// to which this plugin is applied will have the Open Data Hub common labels included.
//
// It has a following characteristics:
//   - It adds labels to the "metadata/labels" path for all resource kinds.
//   - It adds labels to the "spec/template/metadata/labels" and "spec/selector/matchLabels" paths
//     for resources of kind "Deployment".
func CreateAddLabelsPlugin(componentName string) *builtins.LabelTransformerPlugin <span class="cov0" title="0">{
        return CreateSetLabelsPlugin(map[string]string{
                labels.ODH.Component(componentName): "true",
                labels.K8SCommon.PartOf:             componentName,
        })
}</span>

func CreateSetLabelsPlugin(labels map[string]string) *builtins.LabelTransformerPlugin <span class="cov0" title="0">{
        return &amp;builtins.LabelTransformerPlugin{
                Labels: labels,
                FieldSpecs: []types.FieldSpec{
                        {
                                Gvk:                resid.Gvk{Kind: "Deployment"},
                                Path:               "spec/template/metadata/labels",
                                CreateIfNotPresent: true,
                        },
                        {
                                Gvk:                resid.Gvk{Kind: "Deployment"},
                                Path:               "spec/selector/matchLabels",
                                CreateIfNotPresent: true,
                        },
                        {
                                Gvk:                resid.Gvk{},
                                Path:               "metadata/labels",
                                CreateIfNotPresent: true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file132" style="display: none">package plugins

import (
        "sigs.k8s.io/kustomize/api/builtins" //nolint:staticcheck // Remove after package update
        "sigs.k8s.io/kustomize/api/filters/namespace"
        "sigs.k8s.io/kustomize/api/types"
        "sigs.k8s.io/kustomize/kyaml/resid"
)

// CreateNamespaceApplierPlugin creates a plugin to ensure resources have the specified target namespace.
func CreateNamespaceApplierPlugin(targetNamespace string) *builtins.NamespaceTransformerPlugin <span class="cov0" title="0">{
        return &amp;builtins.NamespaceTransformerPlugin{
                ObjectMeta: types.ObjectMeta{
                        Name:      "odh-namespace-plugin",
                        Namespace: targetNamespace,
                },
                FieldSpecs: []types.FieldSpec{
                        {
                                Gvk:                resid.Gvk{},
                                Path:               "metadata/namespace",
                                CreateIfNotPresent: true,
                        },
                        {
                                Gvk: resid.Gvk{
                                        Group: "rbac.authorization.k8s.io",
                                        Kind:  "ClusterRoleBinding",
                                },
                                Path:               "subjects/namespace",
                                CreateIfNotPresent: true,
                        },
                        {
                                Gvk: resid.Gvk{
                                        Group: "rbac.authorization.k8s.io",
                                        Kind:  "RoleBinding",
                                },
                                Path:               "subjects/namespace",
                                CreateIfNotPresent: true,
                        },
                        {
                                Gvk: resid.Gvk{
                                        Group: "admissionregistration.k8s.io",
                                        Kind:  "ValidatingWebhookConfiguration",
                                },
                                Path:               "webhooks/clientConfig/service/namespace",
                                CreateIfNotPresent: false,
                        },
                        {
                                Gvk: resid.Gvk{
                                        Group: "admissionregistration.k8s.io",
                                        Kind:  "MutatingWebhookConfiguration",
                                },
                                Path:               "webhooks/clientConfig/service/namespace",
                                CreateIfNotPresent: false,
                        },
                        {
                                Gvk: resid.Gvk{
                                        Group: "apiextensions.k8s.io",
                                        Kind:  "CustomResourceDefinition",
                                },
                                Path:               "spec/conversion/webhook/clientConfig/service/namespace",
                                CreateIfNotPresent: false,
                        },
                },
                UnsetOnly:              false,
                SetRoleBindingSubjects: namespace.AllServiceAccountSubjects,
        }
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">package plugins

import (
        "errors"

        "k8s.io/apimachinery/pkg/runtime/schema"
        "sigs.k8s.io/kustomize/api/resmap"
        "sigs.k8s.io/kustomize/api/resource"
        "sigs.k8s.io/kustomize/kyaml/kio"
        kyaml "sigs.k8s.io/kustomize/kyaml/yaml"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
)

var (
        AllowListedFields = []RemoverPlugin{
                // for resources, i.e cpu and memory
                {
                        Gvk:  gvk.Deployment,
                        Path: []string{"spec", "template", "spec", "containers", "*", "resources"},
                },
                // for replicas
                {
                        Gvk:  gvk.Deployment,
                        Path: []string{"spec", "replicas"},
                },
        }
)

// Removes the field from the resources of ResMap if they match GVK.
type RemoverPlugin struct {
        Gvk  schema.GroupVersionKind
        Path []string
}

var _ resmap.Transformer = &amp;RemoverPlugin{}

// Transform removes the field from ResMap if they match filter.
func (p *RemoverPlugin) Transform(m resmap.ResMap) error <span class="cov0" title="0">{
        filter := RemoverFilter{
                Gvk:  p.Gvk,
                Path: p.Path,
        }
        return m.ApplyFilter(filter)
}</span>

// TransformResource works only on one resource, not on the whole ResMap.
func (p *RemoverPlugin) TransformResource(r *resource.Resource) error <span class="cov8" title="6">{
        filter := RemoverFilter{
                Gvk:  p.Gvk,
                Path: p.Path,
        }

        nodes := []*kyaml.RNode{&amp;r.RNode}
        _, err := filter.Filter(nodes)
        return err
}</span>

type RemoverFilter struct {
        Gvk  schema.GroupVersionKind
        Path []string
}

var _ kio.Filter = RemoverFilter{}

func (f RemoverFilter) Filter(nodes []*kyaml.RNode) ([]*kyaml.RNode, error) <span class="cov8" title="6">{
        return kio.FilterAll(kyaml.FilterFunc(f.run)).Filter(nodes)
}</span>

func (f RemoverFilter) run(node *kyaml.RNode) (*kyaml.RNode, error) <span class="cov8" title="6">{
        pathLen := len(f.Path)
        if pathLen == 0 </span><span class="cov0" title="0">{
                return node, errors.New("no field set to remove, path to the field cannot be empty")
        }</span>

        <span class="cov8" title="6">return ClearFieldFor(node, f.Gvk, f.Path)</span>
}

func ClearFieldFor(node *kyaml.RNode, gvk schema.GroupVersionKind, fieldPath []string) (*kyaml.RNode, error) <span class="cov8" title="6">{
        pathLen := len(fieldPath)
        if pathLen == 0 </span><span class="cov0" title="0">{
                return node, nil
        }</span>

        <span class="cov8" title="6">typeMeta := kyaml.TypeMeta{
                APIVersion: gvk.GroupVersion().String(),
                Kind:       gvk.Kind,
        }

        meta, err := node.GetMeta()
        if err != nil </span><span class="cov0" title="0">{
                return node, err
        }</span>

        <span class="cov8" title="6">if meta.TypeMeta != typeMeta </span><span class="cov0" title="0">{
                return node, nil
        }</span>

        <span class="cov8" title="6">path := fieldPath[:pathLen-1]
        name := fieldPath[pathLen-1]

        matcher := &amp;kyaml.PathMatcher{Path: path}
        result, err := node.Pipe(matcher)
        if err != nil </span><span class="cov0" title="0">{
                return node, err
        }</span>

        <span class="cov8" title="6">return node, result.VisitElements(
                func(node *kyaml.RNode) error </span><span class="cov10" title="8">{
                        return node.PipeE(kyaml.FieldClearer{Name: name})
                }</span>)
}

func ClearField(node *kyaml.RNode, fieldPath []string) (*kyaml.RNode, error) <span class="cov0" title="0">{
        pathLen := len(fieldPath)
        if pathLen == 0 </span><span class="cov0" title="0">{
                return node, nil
        }</span>

        <span class="cov0" title="0">path := fieldPath[:pathLen-1]
        name := fieldPath[pathLen-1]

        matcher := &amp;kyaml.PathMatcher{Path: path}
        result, err := node.Pipe(matcher)
        if err != nil </span><span class="cov0" title="0">{
                return node, err
        }</span>

        <span class="cov0" title="0">return node, result.VisitElements(
                func(node *kyaml.RNode) error </span><span class="cov0" title="0">{
                        return node.PipeE(kyaml.FieldClearer{Name: name})
                }</span>)
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package resources

import (
        "bytes"
        "context"
        "crypto/sha256"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "slices"

        "github.com/davecgh/go-spew/spew"
        routev1 "github.com/openshift/api/route/v1"
        "gopkg.in/yaml.v3"
        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/discovery"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/client/apiutil"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
)

const PlatformFieldOwner = "platform.opendatahub.io"

func ToUnstructured(obj any) (*unstructured.Unstructured, error) <span class="cov8" title="1">{
        data, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to convert object %T to unstructured: %w", obj, err)
        }</span>

        <span class="cov8" title="1">u := unstructured.Unstructured{
                Object: data,
        }

        return &amp;u, nil</span>
}

func ObjectToUnstructured(s *runtime.Scheme, obj client.Object) (*unstructured.Unstructured, error) <span class="cov8" title="1">{
        // Ensure that the object has a GroupVersionKind set
        if err := EnsureGroupVersionKind(s, obj); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to ensure GroupVersionKind: %w", err)
        }</span>

        // Now, convert the object to unstructured
        <span class="cov8" title="1">u, err := ToUnstructured(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return u, nil</span>
}

func ObjectFromUnstructured(s *runtime.Scheme, obj *unstructured.Unstructured, intoObj client.Object) error <span class="cov8" title="1">{
        if obj == nil </span><span class="cov8" title="1">{
                return errors.New("nil object")
        }</span>

        // Convert the unstructured object to the typed object
        <span class="cov8" title="1">err := runtime.DefaultUnstructuredConverter.FromUnstructured(obj.Object, intoObj)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to convert unstructured object to %T: %w", intoObj, err)
        }</span>

        // Ensure that the GroupVersionKind is correctly set on the target object
        <span class="cov8" title="1">err = EnsureGroupVersionKind(s, intoObj)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to ensure GroupVersionKind: %w", err)
        }</span>

        // Validate that the GroupVersionKind is known in the scheme
        <span class="cov8" title="1">gvk := intoObj.GetObjectKind().GroupVersionKind()
        if _, err := s.New(gvk); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("unable to create object for GVK %s: %w", gvk, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func Decode(decoder runtime.Decoder, content []byte) ([]unstructured.Unstructured, error) <span class="cov0" title="0">{
        results := make([]unstructured.Unstructured, 0)

        r := bytes.NewReader(content)
        yd := yaml.NewDecoder(r)

        for </span><span class="cov0" title="0">{
                var out map[string]interface{}

                err := yd.Decode(&amp;out)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">return nil, fmt.Errorf("unable to decode resource: %w", err)</span>
                }

                <span class="cov0" title="0">if len(out) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if out["Kind"] == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">encoded, err := yaml.Marshal(out)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to marshal resource: %w", err)
                }</span>

                <span class="cov0" title="0">var obj unstructured.Unstructured

                if _, _, err = decoder.Decode(encoded, nil, &amp;obj); err != nil </span><span class="cov0" title="0">{
                        if runtime.IsMissingKind(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">return nil, fmt.Errorf("unable to decode resource: %w", err)</span>
                }

                <span class="cov0" title="0">results = append(results, obj)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func GvkToUnstructured(gvk schema.GroupVersionKind) *unstructured.Unstructured <span class="cov0" title="0">{
        u := unstructured.Unstructured{}
        u.SetGroupVersionKind(gvk)

        return &amp;u
}</span>

func IngressHost(r routev1.Route) string <span class="cov0" title="0">{
        if len(r.Status.Ingress) != 1 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">in := r.Status.Ingress[0]

        for i := range in.Conditions </span><span class="cov0" title="0">{
                if in.Conditions[i].Type == routev1.RouteAdmitted &amp;&amp; in.Conditions[i].Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                        return in.Host
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func HasLabel(obj client.Object, k string, values ...string) bool <span class="cov8" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">target := obj.GetLabels()
        if target == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">val, found := target[k]
        if !found </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return slices.Contains(values, val)</span>
}

func SetLabels(obj client.Object, values map[string]string) <span class="cov0" title="0">{
        target := obj.GetLabels()
        if target == nil </span><span class="cov0" title="0">{
                target = make(map[string]string)
        }</span>

        <span class="cov0" title="0">for k, v := range values </span><span class="cov0" title="0">{
                target[k] = v
        }</span>

        <span class="cov0" title="0">obj.SetLabels(target)</span>
}

func SetLabel(obj client.Object, k string, v string) string <span class="cov0" title="0">{
        target := obj.GetLabels()
        if target == nil </span><span class="cov0" title="0">{
                target = make(map[string]string)
        }</span>

        <span class="cov0" title="0">old := target[k]
        target[k] = v

        obj.SetLabels(target)

        return old</span>
}

func RemoveLabel(obj client.Object, k string) <span class="cov0" title="0">{
        target := obj.GetLabels()
        if target == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">delete(target, k)

        obj.SetLabels(target)</span>
}

func GetLabel(obj client.Object, k string) string <span class="cov0" title="0">{
        target := obj.GetLabels()
        if target == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return target[k]</span>
}

func HasAnnotation(obj client.Object, k string, values ...string) bool <span class="cov8" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">target := obj.GetAnnotations()
        if target == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">val, found := target[k]
        if !found </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return slices.Contains(values, val)</span>
}

func SetAnnotations(obj client.Object, values map[string]string) <span class="cov0" title="0">{
        target := obj.GetAnnotations()
        if target == nil </span><span class="cov0" title="0">{
                target = make(map[string]string)
        }</span>

        <span class="cov0" title="0">for k, v := range values </span><span class="cov0" title="0">{
                target[k] = v
        }</span>

        <span class="cov0" title="0">obj.SetAnnotations(target)</span>
}

func SetAnnotation(obj client.Object, k string, v string) string <span class="cov0" title="0">{
        target := obj.GetAnnotations()
        if target == nil </span><span class="cov0" title="0">{
                target = make(map[string]string)
        }</span>

        <span class="cov0" title="0">old := target[k]
        target[k] = v

        obj.SetAnnotations(target)

        return old</span>
}

func RemoveAnnotation(obj client.Object, k string) <span class="cov0" title="0">{
        target := obj.GetAnnotations()
        if target == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">delete(target, k)

        obj.SetAnnotations(target)</span>
}

func GetAnnotation(obj client.Object, k string) string <span class="cov0" title="0">{
        target := obj.GetAnnotations()
        if target == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return target[k]</span>
}

// Hash generates an SHA-256 hash of an unstructured Kubernetes object, omitting
// specific fields that are typically irrelevant for hash comparison such as
// "creationTimestamp", "deletionTimestamp", "managedFields", "ownerReferences",
// "uid", "resourceVersion", and "status". It returns the computed hash as a byte
// slice or an error if the hashing process fails.
func Hash(in *unstructured.Unstructured) ([]byte, error) <span class="cov0" title="0">{
        obj := in.DeepCopy()
        unstructured.RemoveNestedField(obj.Object, "metadata", "uid")
        unstructured.RemoveNestedField(obj.Object, "metadata", "resourceVersion")
        unstructured.RemoveNestedField(obj.Object, "metadata", "deletionTimestamp")
        unstructured.RemoveNestedField(obj.Object, "metadata", "managedFields")
        unstructured.RemoveNestedField(obj.Object, "metadata", "ownerReferences")
        unstructured.RemoveNestedField(obj.Object, "status")

        printer := spew.ConfigState{
                Indent:         " ",
                SortKeys:       true,
                DisableMethods: true,
                SpewKeys:       true,
        }

        hasher := sha256.New()

        if _, err := printer.Fprintf(hasher, "%#v", obj); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate hash: %w", err)
        }</span>

        <span class="cov0" title="0">return hasher.Sum(nil), nil</span>
}

func EncodeToString(in []byte) string <span class="cov0" title="0">{
        return "v" + base64.RawURLEncoding.EncodeToString(in)
}</span>

func KindForObject(scheme *runtime.Scheme, obj runtime.Object) (string, error) <span class="cov0" title="0">{
        if obj.GetObjectKind().GroupVersionKind().Kind != "" </span><span class="cov0" title="0">{
                return obj.GetObjectKind().GroupVersionKind().Kind, nil
        }</span>

        <span class="cov0" title="0">gvk, err := apiutil.GVKForObject(obj, scheme)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get GVK: %w", err)
        }</span>

        <span class="cov0" title="0">return gvk.Kind, nil</span>
}

func GetGroupVersionKindForObject(s *runtime.Scheme, obj runtime.Object) (schema.GroupVersionKind, error) <span class="cov8" title="1">{
        if obj == nil </span><span class="cov8" title="1">{
                return schema.GroupVersionKind{}, errors.New("nil object")
        }</span>

        <span class="cov8" title="1">if obj.GetObjectKind().GroupVersionKind().Version != "" &amp;&amp; obj.GetObjectKind().GroupVersionKind().Kind != "" </span><span class="cov8" title="1">{
                return obj.GetObjectKind().GroupVersionKind(), nil
        }</span>

        <span class="cov8" title="1">gvk, err := apiutil.GVKForObject(obj, s)
        if err != nil </span><span class="cov8" title="1">{
                return schema.GroupVersionKind{}, fmt.Errorf("failed to get GVK: %w", err)
        }</span>

        <span class="cov8" title="1">return gvk, nil</span>
}

func EnsureGroupVersionKind(s *runtime.Scheme, obj client.Object) error <span class="cov8" title="1">{
        gvk, err := GetGroupVersionKindForObject(s, obj)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">obj.GetObjectKind().SetGroupVersionKind(gvk)

        return nil</span>
}

func HasDevFlags(in common.WithDevFlags) bool <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">df := in.GetDevFlags()

        return df != nil &amp;&amp; len(df.Manifests) != 0</span>
}

// InstanceHasDevFlags checks if the given PlatformObject implements the WithDevFlags interface
// and if it has any DevFlags set. If the object does not implement WithDevFlags, it returns false.
// This function helps ensure that only objects with the WithDevFlags interface are processed for DevFlags.
func InstanceHasDevFlags(in common.PlatformObject) bool <span class="cov0" title="0">{
        if obj, ok := in.(common.WithDevFlags); ok </span><span class="cov0" title="0">{
                return HasDevFlags(obj)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func NamespacedNameFromObject(obj client.Object) types.NamespacedName <span class="cov0" title="0">{
        return types.NamespacedName{
                Namespace: obj.GetNamespace(),
                Name:      obj.GetName(),
        }
}</span>

func FormatNamespacedName(nn types.NamespacedName) string <span class="cov0" title="0">{
        if nn.Namespace == "" </span><span class="cov0" title="0">{
                return nn.Name
        }</span>
        <span class="cov0" title="0">return nn.String()</span>
}

func FormatUnstructuredName(obj *unstructured.Unstructured) string <span class="cov0" title="0">{
        if obj.GetNamespace() == "" </span><span class="cov0" title="0">{
                return obj.GetName()
        }</span>
        <span class="cov0" title="0">return obj.GetNamespace() + string(types.Separator) + obj.GetName()</span>
}

// RemoveOwnerReferences removes all owner references from a Kubernetes object that match the provided predicate.
//
// This function iterates through the OwnerReferences of the given object, filters out those that satisfy
// the predicate, and updates the object in the cluster using the provided client.
//
// Parameters:
//   - ctx: The context for the request, which can carry deadlines, cancellation signals, and other request-scoped values.
//   - cli: A controller-runtime client used to update the Kubernetes object.
//   - obj: The Kubernetes object whose OwnerReferences are to be filtered. It must implement client.Object.
//   - predicate: A function that takes an OwnerReference and returns true if the reference should be removed.
//
// Returns:
//   - An error if the update operation fails, otherwise nil.
func RemoveOwnerReferences(
        ctx context.Context,
        cli client.Client,
        obj client.Object,
        predicate func(reference metav1.OwnerReference) bool,
) error <span class="cov8" title="1">{
        oldRefs := obj.GetOwnerReferences()
        if len(oldRefs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">newRefs := oldRefs[:0]
        for _, ref := range oldRefs </span><span class="cov8" title="1">{
                if !predicate(ref) </span><span class="cov8" title="1">{
                        newRefs = append(newRefs, ref)
                }</span>
        }

        <span class="cov8" title="1">if len(newRefs) == len(oldRefs) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">obj.SetOwnerReferences(newRefs)

        // Update the object in the cluster
        if err := cli.Update(ctx, obj); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "failed to remove owner references from object %s/%s with gvk %s: %w",
                        obj.GetNamespace(),
                        obj.GetName(),
                        obj.GetObjectKind().GroupVersionKind(),
                        err,
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsOwnedByType checks if the given object (obj) is owned by an entity of the specified GroupVersionKind.
// It iterates through the object's owner references to determine ownership.
//
// Parameters:
// - obj: The Kubernetes object to check ownership for.
// - ownerGVK: The GroupVersionKind (GVK) of the expected owner.
//
// Returns:
// - A boolean indicating whether the object is owned by an entity of the specified GVK.
// - An error if any issue occurs while parsing the owner's API version.
func IsOwnedByType(obj client.Object, ownerGVK schema.GroupVersionKind) (bool, error) <span class="cov0" title="0">{
        for _, ref := range obj.GetOwnerReferences() </span><span class="cov0" title="0">{
                av, err := schema.ParseGroupVersion(ref.APIVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">if av.Group == ownerGVK.Group &amp;&amp; av.Version == ownerGVK.Version &amp;&amp; ref.Kind == ownerGVK.Kind </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

func GvkToPartial(gvk schema.GroupVersionKind) *metav1.PartialObjectMetadata <span class="cov0" title="0">{
        return &amp;metav1.PartialObjectMetadata{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: gvk.GroupVersion().String(),
                        Kind:       gvk.Kind,
                },
        }
}</span>

// Apply patches an object using server-side apply.
//
// This function converts the input object to an unstructured type, removes fields that
// are not required for patching (i.e. managedFields, resourceVersion, and status), applies
// the patch, and updates the input object with the patched result.
//
// The function handles the case where the resource doesn't exist (NotFound error) by treating
// it as a success condition and returning nil.
//
// Parameters:
//   - ctx: The context for the client operation
//   - cli: The Kubernetes client interface used to perform the patch operation
//   - in: The Kubernetes object to be applied
//   - opts: Optional client patch options
//
// Returns:
//   - error: nil on success, or an error with context if the operation fails
func Apply(ctx context.Context, cli client.Client, in client.Object, opts ...client.PatchOption) error <span class="cov0" title="0">{
        err := EnsureGroupVersionKind(cli.Scheme(), in)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure GVK: %w", err)
        }</span>

        <span class="cov0" title="0">u, err := ToUnstructured(in)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert resource to unstructured: %w", err)
        }</span>

        // safe copy
        <span class="cov0" title="0">u = u.DeepCopy()

        // remove not required fields
        unstructured.RemoveNestedField(u.Object, "metadata", "managedFields")
        unstructured.RemoveNestedField(u.Object, "metadata", "resourceVersion")
        unstructured.RemoveNestedField(u.Object, "status")

        err = cli.Patch(ctx, u, client.Apply, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to patch object %s: %w", u, err)
        }</span>

        // Write back the modified object so callers can access the patched object.
        <span class="cov0" title="0">err = cli.Scheme().Convert(u, in, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write modified object: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ApplyStatus patches the status subresource of a Kubernetes object using server-side apply.
//
// This function converts the input object to an unstructured type, removes fields that are
// not required for patching (i.e. managedFields and resourceVersion), applies the patch to
// the status subresource, and updates the input object with the patched result.
//
// The function handles the case where the resource doesn't exist (NotFound error) by treating
// it as a success condition and returning nil.
//
// Parameters:
//   - ctx: The context for the client operation
//   - cli: The Kubernetes client interface used to perform the patch operation
//   - in: The Kubernetes object whose status should be applied
//   - opts: Optional client subresource patch options
//
// Returns:
//   - error: nil on success, or an error with context if the operation fails
func ApplyStatus(ctx context.Context, cli client.Client, in client.Object, opts ...client.SubResourcePatchOption) error <span class="cov0" title="0">{
        err := EnsureGroupVersionKind(cli.Scheme(), in)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure GVK: %w", err)
        }</span>

        <span class="cov0" title="0">u, err := ToUnstructured(in)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert resource to unstructured: %w", err)
        }</span>

        // safe copy
        <span class="cov0" title="0">u = u.DeepCopy()

        // remove not required fields
        unstructured.RemoveNestedField(u.Object, "metadata", "managedFields")
        unstructured.RemoveNestedField(u.Object, "metadata", "resourceVersion")

        err = cli.Status().Patch(ctx, u, client.Apply, opts...)
        switch </span>{
        case k8serr.IsNotFound(err):<span class="cov0" title="0"> // Cannot be removed like in Apply func because reconciler_finalizer_test.go would then throw an error, needs extensive test rewrite
                return nil</span>
        case err != nil:<span class="cov0" title="0">
                return fmt.Errorf("unable to patch object status %s: %w", u, err)</span>
        }

        // Write back the modified object so callers can access the patched object.
        <span class="cov0" title="0">err = cli.Scheme().Convert(u, in, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write modified object: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListAvailableAPIResources retrieves the preferred API resource lists available on
// the Kubernetes server using the provided discovery client.
//
// This function calls ServerPreferredResources to get a prioritized list of
// APIResourceList, which describes the API groups, versions, and resources the
// server supports.
//
// It gracefully handles partial discovery failures (e.g. due to aggregated APIs like
// Knative or custom metrics APIs that may require special permissions). In such cases,
// it still returns the successfully discovered resource lists.
//
// Parameters:
//   - cli: A discovery.DiscoveryInterface used to interact with the Kubernetes API server.
//
// Returns:
//   - []*metav1.APIResourceList: A list of resource groups and versions supported by
//     the server.
//   - error: Non-nil only if a non-group-discovery-related error occurs during discovery.
func ListAvailableAPIResources(
        cli discovery.DiscoveryInterface,
) ([]*metav1.APIResourceList, error) <span class="cov0" title="0">{
        items, err := cli.ServerPreferredResources()

        // Swallow group discovery errors, e.g., Knative serving exposes an
        // aggregated API for custom.metrics.k8s.io that requires special
        // authentication scheme while discovering preferred resources.
        if err != nil &amp;&amp; !discovery.IsGroupDiscoveryFailedError(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failure retrieving supported resources: %w", err)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package resources

import (
        "strings"

        "k8s.io/apimachinery/pkg/api/meta"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

type UnstructuredList []unstructured.Unstructured

func (l UnstructuredList) Clone() []unstructured.Unstructured <span class="cov0" title="0">{
        if len(l) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]unstructured.Unstructured, len(l))

        for i := range l </span><span class="cov0" title="0">{
                result[i] = *l[i].DeepCopy()
        }</span>

        <span class="cov0" title="0">return result</span>
}

// Resource represents a Kubernetes API resource type with convenient methods
// for accessing common properties and relationships. It wraps the standard
// meta.RESTMapping struct to provide a more intuitive interface.
type Resource struct {
        meta.RESTMapping
}

// GroupVersionResource returns the schema.GroupVersionResource associated with this Resource.
func (r Resource) GroupVersionResource() schema.GroupVersionResource <span class="cov0" title="0">{
        return r.Resource
}</span>

// GroupVersionKind returns the schema.GroupVersionKind associated with this Resource.
func (r Resource) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return r.RESTMapping.GroupVersionKind
}</span>

// String returns a string representation of this Resource that includes both
// the GroupVersionResource and GroupVersionKind for better debugging.
func (r Resource) String() string <span class="cov0" title="0">{
        gv := r.Resource.Version

        if len(r.Resource.Group) &gt; 0 </span><span class="cov0" title="0">{
                gv = r.Resource.Group + "/" + r.Resource.Version
        }</span>

        <span class="cov0" title="0">return strings.Join(
                []string{
                        gv, "Resource=", r.Resource.Resource, "Kind=", r.RESTMapping.GroupVersionKind.Kind,
                },
                " ",
        )</span>
}

// IsNamespaced returns true if this Resource is namespaced, false otherwise.
// Namespaced resources are those that exist within a Kubernetes namespace.
func (r Resource) IsNamespaced() bool <span class="cov0" title="0">{
        // The Scope field may be nil if the RESTMapping was not fully initialized
        // or if it was constructed manually. In this case, we assume the resource
        // is not namespaced.
        if r.Scope == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return r.Scope.Name() == meta.RESTScopeNameNamespace</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package rules

import (
        "context"
        "fmt"
        "maps"
        "slices"
        "strings"

        authorizationv1 "k8s.io/api/authorization/v1"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/discovery"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

const (
        // VerbDelete represents the Kubernetes delete permission verb.
        VerbDelete = "delete"

        // VerbAny represents a wildcard for any permission verb.
        VerbAny = "*"

        // ResourceAny represents a wildcard for any resource.
        ResourceAny = "*"
)

// RetrieveSelfSubjectRules retrieves the list of resource rules for the current subject
// (user or service account) in the specified namespace. It creates a SelfSubjectRulesReview
// to determine what actions the current subject is allowed to perform within the namespace.
//
// Parameters:
//   - ctx: The context for the client operation
//   - cli: The Kubernetes client interface used to create the SelfSubjectRulesReview
//   - ns: The namespace for which to retrieve the subject's resource rules
//
// Returns:
//   - []authorizationv1.ResourceRule: A slice of ResourceRule objects describing what actions
//     the current subject can perform on which resources in the specified namespace
//   - error: nil on success, or an error with context if the operation fails
//
// The function will return an error if:
//   - Creating the SelfSubjectRulesReview fails
func RetrieveSelfSubjectRules(
        ctx context.Context,
        cli client.Client,
        ns string,
) ([]authorizationv1.ResourceRule, error) <span class="cov10" title="2">{
        rulesReview := authorizationv1.SelfSubjectRulesReview{
                Spec: authorizationv1.SelfSubjectRulesReviewSpec{
                        Namespace: ns,
                },
        }

        err := cli.Create(ctx, &amp;rulesReview)
        if err != nil </span><span class="cov10" title="2">{
                return nil, fmt.Errorf("failed to create SelfSubjectRulesReview for namespace '%s': %w", ns, err)
        }</span>

        <span class="cov10" title="2">if rulesReview.Status.EvaluationError != "" </span><span class="cov10" title="2">{
                // NOTE: the EvaluationError is unreliable and may report wrong error that could
                // potentially cause misbehavior of the GC logic.
                logf.FromContext(ctx).Info("error occurred during rule evaluation: " + rulesReview.Status.EvaluationError)
        }</span>

        <span class="cov10" title="2">return rulesReview.Status.ResourceRules, nil</span>
}

// IsResourceMatchingRule determines if a Kubernetes API resource matches an authorization rule.
// It checks whether the resource's group and name are covered by the permissions defined in the
// rule.
//
// Parameters:
//   - resourceGroup: The API group of the resource being checked
//   - apiRes: The API resource metadata
//   - rule: The authorization rule to match against
//
// Returns:
//   - bool: true if the resource matches the rule, false otherwise
func IsResourceMatchingRule(
        resourceGroup string,
        apiRes metav1.APIResource,
        rule authorizationv1.ResourceRule,
) bool <span class="cov10" title="2">{
        // Check if the resource group matches any of the rule's API groups
        for _, ruleGroup := range rule.APIGroups </span><span class="cov10" title="2">{
                // Skip if the group doesn't match and isn't a wildcard
                if resourceGroup != ruleGroup &amp;&amp; ruleGroup != ResourceAny </span><span class="cov10" title="2">{
                        continue</span>
                }

                // Check if the resource name matches any of the rule's resources
                <span class="cov10" title="2">for _, ruleResource := range rule.Resources </span><span class="cov10" title="2">{
                        if apiRes.Name == ruleResource || ruleResource == ResourceAny </span><span class="cov10" title="2">{
                                return true
                        }</span>
                }
        }

        <span class="cov10" title="2">return false</span>
}

// HasDeletePermission checks if the current subject has permission to delete a specific API
// resource based on the provided authorization rules.
//
// Parameters:
//   - group: The API group of the resource to check
//   - apiRes: The API resource metadata
//   - permissionRules: A slice of authorization rules to check against
//
// Returns:
//   - bool: true if the resource can be deleted by the current subject, false otherwise
func HasDeletePermission(
        group string,
        apiRes metav1.APIResource,
        permissionRules []authorizationv1.ResourceRule,
) bool <span class="cov10" title="2">{
        for _, rule := range permissionRules </span><span class="cov10" title="2">{
                // Skip if the rule doesn't grant delete permission
                if !slices.Contains(rule.Verbs, VerbDelete) &amp;&amp; !slices.Contains(rule.Verbs, VerbAny) </span><span class="cov10" title="2">{
                        continue</span>
                }

                // Skip if the resource doesn't match this rule
                <span class="cov10" title="2">if !IsResourceMatchingRule(group, apiRes, rule) </span><span class="cov10" title="2">{
                        continue</span>
                }

                <span class="cov10" title="2">return true</span>
        }

        <span class="cov10" title="2">return false</span>
}

// ComputeDeletableResources returns a sorted list of Kubernetes resources that the user
// is authorized to delete, based on the available API resources and RBAC rules.
//
// Parameters:
//   - resourceLists: A slice of metav1.APIResourceList. Each entry describes a group/version
//     and the set of API resources (kinds) available under it.
//   - rules: A slice of authorizationv1.ResourceRule, representing the set of actions
//     the user is allowed to perform. These typically come from a SubjectAccessReview
//     or SelfSubjectRulesReview.
//
// Return values:
//   - []resources.Resource: A slice of resources the user can delete. Each resource includes
//     its GroupVersionResource, GroupVersionKind, and scope (namespaced or cluster-wide).
//     The slice is sorted by the string representation of the resource.
//   - error: Returned if any GroupVersion string in the API resource list fails to parse.
func ComputeDeletableResources(
        resourceLists []*metav1.APIResourceList,
        rules []authorizationv1.ResourceRule,
) ([]resources.Resource, error) <span class="cov10" title="2">{
        allowedResources := make(map[resources.Resource]struct{})

        for _, list := range resourceLists </span><span class="cov10" title="2">{
                groupVersion, err := schema.ParseGroupVersion(list.GroupVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to parse group version '%s': %w", list.GroupVersion, err)
                }</span>

                <span class="cov10" title="2">for _, apiResource := range list.APIResources </span><span class="cov10" title="2">{
                        group := apiResource.Group
                        if group == "" </span><span class="cov10" title="2">{
                                group = groupVersion.Group
                        }</span>

                        <span class="cov10" title="2">if !HasDeletePermission(group, apiResource, rules) </span><span class="cov10" title="2">{
                                continue</span>
                        }

                        <span class="cov10" title="2">resource := resources.Resource{
                                RESTMapping: meta.RESTMapping{
                                        Resource: schema.GroupVersionResource{
                                                Group:    groupVersion.Group,
                                                Version:  groupVersion.Version,
                                                Resource: apiResource.Name,
                                        },
                                        GroupVersionKind: schema.GroupVersionKind{
                                                Group:   groupVersion.Group,
                                                Version: groupVersion.Version,
                                                Kind:    apiResource.Kind,
                                        },
                                        Scope: meta.RESTScopeNamespace,
                                },
                        }

                        if apiResource.Namespaced </span><span class="cov10" title="2">{
                                resource.Scope = meta.RESTScopeNamespace
                        }</span> else<span class="cov0" title="0"> {
                                resource.Scope = meta.RESTScopeRoot
                        }</span>

                        <span class="cov10" title="2">allowedResources[resource] = struct{}{}</span>
                }
        }

        <span class="cov10" title="2">result := slices.AppendSeq(make([]resources.Resource, 0, len(allowedResources)), maps.Keys(allowedResources))
        slices.SortFunc(result, func(a, b resources.Resource) int </span><span class="cov10" title="2">{
                return strings.Compare(a.String(), b.String())
        }</span>)

        <span class="cov10" title="2">return result, nil</span>
}

// ListAuthorizedDeletableResources returns a list of Kubernetes resources that the current
// service account is authorized to delete within the specified namespace.
//
// It uses the discovery API to filter for resources that support the "delete" verb and
// cross-references this list with the user's effective RBAC permissions.
//
// This prevents querying resources that do not support deletion or that the user does not have
// permission to delete, thereby avoiding unnecessary or unauthorized API calls (e.g., errors
// like "MethodNotAllowed").
//
// Parameters:
//   - ctx: A context used for request cancellation and timeouts.
//   - cli: A controller-runtime client used to make Kubernetes API calls.
//   - apis: A slice of APIResourceList, typically returned by discovery from the API server.
//   - namespace: The namespace in which to evaluate the user's permissions.
//
// Returns:
//   - []resources.Resource: A slice of deletable resources the user is authorized to delete,
//     including their GVK, GVR, and scope information.
//   - error: Non-nil if permission checks or deletable resource computation fails.
func ListAuthorizedDeletableResources(
        ctx context.Context,
        cli client.Client,
        apis []*metav1.APIResourceList,
        namespace string,
) ([]resources.Resource, error) <span class="cov10" title="2">{
        // We only take types that support the "delete" verb,
        // to prevents from performing queries that we know are going to
        // return "MethodNotAllowed".
        apiResourceLists := discovery.FilteredBy(
                discovery.SupportsAllVerbs{
                        Verbs: []string{VerbDelete},
                },
                apis,
        )

        // Get the permissions of the service account in the specified namespace.
        items, err := RetrieveSelfSubjectRules(ctx, cli, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failure retrieving resource rules: %w", err)
        }</span>

        // Collect deletable resources.
        <span class="cov10" title="2">result, err := ComputeDeletableResources(apiResourceLists, items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failure retrieving deletable resources: %w", err)
        }</span>

        <span class="cov10" title="2">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package upgrade

import (
        "context"
        "fmt"
        "time"

        corev1 "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
)

const (
        // DeleteConfigMapLabel is the label for configMap used to trigger operator uninstall
        // TODO: Label should be updated if addon name changes.
        DeleteConfigMapLabel = "api.openshift.com/addon-managed-odh-delete"
)

// OperatorUninstall deletes all the externally generated resources.
// This includes DSCI, namespace created by operator (but not workbench or MR's), subscription and CSV.
func OperatorUninstall(ctx context.Context, cli client.Client, platform common.Platform) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)

        if err := removeDSC(ctx, cli); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := removeDSCI(ctx, cli); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete generated namespaces by the operator
        <span class="cov0" title="0">generatedNamespaces := &amp;corev1.NamespaceList{}
        nsOptions := []client.ListOption{
                client.MatchingLabels{labels.ODH.OwnedNamespace: "true"},
        }
        if err := cli.List(ctx, generatedNamespaces, nsOptions...); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting generated namespaces : %w", err)
        }</span>

        // Return if any one of the namespaces is Terminating due to resources that are in process of deletion. (e.g. CRDs)
        <span class="cov0" title="0">for _, namespace := range generatedNamespaces.Items </span><span class="cov0" title="0">{
                if namespace.Status.Phase == corev1.NamespaceTerminating </span><span class="cov0" title="0">{
                        return fmt.Errorf("waiting for namespace %v to be deleted", namespace.Name)
                }</span>
        }

        <span class="cov0" title="0">for _, namespace := range generatedNamespaces.Items </span><span class="cov0" title="0">{
                if namespace.Status.Phase == corev1.NamespaceActive </span><span class="cov0" title="0">{
                        if err := cli.Delete(ctx, &amp;namespace); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error deleting namespace %v: %w", namespace.Name, err)
                        }</span>
                        <span class="cov0" title="0">log.Info("Namespace deleted as a part of uninstallation", "namespace", namespace.Name)</span>
                }
        }

        // give enough time for namespace deletion before proceed
        <span class="cov0" title="0">time.Sleep(10 * time.Second)

        // We can only assume the subscription is using standard names
        // if user install by creating different named subs, then we will not know the name
        // we cannot remove CSV before remove subscription because that need SA account
        operatorNs, err := cluster.GetOperatorNamespace()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Info("Removing operator subscription which in turn will remove installplan")
        subsName := "opendatahub-operator"
        if platform == cluster.SelfManagedRhoai </span><span class="cov0" title="0">{
                subsName = "rhods-operator"
        }</span>
        <span class="cov0" title="0">if platform != cluster.ManagedRhoai </span><span class="cov0" title="0">{
                if err := cluster.DeleteExistingSubscription(ctx, cli, operatorNs, subsName); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">log.Info("Removing the operator CSV in turn remove operator deployment")
        err = removeCSV(ctx, cli)

        log.Info("All resources deleted as part of uninstall.")
        return err</span>
}

func removeDSCI(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        instance := &amp;dsciv1.DSCInitialization{}

        if err := cli.DeleteAllOf(ctx, instance, client.PropagationPolicy(metav1.DeletePropagationForeground)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failure deleting DSCI: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func removeDSC(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        instance := &amp;dscv1.DataScienceCluster{}

        if err := cli.DeleteAllOf(ctx, instance, client.PropagationPolicy(metav1.DeletePropagationForeground)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failure deleting DSC: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HasDeleteConfigMap returns true if delete configMap is added to the operator namespace by managed-tenants repo.
// It returns false in all other cases.
func HasDeleteConfigMap(ctx context.Context, c client.Client) bool <span class="cov0" title="0">{
        // Get watchNamespace
        operatorNamespace, err := cluster.GetOperatorNamespace()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // If delete configMap is added, uninstall the operator and the resources
        <span class="cov0" title="0">deleteConfigMapList := &amp;corev1.ConfigMapList{}
        cmOptions := []client.ListOption{
                client.InNamespace(operatorNamespace),
                client.MatchingLabels{DeleteConfigMapLabel: "true"},
        }

        if err := c.List(ctx, deleteConfigMapList, cmOptions...); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return len(deleteConfigMapList.Items) != 0</span>
}

func removeCSV(ctx context.Context, c client.Client) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        // Get watchNamespace
        operatorNamespace, err := cluster.GetOperatorNamespace()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">operatorCsv, err := cluster.GetClusterServiceVersion(ctx, c, operatorNamespace)
        if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                ctrl.Log.Info("No clusterserviceversion for the operator found.")
                return nil
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Info("Deleting CSV", "name", operatorCsv.Name)
        err = c.Delete(ctx, operatorCsv)
        if err != nil </span><span class="cov0" title="0">{
                if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("error deleting clusterserviceversion: %w", err)</span>
        }
        <span class="cov0" title="0">log.Info("Clusterserviceversion deleted as a part of uninstall", "name", operatorCsv.Name)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">// Package upgrade provides functions of upgrade ODH from v1 to v2 and vaiours v2 versions.
// It contains both the logic to upgrade the ODH components and the logic to cleanup the deprecated resources.
package upgrade

import (
        "context"
        "errors"
        "fmt"
        "reflect"

        "github.com/hashicorp/go-multierror"
        operatorv1 "github.com/openshift/api/operator/v1"
        templatev1 "github.com/openshift/api/template/v1"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        appsv1 "k8s.io/api/apps/v1"
        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        apiextv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/opendatahub-io/opendatahub-operator/v2/api/common"
        componentApi "github.com/opendatahub-io/opendatahub-operator/v2/api/components/v1alpha1"
        dscv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/datasciencecluster/v1"
        dsciv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/dscinitialization/v1"
        featuresv1 "github.com/opendatahub-io/opendatahub-operator/v2/api/features/v1"
        infrav1 "github.com/opendatahub-io/opendatahub-operator/v2/api/infrastructure/v1"
        serviceApi "github.com/opendatahub-io/opendatahub-operator/v2/api/services/v1alpha1"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/cluster/gvk"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/metadata/labels"
        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

// TODO: to be removed: https://issues.redhat.com/browse/RHOAIENG-21080
var (
        NotebookSizesData = []any{
                map[string]any{
                        "name": "Small",
                        "resources": map[string]any{
                                "requests": map[string]any{
                                        "cpu":    "1",
                                        "memory": "8Gi",
                                },
                                "limits": map[string]any{
                                        "cpu":    "2",
                                        "memory": "8Gi",
                                },
                        },
                },
                map[string]any{
                        "name": "Medium",
                        "resources": map[string]any{
                                "requests": map[string]any{
                                        "cpu":    "3",
                                        "memory": "24Gi",
                                },
                                "limits": map[string]any{
                                        "cpu":    "6",
                                        "memory": "24Gi",
                                },
                        },
                },
                map[string]any{
                        "name": "Large",
                        "resources": map[string]any{
                                "requests": map[string]any{
                                        "cpu":    "7",
                                        "memory": "56Gi",
                                },
                                "limits": map[string]any{
                                        "cpu":    "14",
                                        "memory": "56Gi",
                                },
                        },
                },
                map[string]any{
                        "name": "X Large",
                        "resources": map[string]any{
                                "requests": map[string]any{
                                        "cpu":    "15",
                                        "memory": "120Gi",
                                },
                                "limits": map[string]any{
                                        "cpu":    "30",
                                        "memory": "120Gi",
                                },
                        },
                },
        }
        ModelServerSizeData = []any{
                map[string]any{
                        "name": "Small",
                        "resources": map[string]any{
                                "requests": map[string]any{
                                        "cpu":    "1",
                                        "memory": "4Gi",
                                },
                                "limits": map[string]any{
                                        "cpu":    "2",
                                        "memory": "8Gi",
                                },
                        },
                },
                map[string]any{
                        "name": "Medium",
                        "resources": map[string]any{
                                "requests": map[string]any{
                                        "cpu":    "4",
                                        "memory": "8Gi",
                                },
                                "limits": map[string]any{
                                        "cpu":    "8",
                                        "memory": "10Gi",
                                },
                        },
                },
                map[string]any{
                        "name": "Large",
                        "resources": map[string]any{
                                "requests": map[string]any{
                                        "cpu":    "6",
                                        "memory": "16Gi",
                                },
                                "limits": map[string]any{
                                        "cpu":    "10",
                                        "memory": "20Gi",
                                },
                        },
                },
                map[string]any{
                        "name": "Custom",
                        "resources": map[string]any{
                                "requests": map[string]any{},
                                "limits":   map[string]any{},
                        },
                },
        }
)

type ResourceSpec struct {
        Gvk       schema.GroupVersionKind
        Namespace string
        // path to the field, like "metadata", "name"
        Path []string
        // set of values for the field to match object, any one matches
        Values []string
}

// CreateDefaultDSC creates a default instance of DSC.
// Note: When the platform is not Managed, and a DSC instance already exists, the function doesn't re-create/update the resource.
func CreateDefaultDSC(ctx context.Context, cli client.Client) error <span class="cov0" title="0">{
        // Set the default DSC name depending on the platform
        releaseDataScienceCluster := &amp;dscv1.DataScienceCluster{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "DataScienceCluster",
                        APIVersion: "datasciencecluster.opendatahub.io/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: "default-dsc",
                },
                Spec: dscv1.DataScienceClusterSpec{
                        Components: dscv1.Components{
                                Dashboard: componentApi.DSCDashboard{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                Workbenches: componentApi.DSCWorkbenches{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                ModelMeshServing: componentApi.DSCModelMeshServing{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                DataSciencePipelines: componentApi.DSCDataSciencePipelines{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                Kserve: componentApi.DSCKserve{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                CodeFlare: componentApi.DSCCodeFlare{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                Ray: componentApi.DSCRay{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                Kueue: componentApi.DSCKueue{
                                        KueueManagementSpec: componentApi.KueueManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                TrustyAI: componentApi.DSCTrustyAI{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                ModelRegistry: componentApi.DSCModelRegistry{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                TrainingOperator: componentApi.DSCTrainingOperator{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                FeastOperator: componentApi.DSCFeastOperator{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                                },
                                LlamaStackOperator: componentApi.DSCLlamaStackOperator{
                                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Removed},
                                },
                        },
                },
        }
        err := cluster.CreateWithRetry(ctx, cli, releaseDataScienceCluster) // 1 min timeout
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create DataScienceCluster custom resource: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateDefaultDSCI creates a default instance of DSCI
// If there exists default-dsci instance already, it will not update DSCISpec on it.
// Note: DSCI CR modifcations are not supported, as it is the initial prereq setting for the components.
func CreateDefaultDSCI(ctx context.Context, cli client.Client, _ common.Platform, monNamespace string) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        defaultDsciSpec := &amp;dsciv1.DSCInitializationSpec{
                Monitoring: serviceApi.DSCIMonitoring{
                        ManagementSpec: common.ManagementSpec{ManagementState: operatorv1.Managed},
                        MonitoringCommonSpec: serviceApi.MonitoringCommonSpec{
                                Namespace: monNamespace,
                                Metrics:   &amp;serviceApi.Metrics{},
                        },
                },
                ServiceMesh: &amp;infrav1.ServiceMeshSpec{
                        ManagementState: "Managed",
                        ControlPlane: infrav1.ControlPlaneSpec{
                                Name:              "data-science-smcp",
                                Namespace:         "istio-system",
                                MetricsCollection: "Istio",
                        },
                },
                TrustedCABundle: &amp;dsciv1.TrustedCABundleSpec{
                        ManagementState: "Managed",
                },
        }

        defaultDsci := &amp;dsciv1.DSCInitialization{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "DSCInitialization",
                        APIVersion: "dscinitialization.opendatahub.io/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: "default-dsci",
                },
                Spec: *defaultDsciSpec,
        }

        instances := &amp;dsciv1.DSCInitializationList{}
        if err := cli.List(ctx, instances); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch </span>{
        case len(instances.Items) &gt; 1:<span class="cov0" title="0">
                log.Info("only one instance of DSCInitialization object is allowed. Please delete other instances.")
                return nil</span>
        case len(instances.Items) == 1:<span class="cov0" title="0">
                // Do not patch/update if DSCI already exists.
                log.Info("DSCInitialization resource already exists. It will not be updated with default DSCI.")
                return nil</span>
        case len(instances.Items) == 0:<span class="cov0" title="0">
                log.Info("create default DSCI CR.")
                err := cluster.CreateWithRetry(ctx, cli, defaultDsci) // 1 min timeout
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getJPHOdhDocumentResources(namespace string, matchedName []string) []ResourceSpec <span class="cov5" title="4">{
        metadataName := []string{"metadata", "name"}
        return []ResourceSpec{
                {
                        Gvk:       gvk.OdhDocument,
                        Namespace: namespace,
                        Path:      metadataName,
                        Values:    matchedName,
                },
        }
}</span>

func getDashboardWatsonResources(ns string) []ResourceSpec <span class="cov5" title="4">{
        metadataName := []string{"metadata", "name"}
        specAppName := []string{"spec", "appName"}
        appName := []string{"watson-studio"}

        return []ResourceSpec{
                {
                        Gvk:       gvk.OdhQuickStart,
                        Namespace: ns,
                        Path:      specAppName,
                        Values:    appName,
                },
                {
                        Gvk:       gvk.OdhDocument,
                        Namespace: ns,
                        Path:      specAppName,
                        Values:    appName,
                },
                {
                        Gvk:       gvk.OdhApplication,
                        Namespace: ns,
                        Path:      metadataName,
                        Values:    appName,
                },
        }
}</span>

// TODO: remove function once we have a generic solution across all components.
func CleanupExistingResource(ctx context.Context,
        cli client.Client,
        platform common.Platform,
        oldReleaseVersion common.Release,
) error <span class="cov5" title="4">{
        var multiErr *multierror.Error
        // get DSCI CR to get application namespace
        dsciList := &amp;dsciv1.DSCInitializationList{}
        if err := cli.List(ctx, dsciList); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="4">if len(dsciList.Items) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov5" title="4">d := &amp;dsciList.Items[0]
        // Handling for dashboard OdhApplication Jupyterhub CR, see jira #443
        multiErr = multierror.Append(multiErr, removOdhApplicationsCR(ctx, cli, gvk.OdhApplication, "jupyterhub", d.Spec.ApplicationsNamespace))

        // cleanup for github.com/opendatahub-io/pull/888
        deprecatedFeatureTrackers := []string{d.Spec.ApplicationsNamespace + "-kserve-temporary-fixes"}
        multiErr = multierror.Append(multiErr, deleteDeprecatedResources(ctx, cli, d.Spec.ApplicationsNamespace, deprecatedFeatureTrackers, &amp;featuresv1.FeatureTrackerList{}))

        // Cleanup of deprecated default RoleBinding resources
        deprecatedDefaultRoleBinding := []string{d.Spec.ApplicationsNamespace}
        multiErr = multierror.Append(multiErr, deleteDeprecatedResources(ctx, cli, d.Spec.ApplicationsNamespace, deprecatedDefaultRoleBinding, &amp;rbacv1.RoleBindingList{}))

        // Handling for dashboard OdhDocument Jupyterhub CR, see jira #443 comments
        odhDocJPH := getJPHOdhDocumentResources(
                d.Spec.ApplicationsNamespace,
                []string{
                        "jupyterhub-install-python-packages",
                        "jupyterhub-update-server-settings",
                        "jupyterhub-view-installed-packages",
                        "jupyterhub-use-s3-bucket-data",
                })
        multiErr = multierror.Append(multiErr, deleteResources(ctx, cli, &amp;odhDocJPH))
        // only apply on RHOAI since ODH has a different way to create this CR by dashboard
        if platform == cluster.SelfManagedRhoai || platform == cluster.ManagedRhoai </span><span class="cov5" title="4">{
                if err := upgradeODCCR(ctx, cli, "odh-dashboard-config", d.Spec.ApplicationsNamespace, oldReleaseVersion); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // remove modelreg proxy container from deployment in ODH
        <span class="cov5" title="4">if platform == cluster.OpenDataHub </span><span class="cov0" title="0">{
                if err := removeRBACProxyModelRegistry(ctx, cli, "model-registry-operator", "kube-rbac-proxy", d.Spec.ApplicationsNamespace); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // to take a reference
        <span class="cov5" title="4">toDelete := getDashboardWatsonResources(d.Spec.ApplicationsNamespace)
        multiErr = multierror.Append(multiErr, deleteResources(ctx, cli, &amp;toDelete))

        // cleanup nvidia nim integration
        multiErr = multierror.Append(multiErr, cleanupNimIntegration(ctx, cli, oldReleaseVersion, d.Spec.ApplicationsNamespace))
        // cleanup model controller legacy deployment
        multiErr = multierror.Append(multiErr, cleanupModelControllerLegacyDeployment(ctx, cli, d.Spec.ApplicationsNamespace))
        // cleanup deprecated kueue ValidatingAdmissionPolicyBinding
        multiErr = multierror.Append(multiErr, cleanupDeprecatedKueueVAPB(ctx, cli))

        return multiErr.ErrorOrNil()</span>
}

func deleteResources(ctx context.Context, c client.Client, resources *[]ResourceSpec) error <span class="cov7" title="7">{
        var errors *multierror.Error

        for _, res := range *resources </span><span class="cov10" title="13">{
                err := deleteOneResource(ctx, c, res)
                errors = multierror.Append(errors, err)
        }</span>

        <span class="cov7" title="7">return errors.ErrorOrNil()</span>
}

func deleteOneResource(ctx context.Context, c client.Client, res ResourceSpec) error <span class="cov10" title="13">{
        log := logf.FromContext(ctx)
        list := &amp;unstructured.UnstructuredList{}
        list.SetGroupVersionKind(res.Gvk)

        err := c.List(ctx, list, client.InNamespace(res.Namespace))
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, &amp;meta.NoKindMatchError{}) </span><span class="cov0" title="0">{
                        log.Info("CRD not found, will not delete", "gvk", res.Gvk.String())
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to list %s: %w", res.Gvk.Kind, err)</span>
        }

        <span class="cov10" title="13">for _, item := range list.Items </span><span class="cov0" title="0">{
                v, ok, err := unstructured.NestedString(item.Object, res.Path...)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get field %v for %s %s/%s: %w", res.Path, res.Gvk.Kind, res.Namespace, item.GetName(), err)
                }</span>

                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexisting path to delete: %v", res.Path)
                }</span>

                <span class="cov0" title="0">for _, toDelete := range res.Values </span><span class="cov0" title="0">{
                        if v == toDelete </span><span class="cov0" title="0">{
                                err = c.Delete(ctx, &amp;item)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to delete %s %s/%s: %w", res.Gvk.Kind, res.Namespace, item.GetName(), err)
                                }</span>
                                <span class="cov0" title="0">log.Info("Deleted object", "name", item.GetName(), "gvk", res.Gvk.String(), "namespace", res.Namespace)</span>
                        }
                }
        }

        <span class="cov10" title="13">return nil</span>
}

func deleteDeprecatedResources(ctx context.Context, cli client.Client, namespace string, resourceList []string, resourceType client.ObjectList) error <span class="cov7" title="7">{
        log := logf.FromContext(ctx)
        var multiErr *multierror.Error
        listOpts := &amp;client.ListOptions{Namespace: namespace}
        if err := cli.List(ctx, resourceType, listOpts); err != nil </span><span class="cov0" title="0">{
                multiErr = multierror.Append(multiErr, err)
        }</span>
        <span class="cov7" title="7">items := reflect.ValueOf(resourceType).Elem().FieldByName("Items")
        for i := range items.Len() </span><span class="cov0" title="0">{
                item := items.Index(i).Addr().Interface().(client.Object) //nolint:errcheck,forcetypeassert
                for _, name := range resourceList </span><span class="cov0" title="0">{
                        if name == item.GetName() </span><span class="cov0" title="0">{
                                log.Info("Attempting to delete", "name", item.GetName(), "namespace", namespace)
                                err := cli.Delete(ctx, item)
                                if err != nil </span><span class="cov0" title="0">{
                                        if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                                                log.Info("Could not find", "name", item.GetName(), "namespace", namespace)
                                        }</span> else<span class="cov0" title="0"> {
                                                multiErr = multierror.Append(multiErr, err)
                                        }</span>
                                }
                                <span class="cov0" title="0">log.Info("Successfully deleted", "name", item.GetName())</span>
                        }
                }
        }
        <span class="cov7" title="7">return multiErr.ErrorOrNil()</span>
}

func removOdhApplicationsCR(ctx context.Context, cli client.Client, gvk schema.GroupVersionKind, instanceName string, applicationNS string) error <span class="cov5" title="4">{
        // first check if CRD in cluster
        crd := &amp;apiextv1.CustomResourceDefinition{}
        if err := cli.Get(ctx, client.ObjectKey{Name: "odhapplications.dashboard.opendatahub.io"}, crd); err != nil </span><span class="cov5" title="4">{
                return client.IgnoreNotFound(err)
        }</span>

        // then check if CR in cluster to delete
        <span class="cov0" title="0">odhObject := &amp;unstructured.Unstructured{}
        odhObject.SetGroupVersionKind(gvk)
        if err := cli.Get(ctx, client.ObjectKey{
                Namespace: applicationNS,
                Name:      instanceName,
        }, odhObject); err != nil </span><span class="cov0" title="0">{
                return client.IgnoreNotFound(err)
        }</span>
        <span class="cov0" title="0">if err := cli.Delete(ctx, odhObject); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error deleting CR %s : %w", instanceName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// upgradODCCR handles different cases:
// 1. unset ownerreference for CR odh-dashboard-config
// 2. flip TrustyAI BiasMetrics to false (.spec.dashboardConfig.disableBiasMetrics) if it is lower release version than input 'release'.
// 3. flip ModelRegistry to false (.spec.dashboardConfig.disableModelRegistry) if it is lower release version than input 'release'.
func upgradeODCCR(ctx context.Context, cli client.Client, instanceName string, applicationNS string, release common.Release) error <span class="cov5" title="4">{
        crd := &amp;apiextv1.CustomResourceDefinition{}
        if err := cli.Get(ctx, client.ObjectKey{Name: "odhdashboardconfigs.opendatahub.io"}, crd); err != nil </span><span class="cov5" title="4">{
                return client.IgnoreNotFound(err)
        }</span>
        <span class="cov0" title="0">odhObject := &amp;unstructured.Unstructured{}
        odhObject.SetGroupVersionKind(gvk.OdhDashboardConfig)
        if err := cli.Get(ctx, client.ObjectKey{
                Namespace: applicationNS,
                Name:      instanceName,
        }, odhObject); err != nil </span><span class="cov0" title="0">{
                return client.IgnoreNotFound(err)
        }</span>

        <span class="cov0" title="0">if err := unsetOwnerReference(ctx, cli, instanceName, odhObject); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := updateODCBiasMetrics(ctx, cli, instanceName, release, odhObject); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return updateODCModelRegistry(ctx, cli, instanceName, release, odhObject)</span>
}

func unsetOwnerReference(ctx context.Context, cli client.Client, instanceName string, odhObject *unstructured.Unstructured) error <span class="cov0" title="0">{
        if odhObject.GetOwnerReferences() != nil </span><span class="cov0" title="0">{
                // set to nil as updates
                odhObject.SetOwnerReferences(nil)
                if err := cli.Update(ctx, odhObject); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error unset ownerreference for CR %s : %w", instanceName, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func updateODCBiasMetrics(ctx context.Context, cli client.Client, instanceName string, oldRelease common.Release, odhObject *unstructured.Unstructured) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        // "from version" as oldRelease, if return "0.0.0" meaning running on 2.10- release/dummy CI build
        // if oldRelease is lower than 2.14.0(e.g 2.13.x-a), flip disableBiasMetrics to false (even the field did not exist)
        if oldRelease.Version.Minor &lt; 14 </span><span class="cov0" title="0">{
                log.Info("Upgrade force BiasMetrics to false due to old release &lt; 2.14.0", "instance", instanceName)
                // flip TrustyAI BiasMetrics to false (.spec.dashboardConfig.disableBiasMetrics)
                disableBiasMetricsValue := []byte(`{"spec": {"dashboardConfig": {"disableBiasMetrics": false}}}`)
                if err := cli.Patch(ctx, odhObject, client.RawPatch(types.MergePatchType, disableBiasMetricsValue)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error enable BiasMetrics in CR %s : %w", instanceName, err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">log.Info("Upgrade does not force BiasMetrics to false due to from release &gt;= 2.14.0")
        return nil</span>
}

func updateODCModelRegistry(ctx context.Context, cli client.Client, instanceName string, oldRelease common.Release, odhObject *unstructured.Unstructured) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        // "from version" as oldRelease, if return "0.0.0" meaning running on 2.10- release/dummy CI build
        // if oldRelease is lower than 2.14.0(e.g 2.13.x-a), flip disableModelRegistry to false (even the field did not exist)
        if oldRelease.Version.Minor &lt; 14 </span><span class="cov0" title="0">{
                log.Info("Upgrade force ModelRegistry to false due to old release &lt; 2.14.0", "instance", instanceName)
                disableModelRegistryValue := []byte(`{"spec": {"dashboardConfig": {"disableModelRegistry": false}}}`)
                if err := cli.Patch(ctx, odhObject, client.RawPatch(types.MergePatchType, disableModelRegistryValue)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error enable ModelRegistry in CR %s : %w", instanceName, err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">log.Info("Upgrade does not force ModelRegistry to false due to from release &gt;= 2.14.0")
        return nil</span>
}

// workaround for RHOAIENG-15328
// TODO: this can be removed from ODH 2.22.
func removeRBACProxyModelRegistry(ctx context.Context, cli client.Client, componentName string, containerName string, applicationNS string) error <span class="cov0" title="0">{
        log := logf.FromContext(ctx)
        deploymentList := &amp;appsv1.DeploymentList{}
        if err := cli.List(ctx, deploymentList, client.InNamespace(applicationNS), client.HasLabels{labels.ODH.Component(componentName)}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error fetching list of deployments: %w", err)
        }</span>

        <span class="cov0" title="0">if len(deploymentList.Items) != 1 </span><span class="cov0" title="0">{ // ModelRegistry operator is not deployed
                return nil
        }</span>
        <span class="cov0" title="0">mrDeployment := deploymentList.Items[0]
        mrContainerList := mrDeployment.Spec.Template.Spec.Containers
        // if only one container in deployment, we are already on newer deployment, no need more action
        if len(mrContainerList) == 1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">log.Info("Upgrade force ModelRegistry to remove container from deployment")
        for i, container := range mrContainerList </span><span class="cov0" title="0">{
                if container.Name == containerName </span><span class="cov0" title="0">{
                        removeUnusedKubeRbacProxy := []byte(fmt.Sprintf("[{\"op\": \"remove\", \"path\": \"/spec/template/spec/containers/%d\"}]", i))
                        if err := cli.Patch(ctx, &amp;mrDeployment, client.RawPatch(types.JSONPatchType, removeUnusedKubeRbacProxy)); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error removing ModelRegistry %s container from deployment: %w", containerName, err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func GetDeployedRelease(ctx context.Context, cli client.Client) (common.Release, error) <span class="cov0" title="0">{
        dsciInstance, err := cluster.GetDSCI(ctx, cli)
        switch </span>{
        case k8serr.IsNotFound(err):<span class="cov0" title="0">
                break</span>
        case err != nil:<span class="cov0" title="0">
                return common.Release{}, err</span>
        default:<span class="cov0" title="0">
                return dsciInstance.Status.Release, nil</span>
        }

        // no DSCI CR found, try with DSC CR
        <span class="cov0" title="0">dscInstances, err := cluster.GetDSC(ctx, cli)
        switch </span>{
        case k8serr.IsNotFound(err):<span class="cov0" title="0">
                break</span>
        case err != nil:<span class="cov0" title="0">
                return common.Release{}, err</span>
        default:<span class="cov0" title="0">
                return dscInstances.Status.Release, nil</span>
        }

        // could be a clean installation or both CRs are deleted already
        <span class="cov0" title="0">return common.Release{}, nil</span>
}

func cleanupNimIntegration(ctx context.Context, cli client.Client, oldRelease common.Release, applicationNS string) error <span class="cov5" title="4">{
        var errs *multierror.Error

        if oldRelease.Version.Minor &gt;= 14 &amp;&amp; oldRelease.Version.Minor &lt;= 16 </span><span class="cov0" title="0">{
                log := logf.FromContext(ctx)
                type objForDel struct {
                        obj        client.Object
                        name, desc string
                }

                // the following objects created by TP (14-15) and by the first GA (16)
                deleteObjs := []objForDel{
                        {
                                obj:  &amp;corev1.ConfigMap{},
                                name: "nvidia-nim-images-data",
                                desc: "data ConfigMap",
                        },
                        {
                                obj:  &amp;templatev1.Template{},
                                name: "nvidia-nim-serving-template",
                                desc: "runtime Template",
                        },
                        {
                                obj:  &amp;corev1.Secret{},
                                name: "nvidia-nim-image-pull",
                                desc: "pull Secret",
                        },
                }

                // the following objects created by TP (14-15)
                if oldRelease.Version.Minor &lt; 16 </span><span class="cov0" title="0">{
                        deleteObjs = append(deleteObjs,
                                objForDel{
                                        obj:  &amp;batchv1.CronJob{},
                                        name: "nvidia-nim-periodic-validator",
                                        desc: "validator CronJob",
                                },
                                objForDel{
                                        obj:  &amp;corev1.ConfigMap{},
                                        name: "nvidia-nim-validation-result",
                                        desc: "validation result ConfigMap",
                                },
                                // the api key is also used by GA (16), but cleanup is only required for TP-&gt;GA switch
                                objForDel{
                                        obj:  &amp;corev1.Secret{},
                                        name: "nvidia-nim-access",
                                        desc: "API key Secret",
                                })
                }</span>

                <span class="cov0" title="0">for _, delObj := range deleteObjs </span><span class="cov0" title="0">{
                        if gErr := cli.Get(ctx, types.NamespacedName{Name: delObj.name, Namespace: applicationNS}, delObj.obj); gErr != nil </span><span class="cov0" title="0">{
                                if !k8serr.IsNotFound(gErr) </span><span class="cov0" title="0">{
                                        log.V(1).Error(gErr, "failed to get NIM", "desc", delObj.desc, "name", delObj.name)
                                        errs = multierror.Append(errs, gErr)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if dErr := cli.Delete(ctx, delObj.obj); dErr != nil </span><span class="cov0" title="0">{
                                        log.Error(dErr, "failed to remove NIM", "desc", delObj.desc, "name", delObj.name)
                                        errs = multierror.Append(errs, dErr)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Info("removed NIM successfully", "desc", delObj.desc)
                                }</span>
                        }
                }
        }

        <span class="cov5" title="4">return errs.ErrorOrNil()</span>
}

// When upgrading from version 2.16 to 2.17, the odh-model-controller
// fails to be provisioned due to the immutability of the deployment's
// label selectors. In RHOAI ≤ 2.16, the model controller was deployed
// independently by both kserve and modelmesh, leading to variations
// in label assignments depending on the deployment order. During a
// redeployment or upgrade, this error was ignored, and the model
// controller would eventually be reconciled by the appropriate component.
//
// However, in version 2.17, the model controller is now a defined
// dependency with its own fixed labels and selectors. This change
// causes issues during upgrades, as existing deployments cannot be
// modified accordingly.
//
// This function as to stay as long as there is any long term support
// release based on the old logic.
func cleanupModelControllerLegacyDeployment(ctx context.Context, cli client.Client, applicationNS string) error <span class="cov5" title="4">{
        l := logf.FromContext(ctx)

        d := appsv1.Deployment{}
        d.Name = "odh-model-controller"
        d.Namespace = applicationNS

        err := cli.Get(ctx, client.ObjectKeyFromObject(&amp;d), &amp;d)
        switch </span>{
        case k8serr.IsNotFound(err):<span class="cov5" title="4">
                return nil</span>
        case err != nil:<span class="cov0" title="0">
                return fmt.Errorf("failure getting %s deployment in namespace %s: %w", d.Name, d.Namespace, err)</span>
        }

        <span class="cov0" title="0">if d.Labels[labels.PlatformPartOf] == componentApi.ModelControllerComponentName </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">l.Info("deleting legacy deployment", "name", d.Name, "namespace", d.Namespace)

        err = cli.Delete(ctx, &amp;d, client.PropagationPolicy(metav1.DeletePropagationForeground))
        switch </span>{
        case k8serr.IsNotFound(err):<span class="cov0" title="0">
                return nil</span>
        case err != nil:<span class="cov0" title="0">
                return fmt.Errorf("failure deleting %s deployment in namespace %s: %w", d.Name, d.Namespace, err)</span>
        }

        <span class="cov0" title="0">l.Info("legacy deployment deleted", "name", d.Name, "namespace", d.Namespace)

        return nil</span>
}

// cleanupDeprecatedKueueVAPB removes the deprecated ValidatingAdmissionPolicyBinding
// that was used in previous versions of Kueue but is no longer needed.
// TODO: Remove this cleanup function in a future release when upgrading from versions
// that contained ValidatingAdmissionPolicyBinding resources (&lt; v2.29.0) is no longer supported.
// This cleanup is only needed for upgrade scenarios from versions that included VAP manifests
// in config/kueue-configs/ocp-4.17-addons/ directory.
func cleanupDeprecatedKueueVAPB(ctx context.Context, cli client.Client) error <span class="cov5" title="4">{
        log := logf.FromContext(ctx)

        // Use the proper ValidatingAdmissionPolicyBinding struct instead of unstructured
        vapb := &amp;admissionregistrationv1.ValidatingAdmissionPolicyBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name: "kueue-validating-admission-policy-binding",
                },
        }

        // Attempt to delete the resource
        err := cli.Delete(ctx, vapb)
        // VAPB is not a CRD but a core type from k8s, we wanna ensure API version is correct
        if client.IgnoreNotFound(err) != nil &amp;&amp; !meta.IsNoMatchError(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete deprecated ValidatingAdmissionPolicyBinding: %w", err)
        }</span>

        <span class="cov5" title="4">if err == nil </span><span class="cov3" title="2">{
                log.Info("Successfully deleted deprecated ValidatingAdmissionPolicyBinding")
        }</span>

        <span class="cov5" title="4">return nil</span>
}

// TODO: to be removed: https://issues.redhat.com/browse/RHOAIENG-21080
func PatchOdhDashboardConfig(ctx context.Context, cli client.Client, prevVersion, currVersion common.Release) error <span class="cov7" title="6">{
        log := logf.FromContext(ctx).WithValues(
                "prevVersion", prevVersion.Version.Version,
                "currVersion", currVersion.Version.Version,
                "action", "migration logic for dashboard",
                "kind", "OdhDashboardConfig",
        )

        if !prevVersion.Version.LT(currVersion.Version.Version) </span><span class="cov3" title="2">{
                log.Info("Skipping patch as current version is not greater than previous version")
                return nil
        }</span>

        <span class="cov6" title="5">dashboardConfig := resources.GvkToUnstructured(gvk.OdhDashboardConfig)

        if err := cluster.GetSingleton(ctx, cli, dashboardConfig); err != nil </span><span class="cov3" title="2">{
                if meta.IsNoMatchError(err) </span><span class="cov3" title="2">{
                        log.Info("OdhDashboardConfig CRD is not installed, skipping patch")
                        return nil
                }</span>
                <span class="cov0" title="0">if k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Info("no odhdashboard instance available, hence skipping patch", "namespace", dashboardConfig.GetNamespace(), "name", dashboardConfig.GetName())
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to retrieve odhdashboardconfg instance: %w", err)</span>
        }
        <span class="cov5" title="4">log = log.WithValues(
                "namespace", dashboardConfig.GetNamespace(),
                "name", dashboardConfig.GetName(),
        )
        log.Info("Found CR, applying patch")

        patch := dashboardConfig.DeepCopy()
        updates := map[string][]any{
                "notebookSizes":    NotebookSizesData,
                "modelServerSizes": ModelServerSizeData,
        }

        updated, err := updateSpecFields(patch, updates)
        if err != nil </span><span class="cov3" title="2">{
                return fmt.Errorf("failed to update odhdashboardconfig spec fields: %w", err)
        }</span>

        <span class="cov4" title="3">if !updated </span><span class="cov3" title="2">{
                log.Info("No changes needed, skipping patch")
                return nil
        }</span>

        <span class="cov3" title="2">if err := cli.Patch(ctx, patch, client.MergeFrom(dashboardConfig)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to patch CR %s in namespace %s: %w", dashboardConfig.GetName(), dashboardConfig.GetNamespace(), err)
        }</span>

        <span class="cov3" title="2">log.Info("Patched odhdashboardconfig successfully")

        return nil</span>
}

// TODO: to be removed: https://issues.redhat.com/browse/RHOAIENG-21080
func updateSpecFields(obj *unstructured.Unstructured, updates map[string][]any) (bool, error) <span class="cov5" title="4">{
        updated := false

        for field, newData := range updates </span><span class="cov7" title="6">{
                existingField, exists, err := unstructured.NestedSlice(obj.Object, "spec", field)
                if err != nil </span><span class="cov3" title="2">{
                        return false, fmt.Errorf("failed to get field '%s': %w", field, err)
                }</span>

                <span class="cov6" title="5">if !exists || len(existingField) == 0 </span><span class="cov4" title="3">{
                        if err := unstructured.SetNestedSlice(obj.Object, newData, "spec", field); err != nil </span><span class="cov0" title="0">{
                                return false, fmt.Errorf("failed to set field '%s': %w", field, err)
                        }</span>
                        <span class="cov4" title="3">updated = true</span>
                }
        }

        <span class="cov4" title="3">return updated, nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package jq

import (
        "fmt"

        "github.com/itchyny/gojq"
        "github.com/onsi/gomega/format"
        "github.com/onsi/gomega/types"
)

func Match(format string, args ...any) *Matcher <span class="cov10" title="21">{
        return &amp;Matcher{
                expression: fmt.Sprintf(format, args...),
        }
}</span>

var _ types.GomegaMatcher = &amp;Matcher{}

type Matcher struct {
        expression       string
        firstFailurePath []interface{}
}

func (matcher *Matcher) Match(actual interface{}) (bool, error) <span class="cov10" title="21">{
        query, err := gojq.Parse(matcher.expression)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("unable to parse expression %s, %w", matcher.expression, err)
        }</span>

        <span class="cov10" title="21">data, err := toType(actual)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov10" title="21">it := query.Run(data)

        v, ok := it.Next()
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov10" title="21">if err, ok := v.(error); ok </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov10" title="21">if match, ok := v.(bool); ok </span><span class="cov10" title="21">{
                return match, nil
        }</span>

        <span class="cov0" title="0">return false, nil</span>
}

func (matcher *Matcher) FailureMessage(actual interface{}) string <span class="cov0" title="0">{
        return formattedMessage(format.Message(fmt.Sprintf("%v", actual), "to match expression", matcher.expression), matcher.firstFailurePath)
}</span>

func (matcher *Matcher) NegatedFailureMessage(actual interface{}) string <span class="cov0" title="0">{
        return formattedMessage(format.Message(fmt.Sprintf("%v", actual), "not to match expression", matcher.expression), matcher.firstFailurePath)
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">package jq

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "reflect"
        "strings"

        "github.com/onsi/gomega/format"
        "github.com/onsi/gomega/gbytes"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

func formattedMessage(comparisonMessage string, failurePath []interface{}) string <span class="cov0" title="0">{
        diffMessage := ""

        if len(failurePath) != 0 </span><span class="cov0" title="0">{
                diffMessage = "\n\nfirst mismatched key: " + formattedFailurePath(failurePath)
        }</span>

        <span class="cov0" title="0">return comparisonMessage + diffMessage</span>
}

func formattedFailurePath(failurePath []interface{}) string <span class="cov0" title="0">{
        formattedPaths := make([]string, 0)

        for i := len(failurePath) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                switch p := failurePath[i].(type) </span>{
                case int:<span class="cov0" title="0">
                        val := fmt.Sprintf(`[%d]`, p)
                        formattedPaths = append(formattedPaths, val)</span>
                default:<span class="cov0" title="0">
                        if i != len(failurePath)-1 </span><span class="cov0" title="0">{
                                formattedPaths = append(formattedPaths, ".")
                        }</span>

                        <span class="cov0" title="0">val := fmt.Sprintf(`"%s"`, p)
                        formattedPaths = append(formattedPaths, val)</span>
                }
        }

        <span class="cov0" title="0">return strings.Join(formattedPaths, "")</span>
}

//nolint:cyclop
func toType(in any) (any, error) <span class="cov10" title="37">{
        valof := reflect.ValueOf(in)
        if !valof.IsValid() </span><span class="cov3" title="3">{
                return nil, nil
        }</span>
        <span class="cov9" title="36">if valof.Kind() == reflect.Ptr &amp;&amp; valof.IsNil() </span><span class="cov3" title="3">{
                return nil, nil
        }</span>

        <span class="cov9" title="35">switch v := in.(type) </span>{
        case string:<span class="cov7" title="14">
                d, err := byteToType([]byte(v))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov7" title="14">return d, nil</span>
        case []byte:<span class="cov6" title="9">
                d, err := byteToType(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov6" title="9">return d, nil</span>
        case json.RawMessage:<span class="cov3" title="3">
                d, err := byteToType(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov3" title="3">return d, nil</span>
        case *gbytes.Buffer:<span class="cov3" title="3">
                d, err := byteToType(v.Contents())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov3" title="3">return d, nil</span>
        case io.Reader:<span class="cov3" title="3">
                data, err := io.ReadAll(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read from reader: %w", err)
                }</span>

                <span class="cov3" title="3">d, err := byteToType(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov3" title="3">return d, nil</span>
        case unstructured.UnstructuredList:<span class="cov3" title="3">
                res := make([]any, 0, len(v.Items))
                for i := range v.Items </span><span class="cov3" title="3">{
                        res = append(res, v.Items[i].Object)
                }</span>
                <span class="cov3" title="3">return res, nil</span>
        case []unstructured.Unstructured:<span class="cov3" title="3">
                res := make([]any, 0, len(v))
                for i := range v </span><span class="cov3" title="3">{
                        res = append(res, v[i].Object)
                }</span>
                <span class="cov3" title="3">return res, nil</span>
        case unstructured.Unstructured:<span class="cov3" title="3">
                return v.Object, nil</span>
        case []*unstructured.Unstructured:<span class="cov0" title="0">
                res := make([]any, 0, len(v))
                for i := range v </span><span class="cov0" title="0">{
                        res = append(res, v[i].Object)
                }</span>
                <span class="cov0" title="0">return res, nil</span>
        case *unstructured.Unstructured:<span class="cov3" title="3">
                return v.Object, nil</span>
        }

        <span class="cov6" title="9">switch reflect.TypeOf(in).Kind() </span>{
        case reflect.Map:<span class="cov6" title="8">
                return in, nil</span>
        case reflect.Slice:<span class="cov3" title="3">
                return in, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsuported type:\n%s", format.Object(in, 1))</span>
        }
}

func byteToType(in []byte) (any, error) <span class="cov9" title="29">{
        if len(in) == 0 </span><span class="cov3" title="3">{
                return nil, errors.New("a valid Json document is expected")
        }</span>

        <span class="cov9" title="28">switch in[0] </span>{
        case '{':<span class="cov9" title="25">
                data := make(map[string]any)
                if err := json.Unmarshal(in, &amp;data); err != nil </span><span class="cov3" title="3">{
                        return nil, fmt.Errorf("unable to unmarshal result, %w", err)
                }</span>

                <span class="cov8" title="24">return data, nil</span>
        case '[':<span class="cov4" title="4">
                var data []any
                if err := json.Unmarshal(in, &amp;data); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to unmarshal result, %w", err)
                }</span>

                <span class="cov4" title="4">return data, nil</span>
        default:<span class="cov3" title="3">
                return nil, errors.New("a Json Array or Object is required")</span>
        }
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package jq

import (
        "fmt"

        "github.com/itchyny/gojq"
)

func Extract(expression string) func(in any) (any, error) <span class="cov7" title="4">{
        return func(in any) (any, error) </span><span class="cov7" title="4">{
                return ExtractValue[any](in, expression)
        }</span>
}

func ExtractValue[T any](in any, expression string) (T, error) <span class="cov10" title="6">{
        var result T
        var ok bool

        query, err := gojq.Parse(expression)
        if err != nil </span><span class="cov0" title="0">{
                return result, fmt.Errorf("unable to parse expression %s, %w", expression, err)
        }</span>

        <span class="cov10" title="6">data, err := toType(in)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov10" title="6">it := query.Run(data)

        v, ok := it.Next()
        if !ok </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov10" title="6">if err, ok := v.(error); ok </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov10" title="6">result, ok = v.(T)
        if !ok </span><span class="cov0" title="0">{
                return result, fmt.Errorf("result value is not of the expected type (expected:%T, got:%T", result, v)
        }</span>

        <span class="cov10" title="6">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package testf

import (
        "context"
        "errors"
        "fmt"
        "testing"
        "time"

        "github.com/onsi/gomega"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/rest"
        "sigs.k8s.io/controller-runtime/pkg/client"
        ctrlcfg "sigs.k8s.io/controller-runtime/pkg/client/config"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/utils/test/scheme"
)

const (
        DefaultPollInterval = 1 * time.Second
        DefaultTimeout      = 2 * time.Minute
)

type testContextOpts struct {
        ctx       context.Context
        cfg       *rest.Config
        client    client.Client
        scheme    *runtime.Scheme
        withTOpts []WithTOpts
}

type TestContextOpt func(testContext *testContextOpts)

func WithClient(value client.Client) TestContextOpt <span class="cov8" title="1">{
        return func(tc *testContextOpts) </span><span class="cov8" title="1">{
                tc.client = value
        }</span>
}

func WithRestConfig(value *rest.Config) TestContextOpt <span class="cov0" title="0">{
        return func(tc *testContextOpts) </span><span class="cov0" title="0">{
                tc.cfg = value
        }</span>
}

func WithScheme(value *runtime.Scheme) TestContextOpt <span class="cov0" title="0">{
        return func(tc *testContextOpts) </span><span class="cov0" title="0">{
                tc.scheme = value
        }</span>
}

func WithContext(value context.Context) TestContextOpt <span class="cov0" title="0">{
        return func(tc *testContextOpts) </span><span class="cov0" title="0">{
                tc.ctx = value
        }</span>
}

func WithTOptions(opts ...WithTOpts) TestContextOpt <span class="cov8" title="1">{
        return func(tc *testContextOpts) </span><span class="cov8" title="1">{
                tc.withTOpts = append(tc.withTOpts, opts...)
        }</span>
}

func NewTestContext(opts ...TestContextOpt) (*TestContext, error) <span class="cov8" title="1">{
        tco := testContextOpts{}
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;tco)
        }</span>

        <span class="cov8" title="1">tc := TestContext{
                ctx:       tco.ctx,
                scheme:    tco.scheme,
                client:    tco.client,
                withTOpts: tco.withTOpts,
        }

        if tc.ctx == nil </span><span class="cov8" title="1">{
                tc.ctx = context.Background()
        }</span>

        <span class="cov8" title="1">if tc.scheme == nil </span><span class="cov8" title="1">{
                s, err := scheme.New()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("unable to create default scheme")
                }</span>

                <span class="cov8" title="1">tc.scheme = s</span>
        }

        <span class="cov8" title="1">if tc.client == nil </span><span class="cov0" title="0">{
                clientCfg := tco.cfg
                if clientCfg == nil </span><span class="cov0" title="0">{
                        cfg, err := ctrlcfg.GetConfig()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error creating the config object %w", err)
                        }</span>

                        <span class="cov0" title="0">clientCfg = cfg</span>
                }

                <span class="cov0" title="0">ctrlCli, err := client.New(clientCfg, client.Options{Scheme: tc.scheme})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to initialize custom client: %w", err)
                }</span>

                <span class="cov0" title="0">tc.client = ctrlCli</span>
        }

        <span class="cov8" title="1">return &amp;tc, nil</span>
}

type TestContext struct {
        ctx    context.Context
        client client.Client
        scheme *runtime.Scheme

        withTOpts []WithTOpts
}

func (tc *TestContext) Context() context.Context <span class="cov0" title="0">{
        return tc.ctx
}</span>

func (tc *TestContext) Client() client.Client <span class="cov0" title="0">{
        return tc.client
}</span>

func (tc *TestContext) Scheme() *runtime.Scheme <span class="cov0" title="0">{
        return tc.client.Scheme()
}</span>

func (tc *TestContext) NewWithT(t *testing.T, opts ...WithTOpts) *WithT <span class="cov8" title="1">{
        t.Helper()

        g := gomega.NewWithT(t)
        g.SetDefaultEventuallyTimeout(DefaultTimeout)
        g.SetDefaultEventuallyPollingInterval(DefaultPollInterval)
        g.SetDefaultConsistentlyDuration(DefaultTimeout)
        g.SetDefaultConsistentlyPollingInterval(DefaultPollInterval)

        answer := WithT{
                ctx:    tc.ctx,
                client: tc.client,
                WithT:  g,
        }

        for _, opt := range tc.withTOpts </span><span class="cov8" title="1">{
                opt(&amp;answer)
        }</span>

        <span class="cov8" title="1">for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;answer)
        }</span>

        <span class="cov8" title="1">return &amp;answer</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package testf

import (
        "context"
        "errors"
        "sync/atomic"
        "time"

        "github.com/onsi/gomega"
        "github.com/onsi/gomega/matchers"
        "github.com/onsi/gomega/types"
)

type Mode int

const (
        eventually Mode = iota
        consistently
)

type EventuallyValue[T any] struct {
        ctx context.Context
        g   *gomega.WithT
        f   func(context.Context) (T, error)
}

func (e *EventuallyValue[T]) Get() (T, error) <span class="cov8" title="1">{
        v, err := e.f(e.ctx)

        var pse gomega.PollingSignalError
        if errors.As(err, &amp;pse) </span><span class="cov0" title="0">{
                if ue := errors.Unwrap(err); ue != nil </span><span class="cov0" title="0">{
                        err = ue
                }</span>
        }

        <span class="cov8" title="1">return v, err</span>
}

func (e *EventuallyValue[T]) Eventually(args ...interface{}) *Assertion[T] <span class="cov8" title="1">{
        return &amp;Assertion[T]{
                ctx:     e.ctx,
                g:       e.g,
                f:       e.f,
                args:    args,
                m:       eventually,
                timeout: e.g.DurationBundle.EventuallyTimeout,
                polling: e.g.DurationBundle.EventuallyPollingInterval,
        }
}</span>

func (e *EventuallyValue[T]) Consistently(args ...interface{}) *Assertion[T] <span class="cov8" title="1">{
        return &amp;Assertion[T]{
                ctx:     e.ctx,
                g:       e.g,
                f:       e.f,
                args:    args,
                m:       consistently,
                timeout: e.g.DurationBundle.ConsistentlyDuration,
                polling: e.g.DurationBundle.ConsistentlyPollingInterval,
        }
}</span>

type Assertion[T any] struct {
        ctx  context.Context
        g    *gomega.WithT
        f    func(context.Context) (T, error)
        args []interface{}

        m Mode

        timeout time.Duration
        polling time.Duration
}

func (a *Assertion[T]) WithTimeout(interval time.Duration) *Assertion[T] <span class="cov8" title="1">{
        a.timeout = interval
        return a
}</span>

func (a *Assertion[T]) WithPolling(interval time.Duration) *Assertion[T] <span class="cov0" title="0">{
        a.polling = interval
        return a
}</span>

func (a *Assertion[T]) WithContext(ctx context.Context) *Assertion[T] <span class="cov0" title="0">{
        a.ctx = ctx
        return a
}</span>

func (a *Assertion[T]) build(f interface{}) gomega.AsyncAssertion <span class="cov8" title="1">{
        var aa gomega.AsyncAssertion

        switch a.m </span>{
        case eventually:<span class="cov8" title="1">
                aa = a.g.Eventually(f, a.args...)</span>
        case consistently:<span class="cov8" title="1">
                aa = a.g.Consistently(f, a.args...)</span>
        default:<span class="cov0" title="0">
                panic("unsupported mode")</span>
        }

        <span class="cov8" title="1">aa = aa.WithContext(a.ctx)

        if a.timeout &gt; 0 </span><span class="cov8" title="1">{
                aa = aa.WithTimeout(a.timeout)
        }</span>
        <span class="cov8" title="1">if a.polling &gt; 0 </span><span class="cov8" title="1">{
                aa = aa.WithPolling(a.polling)
        }</span>

        <span class="cov8" title="1">return aa</span>
}

//nolint:dupl
func (a *Assertion[T]) Should(matcher types.GomegaMatcher, optionalDescription ...interface{}) T <span class="cov8" title="1">{
        var res atomic.Value
        var wrapper interface{}

        switch matcher.(type) </span>{
        case *matchers.SucceedMatcher:<span class="cov8" title="1">
                wrapper = func(ctx context.Context) error </span><span class="cov8" title="1">{
                        v, err := a.f(ctx)
                        res.Store(v)

                        return err
                }</span>
        case *matchers.MatchErrorMatcher:<span class="cov0" title="0">
                wrapper = func(ctx context.Context) error </span><span class="cov0" title="0">{
                        v, err := a.f(ctx)
                        res.Store(v)

                        return err
                }</span>
        default:<span class="cov8" title="1">
                wrapper = func(ctx context.Context) (T, error) </span><span class="cov8" title="1">{
                        v, err := a.f(ctx)
                        res.Store(v)

                        return v, err
                }</span>
        }

        <span class="cov8" title="1">a.build(wrapper).Should(matcher, optionalDescription...)

        //nolint:forcetypeassert,errcheck
        return res.Load().(T)</span>
}

//nolint:dupl
func (a *Assertion[T]) ShouldNot(matcher types.GomegaMatcher, optionalDescription ...interface{}) T <span class="cov8" title="1">{
        var res atomic.Value
        var wrapper interface{}

        switch matcher.(type) </span>{
        case *matchers.SucceedMatcher:<span class="cov0" title="0">
                wrapper = func(ctx context.Context) error </span><span class="cov0" title="0">{
                        v, err := a.f(ctx)
                        res.Store(v)

                        return err
                }</span>
        case *matchers.MatchErrorMatcher:<span class="cov0" title="0">
                wrapper = func(ctx context.Context) error </span><span class="cov0" title="0">{
                        v, err := a.f(ctx)
                        res.Store(v)

                        return err
                }</span>
        default:<span class="cov8" title="1">
                wrapper = func(ctx context.Context) (T, error) </span><span class="cov8" title="1">{
                        v, err := a.f(ctx)
                        res.Store(v)

                        return v, err
                }</span>
        }

        <span class="cov8" title="1">a.build(wrapper).ShouldNot(matcher, optionalDescription...)

        //nolint:forcetypeassert,errcheck
        return res.Load().(T)</span>
}

type EventuallyErr struct {
        ctx context.Context
        g   *gomega.WithT
        f   func(context.Context) error
}

func (e *EventuallyErr) Get() error <span class="cov8" title="1">{
        err := e.f(e.ctx)

        var pse gomega.PollingSignalError
        if errors.As(err, &amp;pse) </span><span class="cov0" title="0">{
                if ue := errors.Unwrap(err); ue != nil </span><span class="cov0" title="0">{
                        err = ue
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

func (e *EventuallyErr) Eventually() types.AsyncAssertion <span class="cov8" title="1">{
        return e.g.Eventually(e.ctx, e.f).
                WithContext(e.ctx).
                WithTimeout(e.g.DurationBundle.EventuallyTimeout).
                WithPolling(e.g.DurationBundle.EventuallyPollingInterval)
}</span>

func (e *EventuallyErr) Consistently() types.AsyncAssertion <span class="cov8" title="1">{
        return e.g.Consistently(e.ctx, e.f).
                WithContext(e.ctx).
                WithTimeout(e.g.DurationBundle.ConsistentlyDuration).
                WithPolling(e.g.DurationBundle.ConsistentlyPollingInterval)
}</span>
</pre>
		
		<pre class="file" id="file144" style="display: none">package testf

import (
        "fmt"

        "github.com/itchyny/gojq"
        "github.com/onsi/gomega"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
)

// StopErr stops the retry process with a specified message and wraps the provided error.
//
// This function leverages Gomega's StopTrying function to signal an end to retrying operations
// when a condition is not satisfied or an error occurs. It enhances the error output
// by wrapping the original error (if any) with the provided message.
//
// Parameters:
//   - err: An error to wrap.
//   - message: A string message that describes the reason for stopping retries.
//
// Returns:
//
//        An error that combines the stopping message and the wrapped error.
//
// Example usage:
//
//        err := someOperation()
//        if err != nil {
//            return StopErr(err, "Operation failed")
//        }
func StopErr(err error, format string, args ...any) error <span class="cov0" title="0">{
        msg := format
        if len(args) != 0 </span><span class="cov0" title="0">{
                msg = fmt.Sprintf(format, args...)
        }</span>

        <span class="cov0" title="0">return gomega.StopTrying(msg).Wrap(err)</span>
}

// TransformFn defines a function type that takes an *unstructured.Unstructured object
// and applies a transformation to it. The function returns an error if the transformation fails.
type TransformFn func(obj *unstructured.Unstructured) error

// TransformPipeline constructs a composite TransformFn from a series of TransformFn steps.
// It returns a single TransformFn that applies each step sequentially to the given object.
//
// If any step returns an error, the pipeline terminates immediately and returns that error.
// If all steps succeed, the pipeline returns nil.
func TransformPipeline(steps ...TransformFn) TransformFn <span class="cov8" title="1">{
        return func(obj *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                for _, step := range steps </span><span class="cov8" title="1">{
                        err := step(obj)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }
}

// Transform creates a transformation function that applies a JQ-like query expression to an
// unstructured Kubernetes object (`unstructured.Unstructured`), allowing dynamic field extraction,
// modification, or replacement of the object's content.
//
// This function generates a transformation function by formatting a query string using
// the provided format and arguments. The returned function can be applied to an
// `*unstructured.Unstructured` object, which will be updated based on the result of the query.
//
// Parameters:
//   - format: A format string for building a JQ-like query expression.
//   - args: Variadic arguments to populate placeholders in the format string.
//
// Returns:
//   - func(*unstructured.Unstructured) error: A function that applies the formatted query to
//     the provided `*unstructured.Unstructured` object and updates its content.
func Transform(format string, args ...any) TransformFn <span class="cov8" title="1">{
        expression := fmt.Sprintf(format, args...)

        return func(in *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                query, err := gojq.Parse(expression)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to parse expression %q: %w", expression, err)
                }</span>

                <span class="cov8" title="1">result, ok := query.Run(in.Object).Next()
                if !ok || result == nil </span><span class="cov8" title="1">{
                        // No results or nil result, nothing to update
                        return nil
                }</span>

                <span class="cov8" title="1">if err, ok := result.(error); ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("query execution error: %w", err)
                }</span>

                <span class="cov8" title="1">uc, ok := result.(map[string]interface{})
                if !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected map[string]interface{}, got %T", result)
                }</span>

                <span class="cov8" title="1">in.SetUnstructuredContent(uc)

                return nil</span>
        }
}

// TransformSpecToUnstructured creates a transformation function that converts a Go struct
// representing a Kubernetes resource spec into an unstructured format and applies it to
// the spec field of an unstructured Kubernetes object (`unstructured.Unstructured`).
//
// Parameters:
//   - spec: A Go struct representing the spec of a Kubernetes resource (e.g., SubscriptionSpec, PodSpec).
//     This struct will be converted into an unstructured format and applied to the `spec` field.
//
// Returns:
//   - func(*unstructured.Unstructured) error: A function that applies the unstructured spec data
//     to the provided `*unstructured.Unstructured` object. If the conversion or update fails, an error is returned.
func TransformSpecToUnstructured(spec interface{}) TransformFn <span class="cov0" title="0">{
        return func(in *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                // Convert the spec to unstructured format
                specData, err := runtime.DefaultUnstructuredConverter.ToUnstructured(spec)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert spec to unstructured: %w", err)
                }</span>

                // Set the spec in the unstructured object
                <span class="cov0" title="0">in.Object["spec"] = specData

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file145" style="display: none">package testf

import (
        "context"
        "time"

        "github.com/onsi/gomega"
        gomegaTypes "github.com/onsi/gomega/types"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"

        "github.com/opendatahub-io/opendatahub-operator/v2/pkg/resources"
)

// WithT encapsulates the test context and the Kubernetes client, along with gomega's assertion methods.
// It provides utility methods to interact with resources in a Kubernetes cluster and perform assertions on them.
type WithT struct {
        ctx    context.Context
        client client.Client

        *gomega.WithT
}

// WithTOpts is a function type used to configure options for the WithT object.
// These options modify the behavior of the tests, such as timeouts and polling intervals.
type WithTOpts func(*WithT)

func WithFailHandler(value gomegaTypes.GomegaFailHandler) WithTOpts <span class="cov8" title="1">{
        return func(g *WithT) </span><span class="cov8" title="1">{
                g.WithT = g.ConfigureWithFailHandler(value)
        }</span>
}

// WithEventuallyTimeout sets the default timeout for Eventually assertions.
//
// Parameters:
//   - value (time.Duration): The timeout duration for Eventually assertions.
//
// Returns:
//   - WithTOpts: A function that applies the timeout configuration to a WithT instance.
func WithEventuallyTimeout(value time.Duration) WithTOpts <span class="cov8" title="1">{
        return func(g *WithT) </span><span class="cov8" title="1">{
                g.SetDefaultEventuallyTimeout(value)
        }</span>
}

// WithEventuallyPollingInterval sets the default polling interval for Eventually assertions.
//
// Parameters:
//   - value (time.Duration): The polling interval for Eventually assertions.
//
// Returns:
//   - WithTOpts: A function that applies the polling interval configuration to a WithT instance.
func WithEventuallyPollingInterval(value time.Duration) WithTOpts <span class="cov0" title="0">{
        return func(g *WithT) </span><span class="cov0" title="0">{
                g.SetDefaultEventuallyPollingInterval(value)
        }</span>
}

// WithConsistentlyDuration sets the default duration for Consistently assertions.
//
// Parameters:
//   - value (time.Duration): The duration for Consistently assertions.
//
// Returns:
//   - WithTOpts: A function that applies the duration configuration to a WithT instance.
func WithConsistentlyDuration(value time.Duration) WithTOpts <span class="cov0" title="0">{
        return func(g *WithT) </span><span class="cov0" title="0">{
                g.SetDefaultConsistentlyDuration(value)
        }</span>
}

// WithConsistentlyPollingInterval sets the default polling interval for Consistently assertions.
//
// Parameters:
//   - value (time.Duration): The polling interval for Consistently assertions.
//
// Returns:
//   - WithTOpts: A function that applies the polling interval configuration to a WithT instance.
func WithConsistentlyPollingInterval(value time.Duration) WithTOpts <span class="cov0" title="0">{
        return func(g *WithT) </span><span class="cov0" title="0">{
                g.SetDefaultConsistentlyPollingInterval(value)
        }</span>
}

// Context returns the current context associated with the test, used for resource operations.
//
// Returns:
//   - context.Context: The current context for the test, which can be used for Kubernetes operations.
func (t *WithT) Context() context.Context <span class="cov8" title="1">{
        return t.ctx
}</span>

// Client returns the `client.Client` used to interact with the cluster for resource operations.
//
// Returns:
//   - client.Client: The Kubernetes client used for performing operations on the cluster.
func (t *WithT) Client() client.Client <span class="cov8" title="1">{
        return t.client
}</span>

// List performs a `kubectl get` operation to list resources of the specified GroupVersionKind.
// It returns the list of resources wrapped in an EventuallyValue to be used with Gomega assertions.
//
// Parameters:
//   - gvk (schema.GroupVersionKind): The GroupVersionKind of the resources to list.
//   - option (...client.ListOption): Optional options to modify the list operation.
//
// Returns:
//   - *EventuallyValue[[]unstructured.Unstructured]: The eventually available list of resources wrapped in an EventuallyValue,
//     which can be used with Gomega assertions to test the list result.
func (t *WithT) List(
        gvk schema.GroupVersionKind,
        option ...client.ListOption,
) *EventuallyValue[[]unstructured.Unstructured] <span class="cov8" title="1">{
        return &amp;EventuallyValue[[]unstructured.Unstructured]{
                ctx: t.Context(),
                g:   t.WithT,
                f: func(ctx context.Context) ([]unstructured.Unstructured, error) </span><span class="cov8" title="1">{
                        items := unstructured.UnstructuredList{}
                        items.SetGroupVersionKind(gvk)

                        err := t.Client().List(ctx, &amp;items, option...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, StopErr(err, "failed to list resource: %s", gvk)
                        }</span>

                        <span class="cov8" title="1">return items.Items, nil</span>
                },
        }
}

// Get performs a `kubectl get` operation for the specified resource and returns the resource wrapped in an EventuallyValue.
// The result can be used in Gomega assertions to test the resource's existence and state.
//
// Parameters:
//   - gvk (schema.GroupVersionKind): The GroupVersionKind of the resource to get.
//   - nn (types.NamespacedName): The namespace and name of the resource to get.
//   - option (...client.GetOption): Optional options for the get operation.
//
// Returns:
//   - *EventuallyValue[*unstructured.Unstructured]: The eventually available resource wrapped in an EventuallyValue,
//     which can be used with Gomega assertions to test the resource's state.
func (t *WithT) Get(
        gvk schema.GroupVersionKind,
        nn types.NamespacedName,
        option ...client.GetOption,
) *EventuallyValue[*unstructured.Unstructured] <span class="cov8" title="1">{
        return &amp;EventuallyValue[*unstructured.Unstructured]{
                ctx: t.Context(),
                g:   t.WithT,
                f: func(ctx context.Context) (*unstructured.Unstructured, error) </span><span class="cov8" title="1">{
                        u := unstructured.Unstructured{}
                        u.SetGroupVersionKind(gvk)

                        err := t.Client().Get(ctx, nn, &amp;u, option...)
                        switch </span>{
                        case errors.IsNotFound(err):<span class="cov8" title="1">
                                return nil, nil</span>
                        case err != nil:<span class="cov0" title="0">
                                return nil, StopErr(err, "failed to get resource: %s, nn: %s", gvk, nn.String())</span>
                        default:<span class="cov8" title="1">
                                return &amp;u, nil</span>
                        }
                },
        }
}

// Create performs a `kubectl create` operation to create the specified Kubernetes resource.
// It returns an EventuallyValue that wraps the created resource, which can be used with Gomega assertions.
//
// Parameters:
//   - obj (*unstructured.Unstructured): The resource to create. It must have the appropriate GroupVersionKind,
//     name, and namespace set in its metadata.
//   - nn (types.NamespacedName): The namespace and name of the resource. This should match the metadata in `obj`.
//   - option (...client.CreateOption): Optional client options for the create operation.
//
// Returns:
//   - *EventuallyValue[*unstructured.Unstructured]: The eventually available created resource, wrapped in an EventuallyValue,
//     which can be used with Gomega assertions to test the created resource.
func (t *WithT) Create(
        obj *unstructured.Unstructured,
        nn types.NamespacedName,
        option ...client.CreateOption,
) *EventuallyValue[*unstructured.Unstructured] <span class="cov0" title="0">{
        return &amp;EventuallyValue[*unstructured.Unstructured]{
                ctx: t.Context(),
                g:   t.WithT,
                f: func(ctx context.Context) (*unstructured.Unstructured, error) </span><span class="cov0" title="0">{
                        err := t.Client().Create(ctx, obj, option...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, StopErr(err, "failed to create resource: %s, nn: %s", obj.GetObjectKind().GroupVersionKind(), nn.String())
                        }</span>

                        <span class="cov0" title="0">return obj, nil</span>
                },
        }
}

// CreateOrUpdate ensures the specified resource exists by either creating it if it does not exist,
// or updating it if it already exists. This method applies the provided mutation function to modify
// the resource before creating or updating it. The function wraps `controllerutil.CreateOrUpdate`,
// ensuring that the resource is created or updated atomically.
//
// Parameters:
//   - gvk (schema.GroupVersionKind): The GroupVersionKind of the resource.
//   - nn (types.NamespacedName): The namespace and name of the resource to be operated on.
//   - fn (func): An optional function that applies a mutation to the resource before creation or update.
//     If omitted, the resource is created or updated without modification.
//
// Returns:
//   - *EventuallyValue[*unstructured.Unstructured]: The eventually available resource after being created or updated,
//     wrapped for use with Gomega assertions.
func (t *WithT) CreateOrUpdate(
        obj *unstructured.Unstructured,
        fn ...func(obj *unstructured.Unstructured) error,
) *EventuallyValue[*unstructured.Unstructured] <span class="cov0" title="0">{
        return &amp;EventuallyValue[*unstructured.Unstructured]{
                ctx: t.Context(),
                g:   t.WithT,
                f: func(ctx context.Context) (*unstructured.Unstructured, error) </span><span class="cov0" title="0">{
                        // Use the provided fn or a default no-op if fn is not provided
                        mutationFn := func() error </span><span class="cov0" title="0">{
                                if len(fn) &gt; 0 &amp;&amp; fn[0] != nil </span><span class="cov0" title="0">{
                                        return fn[0](obj) // Use the provided mutation function
                                }</span>
                                <span class="cov0" title="0">return nil</span> // Default no-op function if fn is omitted
                        }

                        <span class="cov0" title="0">_, err := controllerutil.CreateOrUpdate(ctx, t.Client(), obj, mutationFn)

                        switch </span>{
                        case errors.IsForbidden(err):<span class="cov0" title="0">
                                return nil, StopErr(
                                        err,
                                        "failed to create or update resource: %s, nn: %s",
                                        obj.GetObjectKind().GroupVersionKind(),
                                        obj.GetNamespace(),
                                )</span>
                        case err != nil:<span class="cov0" title="0">
                                return nil, err</span>
                        default:<span class="cov0" title="0">
                                return obj, nil</span>
                        }
                },
        }
}

// CreateOrPatch ensures the specified resource exists by either creating it if it does not exist,
// or applying a patch if the resource already exists. This function uses the
// `controllerutil.CreateOrPatch` method to handle the creation and patching operations atomically.
//
// Parameters:
//   - gvk (schema.GroupVersionKind): The GroupVersionKind of the resource to be operated on.
//   - nn (types.NamespacedName): The namespace and name of the resource to be created or patched.
//   - fn (func): A function that modifies the resource before creating or patching it.
//
// Returns:
//   - *EventuallyValue[*unstructured.Unstructured]: The eventually available resource after being created or patched.
func (t *WithT) CreateOrPatch(
        obj *unstructured.Unstructured,
        fn ...func(obj *unstructured.Unstructured) error,
) *EventuallyValue[*unstructured.Unstructured] <span class="cov0" title="0">{
        return &amp;EventuallyValue[*unstructured.Unstructured]{
                ctx: t.Context(),
                g:   t.WithT,
                f: func(ctx context.Context) (*unstructured.Unstructured, error) </span><span class="cov0" title="0">{
                        // Use the provided fn or a default no-op if fn is not provided
                        mutationFn := func() error </span><span class="cov0" title="0">{
                                // Remove status fields that should not be modified directly
                                unstructured.RemoveNestedField(obj.Object, "status")

                                if len(fn) &gt; 0 &amp;&amp; fn[0] != nil </span><span class="cov0" title="0">{
                                        return fn[0](obj) // Use the provided mutation function
                                }</span>

                                <span class="cov0" title="0">return nil</span> // Default no-op function if fn is omitted
                        }

                        <span class="cov0" title="0">_, err := controllerutil.CreateOrPatch(ctx, t.Client(), obj, mutationFn)

                        // Check for errors
                        switch </span>{
                        case err != nil:<span class="cov0" title="0">
                                return nil, StopErr(
                                        err,
                                        "failed to create or patch resource: %s, nn: %s",
                                        obj.GetObjectKind().GroupVersionKind(),
                                        obj.GetNamespace(),
                                )</span>
                        default:<span class="cov0" title="0">
                                return obj, nil</span> // Successfully created or patched
                        }
                },
        }
}

// Update performs a `kubectl update` operation on the specified resource, applying a function to mutate the resource
// before updating. The result is wrapped in an EventuallyValue, which can be used in Gomega assertions.
//
// Parameters:
//   - gvk (schema.GroupVersionKind): The GroupVersionKind of the resource to update.
//   - nn (types.NamespacedName): The namespace and name of the resource to update.
//   - fn (func): A function that modifies the resource before updating.
//   - option (...client.UpdateOption): Optional options for the update operation.
//
// Returns:
//   - *EventuallyValue[*unstructured.Unstructured]: The eventually available resource wrapped in an EventuallyValue,
//     which can be used with Gomega assertions to test the updated resource.
func (t *WithT) Update(
        gvk schema.GroupVersionKind,
        nn types.NamespacedName,
        fn func(obj *unstructured.Unstructured) error,
        option ...client.UpdateOption,
) *EventuallyValue[*unstructured.Unstructured] <span class="cov8" title="1">{
        return &amp;EventuallyValue[*unstructured.Unstructured]{
                ctx: t.Context(),
                g:   t.WithT,
                f: func(ctx context.Context) (*unstructured.Unstructured, error) </span><span class="cov8" title="1">{
                        u := resources.GvkToUnstructured(gvk)

                        err := t.Client().Get(ctx, nn, u)
                        switch </span>{
                        case errors.IsNotFound(err):<span class="cov0" title="0">
                                return nil, nil</span>
                        case err != nil:<span class="cov0" title="0">
                                return nil, StopErr(err, "failed to get resource: %s, nn: %s", gvk, nn.String())</span>
                        }

                        <span class="cov8" title="1">in, err := resources.ToUnstructured(u)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, StopErr(err, "failed to convert to unstructured")
                        }</span>

                        <span class="cov8" title="1">if err := fn(in); err != nil </span><span class="cov0" title="0">{
                                return nil, StopErr(err, "failed to apply function")
                        }</span>

                        <span class="cov8" title="1">err = t.Client().Update(ctx, in, option...)
                        switch </span>{
                        case errors.IsForbidden(err):<span class="cov0" title="0">
                                return nil, StopErr(err, "failed to update resource: %s, nn: %s", gvk, nn.String())</span>
                        case err != nil:<span class="cov0" title="0">
                                return nil, err</span>
                        default:<span class="cov8" title="1">
                                return in, nil</span>
                        }
                },
        }
}

// Delete performs a `kubectl delete` operation on the specified resource.
// It returns an EventuallyErr, which can be used in Gomega assertions to check for the deletion's success or failure.
//
// Parameters:
//   - gvk (schema.GroupVersionKind): The GroupVersionKind of the resource to delete.
//   - nn (types.NamespacedName): The namespace and name of the resource to delete.
//   - option (...client.DeleteOption): Optional options for the delete operation.
//
// Returns:
//   - *EventuallyErr: The eventually available result of the delete operation, wrapped in an EventuallyErr,
//     which can be used with Gomega assertions to test the deletion result.
func (t *WithT) Delete(
        gvk schema.GroupVersionKind,
        nn types.NamespacedName,
        option ...client.DeleteOption,
) *EventuallyErr <span class="cov8" title="1">{
        return &amp;EventuallyErr{
                ctx: t.Context(),
                g:   t.WithT,
                f: func(ctx context.Context) error </span><span class="cov8" title="1">{
                        u := resources.GvkToUnstructured(gvk)
                        u.SetName(nn.Name)
                        u.SetNamespace(nn.Namespace)

                        err := t.Client().Delete(ctx, u, option...)
                        switch </span>{
                        case errors.IsNotFound(err):<span class="cov8" title="1">
                                return nil</span>
                        case err != nil:<span class="cov0" title="0">
                                return StopErr(err, "failed to delete resource: %s, nn: %s", gvk, nn.String())</span>
                        default:<span class="cov8" title="1">
                                return nil</span>
                        }
                },
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
